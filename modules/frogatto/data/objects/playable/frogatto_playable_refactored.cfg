{
id: "frogatto_playable_refactored",
prototype: ["playable_refactored"],
hitpoints: 4,
mass: 5,
friction: 2000,
solid_area: [9,8,23,30],
traction_in_water: 1000,
affected_by_currents: true,
feet_width: 5,
zorder: "@include data/zorders.cfg:player",

editor_info: {
	help: "This object is the hero of Frogatto. Instances placed in-level will be ignored if there is already a playable character the player is playing.",
	category: "player",
},

//these spritesheets get switched for fat frogatto, so we can't compile them.
no_compile_image: "characters/frogatto-spritesheet1.png,characters/frogatto-spritesheet3.png,characters/frogatto-spritesheet4.png",
load_variations: "fat",

properties: {
//-------------------------- attack/damage handlers --------------------------
	flinch_threshold: 0,
	attack_knockback: "bool <- if(animation = 'run_attack', 300, 20)",
	damage_cooldown: 10,
	attack_damage: "bool <- animation = 'fall_spin_attack'",
	damage_type: "string|null <- if(animation = 'run_attack','stun')",
	player_specific_damage_response: "def() -> commands execute(me, animation(if(FAT, 'spit','hurt') ))",

	play_hurt_sounds: "def(string|null type) -> commands
		switch(type,
			'bite', sound('hurt-bite'+1d5+'.wav'),
			'stab', sound('hurt-stab'+1d2+'.wav'),
			sound('TakeDamage.wav')
		)",

//-------------------------- general handlers --------------------------
	zombie_object_cleanup: "def() -> commands [remove_object(tmp.tongue_tip), set(tmp.tongue_tip, null), remove_object(tmp.tongue_shaft), set(tmp.tongue_shaft, null)]",

	is_player_body_part: 1,
	
	set_light_size: "def(int lsize) -> commands [set(vars.lightSize, lsize), fire_event(self, 'light_size')]",
	
	bounce_on: "def(object frog, object obj) -> commands [
		set(frog.velocity_y,
			-max(obj.spring_amount,
				((frog.velocity_y*obj.springiness)/100 * (100 - abs(bounce_angle)))/100
			)
		),
		add(frog.velocity_x, 
			((frog.velocity_y*obj.springiness)/100*bounce_angle)/100
		),
		fire_event(obj, 'bounced_on'),
		set(vars.bounced_on_chain, new_bounced_on_chain),
		if(vars.new_bounced_on_chain > 8, achievement('jackalope')),
		] where bounce_angle = (obj.bounce_roundness*(frog.midpoint_x - obj.midpoint_x))/(max(1, obj.w)),
				new_bounced_on_chain = if(obj.team != 'evil', 0, vars.bounced_on_chain + 1)",
	
	register_annoyed_npc: "def(string name) -> commands debug('Recorded ' + name + ' as annoyed.')",
	
	//cheat code:  in the spirit of early cheat codes, this is meant to make testing later levels more balanced against how powerful the player would normally be on such a level; it immediately empowers the player as though the player has purchased a bunch of late game upgrades.  This way we don't fall into making the levels easy enough to pass on a mere 2 hearts.
	//note that the way to enter this code is to type ctrl+d to bring up the debug prompt, type "hax", press return to execute the code, and then press escape to turn off the debug prompt.
	hax: "map(range(ability_list_full.size), schedule(value,fire_event('hax')))",
	hax_: "[
		set(level.player.driver.max_hitpoints, 10), 
		set(level.player.driver.hitpoints, 10),
		set(level.player.driver.tongue_length, 26), 
		set(level.player.mana, 5000), 
		map(ability_list_full, add_ability(value)),
		]",	
	choppa: "set(vars.jump_cheat,1)",
	smite: "map(level.chars, if(value.team = 'evil', set(value.hitpoints, 0)))",
	supes: "[hax,choppa,set(invincible,-1)]",


//-------------------------- attack/ability handlers --------------------------
	ability_list_full: "['firebreath','energyshot','homingshot']",
	add_ability: "def(string name) -> commands
		if((not name in ability_list) asserting name in ability_list_full, 
			set(level.player.ability_list, sort(level.player.ability_list + [name], index(ability_list_full, a) < index(ability_list_full, b))))",

	maintain_locomotion: "def() -> commands [if(ctrl_left, set(accel_x,1600)), if(ctrl_right, set(accel_x,1600))]",

	//NOTE: regarding channelled attacks, especially those which consume a low amount of mana per frame.
	// Problem:  if your only requirement to initiate the attack is the mana/frame cost, then you will "sputter" when your mana is low.  For example, if it takes 20 mana to fire a round, and it takes 10 frames to recharge that much (say, recharging 2 mana/frame), you'll go from firing a constant steam of one projectile/frame, to firing only one projectile every 10 frames 
	// Visually, this actually looks kinda cool on the fire attack, but it's problematic, because the high cooldown means that this sputtering version is as effective as the real thing even if you have no mana!
	// There are a few options to prevent this, we've gone with both 1 and 2 for now:
	// 1] when mana is exhausted, incur a "mana shock" timeout where all mana-based abilities are unuseable for a few moments.
	// 2] keep burning mana at the same rate, regardless of whether the powerup is being used, for the full cooldown duration of the ability.
	// 3] incur a startup cost to initiate the ability at all; if something costs 2 mana/frame, maybe charge 40 mana to start the ability up at all.
	// 4] rather than a startup cost, require the player to have at least > X mana to use the ability.  This differs from 2] in not actually consuming that startup cost, just requiring you to have it.
	attack: "def() -> commands
		if('fat' in variations, tongue(), 
			if(underwater, shoot_bubble(),
				switch(vars.ability_list[vars.current_ability],
					'tongue', tongue(),
					'firebreath', mana_shock_guard(shoot_fire()),
					'energyshot', mana_shock_guard(shoot_energy_shot()),
					'homingshot', mana_shock_guard(shoot_homing_shot())
				)
			) 
		)",
		
	spawn_tongue: "def(decimal angle) -> commands
			[if(animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'run', 'enter_lookup', 'lookup','skid', 'land'], animation('attack')),
			if(animation in ['jump', 'fall'], animation('jump_attack')),
			spawn('frogatto_playable_refactored.tongue_tip', if(facing > 0, x + 30, x), y + 46, facing,set_var('tongue_angle',angle))]",
	
	tongue: "def() -> commands
			if(tmp.ctrl_tongue > 1, null,
				if('fat' in variations,
					if(not (animation in ['interact']), [animation('spit')]),
					[
						if(/*animation in ['run']*/ false, animation('run_attack')),
						if(animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'run', 'enter_lookup', 'lookup','skid', 'land', 'jump', 'fall'],
							if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, spawn_tongue(-45),
								if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, spawn_tongue(45),
									if(ctrl_up, spawn_tongue(-90), if(ctrl_down, spawn_tongue(90), spawn_tongue(0))))))
					]
				)
			)",
			
//-------------------------- sfx for material-interactions --------------------------
	tagged_sfx: "def(string action) -> commands switch(action,
		'slide', [
			{keys: ['wood'],	   sound: sound('slide-wood'+1d13+'.wav')},
			{keys: ['foliage'],	sound: sound('slide-foliage'+1d10+'.wav')},
			{keys: ['dirt'],	   sound: sound('slide-dirt'+1d4+'.wav')},
			{keys: ['stone'],	  sound: sound('slide-stone'+1d10+'.wav')},
			{keys: ['wood_solid'], sound: sound('slide-wood-solid'+1d5+'.wav')},
			{keys: ['metal'],	  sound: sound('slide-metal'+1d9+'.wav')},
			{keys: ['padding'],	sound: sound('footstep-slide-padding'+1d4+'.wav')},
			],
		'jump', [
			{keys: ['wood'],	   sound: [base_sound, sound('jump-wood'+1d10+'.wav',0.7)]},
			{keys: ['foliage'],	sound: [base_sound, sound('jump-foliage'+1d8+'.wav')]},
			{keys: ['padding'],	sound: [base_sound, sound('footstep-jump-padding'+1d7+'.wav')]},
			{keys: ['dirt'],	   sound: [base_sound, sound('jump-dirt'+1d9+'.wav')]},
			{keys: ['stone'],	  sound: [base_sound, sound('footstep-run-stone'+1d8+'.wav')]},
			{keys: ['wood_solid'], sound: [base_sound, sound('jump-wood-solid'+1d3+'.wav',0.6)]},
			{keys: ['metal'],	  sound: [base_sound, sound('footstep-run-metal'+1d5+'.wav',0.6)]},
			{keys: ['default'],	sound: [base_sound, sound('JumpSoft.ogg')]},
			] where base_sound = null /*sound('JumpSoft.ogg')*/,
		'footfall', ([
			{keys: ['wood'],	   sound: [sound('footstep-'+run+'wood'+if(running,1d10,1d7)+'.wav',if(running,0.7,1.0))]},
			{keys: ['foliage'],	sound: [sound('footstep-'+run+'foliage'+if(running,1d9,1d6)+'.wav')]},
			{keys: ['dirt'],	   sound: [sound('footstep-'+run+'dirt'+if(running,1d9,1d10)+'.wav')]},
			{keys: ['stone'],	  sound: [sound('footstep-'+run+'stone'+if(running,1d8,1d10)+'.wav')]},
			{keys: ['padding'],	sound: [sound('footstep-'+run+'padding'+if(running,1d7,1d7)+'.wav')]},
			{keys: ['wood_solid'], sound: [sound('footstep-'+run+'wood-solid'+if(running,1d7,1d8)+'.wav',0.6)]},
			{keys: ['metal'],	  sound: [sound('footstep-'+run+'metal'+if(running,1d5,1d5)+'.wav',0.8)]},
			{keys: ['default'],	sound: [sound('footstep'+1d4+'.wav')]},
			] where run = if(animation in ['run'],'run-',''),
					running = (animation in ['run']) )
		)",
			
//-------------------------- mana --------------------------
	mana_regen_per_frame: "0.5 + if(has_item('lesser_mana_talisman'), 0.3333) + if(has_item('greater_mana_talisman'), 0.6667)",
	
	mana_costs: "{'firebreath' : 35, 'homingshot' : 1000, 'energyshot' : 200}",
	
	//mana_cooldown_time: how long mana keeps burning and the interval between which the ability can't deal damage
	mana_cooldown_time: "{'firebreath' : 10, 'homingshot' : 0, 'energyshot' : 0}", 
	
	//ability_charge_time: how long an ability needs to "charge up" before you can fire it again 
	ability_charge_time: "{'firebreath' : 0, 'homingshot' : 30, 'energyshot' : 5}",
	
	//check all the standard criterion for whether the ability can be used.
	ability_is_charged_up: "def(string ability_name) -> bool 
		(not mana_shock_active)
		and mana >= mana_costs[ability_name]
		and min(
			ability_charge_time[ability_name],
			cycle-tmp.started_using_ability_at_cycle[ability_name]
			) >= ability_charge_time[ability_name]",
	
	//check if we need to burn mana after having just used this ability
	ability_is_cooling_down: "def(string ability_name) -> bool 
		min(
			mana_cooldown_time[ability_name],
			cycle - tmp.started_using_ability_at_cycle[ability_name]
			) < mana_cooldown_time[ability_name]",
	
	//used for regular, active consumption - note that we DON'T subtract mana if we're cooling down, otherwise we'd double-dip
	use_mana_for_ability: "def(string ability_name) -> commands [
		if(not ability_is_cooling_down(ability_name),
			add(mana, -mana_costs[ability_name])),
		set(me.tmp.started_using_ability_at_cycle[ability_name], cycle)
		]",
	
	//used in the process loop to burn cooldown mana for any recently used powers
	use_mana_cooldowns: "def() -> commands map(ability_list_full, if(ability_is_cooling_down(value), add(mana, -mana_costs[value])))",
	
	
//-------------------------- attacks --------------------------
	shoot_bubble: "def()  -> commands
		if(cycle%8=0,	[spawn('frogatto_playable_refactored.bubble_shot',midpoint_x+10*facing,midpoint_y,facing, [set(velocity_x,if((ctrl_up or ctrl_down) and (not(ctrl_left or ctrl_right)),1d100-50,400+1d100)*facing + me.velocity_x),set(velocity_y,1d100-50 + if(ctrl_up,-400-1d100,0) + if(ctrl_down,400+1d100,0) + me.velocity_y)]),sound('bubble-blow'+1d8+'.wav') ])",

	shoot_fire_active: "tmp.ctrl_tongue > 1 and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('firebreath') and (animation in ['firebreath_begin','firebreath_cycle','firebreath_end'])",
	
	shoot_fire: "def() -> commands [if((not (shoot_fire_active)) and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('firebreath'), animation('firebreath_begin')), shoot_fire_internal()]",
	
	shoot_fire_internal: "def() -> commands if( ability_is_charged_up('firebreath') and
		animation in ['firebreath_begin','firebreath_cycle','firebreath_end'], [spawn('frogatto_playable_refactored.fire_shot',midpoint_x+1d10*facing,midpoint_y+4,facing, 
			[set(velocity_x,(1500+1d250)*facing),set(velocity_y,1d900-450)]), use_mana_for_ability('firebreath'), if(cycle >= (tmp.last_played_fire_sfx + 12) or tmp.last_played_fire_sfx = null, [sound('firebreath'+1d5+'.wav'),set(tmp.last_played_fire_sfx,cycle)])]) where mana_cost = mana_costs['firebreath']",
			
	shoot_homing_shot: "def() -> commands
		if(ability_is_charged_up('homingshot') and (not animation in energyshot_anim_list), [schedule(1,animation(energyshot_anim)), homingshot_fire_projectile(energyshot_angle), energyshot_spawn_head(), use_mana_for_ability('homingshot')])",
	
	homingshot_fire_projectile: "def(angle) -> commands spawn('frogatto_playable_refactored.homingshot', midpoint_x + 45*facing*cos(angle), midpoint_y + 40*sin(angle), facing, [set(velocity_x, velocity_x/4 + 2000 * cos(angle) * facing), set(velocity_y, velocity_y/4 + 2000 * sin(angle))])",
	
	shoot_energy_shot: "def() -> commands
		if(ability_is_charged_up('energyshot') and (not animation in energyshot_anim_list), [schedule(1,animation(energyshot_anim)) ,energyshot_fire_projectile(energyshot_angle), energyshot_spawn_head(), use_mana_for_ability('energyshot')])",
	
	energyshot_fire_projectile: "def(angle) -> commands spawn('frogatto_playable_refactored.energyshot', midpoint_x + 45*facing*cos(angle), midpoint_y + 40*sin(angle), facing, [set(velocity_x, velocity_x/4 + 2000 * cos(angle) * facing), set(velocity_y, velocity_y/4 + 2000 * sin(angle))])",
	
	energyshot_angle: "if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, -45,
				if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, 45,
					if(ctrl_up, -90, if(ctrl_down, 90, 0))))",
	
	energyshot_spawn_head: "def() -> commands spawn('frogatto_playable_refactored.frogatto_head_energyshot',midpoint_x,midpoint_y-8,facing, [set_var('angle',energyshot_angle)])",
	
	energyshot_anim: "switch(null,
		me.animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'enter_lookup', 'lookup','skid', 'land'], if(abs(slope_standing_on) < 20, 'energyshot', if(slope_standing_on*facing > 0, 'energyshot_down_slope', 'energyshot_up_slope')),
		me.animation in ['jump', 'fall'], 'energyshot_jump',
		'energyshot')",
	
	energyshot_anim_list: "['energyshot','energyshot_up','energyshot_down','energyshot_jump','energyshot_crouch','energyshot_swim_side','energyshot_swim_down','energyshot_swim_up']",


//-------------------------- item management --------------------------
	has_item: "def(string item_name) -> bool items_carried[item_name] > 0",
	
	number_of_item: "def(string item_name) -> int int(items_carried[item_name])",
	
	add_item: "def(string item_name, int count) -> commands
		set(level.player.vars.items_carried, map_merge(level.player.vars.items_carried, {(item_name) : count}))
		asserting item_name != '' | {message:'Attempting to get an item out of inventory, but the item type given is an empty string.', name:item_name, count:count}",
	
	set_item_amount: "def(string item_name, int count) -> commands
		add(level.player.vars.items_carried, {(item_name) : count}) //This sets the amount, because lists when added to overwrite values if the key already exists.
		asserting item_name != '' | {message:'Attempting to set an item in inventory, but the item type given is an empty string.', name:item_name, count:count}",
	
	
//-------------------------- other functions --------------------------
	spawn_on_ref: "def(string name, decimal x, decimal y, int facing) -> commands [
		set(obj.parent, self.standing_on),
		add_object(obj),
		] where obj = object(name, x, y, facing)",
		
	should_be_standing: "bool <- self.animation in ['stand', 'stand_up_slope', 'stand_down_slope', 'run', 'walk', 'land', 'lookup', 'crouch', 'enter_crouch', 'leave_crouch', 'turn', 'roll','skid']",
	
	set_facing: "def(int direction) -> commands
		if(self.facing != direction and (not (self.animation in ['interact', 'slide'])), [
			facing(direction),
			if(self.is_standing, animation('turn')),
		])",
		
	stand: "def() -> commands
		if(abs(self.velocity_x) > 240 and (not self.animation in ['walk']), animation('skid'),
			if(abs(self.slope_standing_on) < 20, if(not self.animation in ['stand'], animation('stand')),
				if(self.slope_standing_on*self.facing > 0,
					animation('stand_down_slope'),
					animation('stand_up_slope')
				)
			)
		)",
		
	//Make Frogatto walk. anim can be either 'walk' or 'run'. Does checking to make sure Frogatto is in a state where he can walk or run. Will make Frogatto 'glide' if in mid air.
	walk: "def(int dir, string anim) -> commands
		if(self.is_standing and (not self.animation in ['walk', 'run', 'jump', 'fall', 'jump_attack', 'turn', 'crouch', 'enter_crouch', 'run_attack', 'energyshot', 'attack', 'walk_attack', 'up_attack', 'firebreath_begin','firebreath_cycle','firebreath_end','interact', 'spit']), [
			animation(anim), 
			if(anim = 'run', sound('runSoft.wav')),
		],
			//Frogatto is in the air, so make him glide.
			if(not self.is_standing or self.animation in ['slide', 'swim_up', 'swim_down', 'swim_side'],
				add(self.velocity_x, self.vars.jump_glide*dir))
		)",
		
	
	//Function to attempt to make Frogatto crouch; does checking to make
	//sure he's in a state that allows entering a crouch.
	crouch: "def() -> commands
		if((not self.animation in ['crouch', 'enter_crouch', 'interact'] ) and self.is_standing, 
			animation('enter_crouch'))",
	  		
	//Function to enter swimming frames.
	swim: "def(decimal dirx, decimal diry) -> commands
		if(dirx or diry, [
			if(self.animation != anim_wanted, animation(anim_wanted)),
			add(self.velocity_x, (self.swim_accel*dirx)/1000),
			add(self.velocity_y, (self.swim_accel*diry)/1000),
		]) where anim_wanted = if(abs(diry) > 500, if(diry < 0, 'swim_up', 'swim_down'), 'swim_side')",
		
	//function to decide if frogatto can slide down a wall
	can_slide: "bool <- boolean(
		(not FAT)
		and solid(self.level, if(self.facing > 0, self.solid_rect.x2+1, self.solid_rect.x-1), (self.solid_rect.y + self.solid_rect.y2*2)/3)
		and (self.velocity_y < 300 and self.velocity_y > -1000 or self.ctrl_jump and self.tmp.pressed_jump_in_air) )",
},

vars: { //TODO: Move some of these over to properties.
	enemies_tasted: {},
	swim_accel: 140,
	lightSize: 60,
	coins: 0,
	coins_total_obtained: 0,
	items_carried: {},
	jump_power: 1200,
	jump_boost: 90,
	jump_glide: 30,
	walk_accel: 1600,
	run_accel: 2800,
	num_partial_hearts: 0,
	name: "Frogatto",
	current_ability: 0,
	ability_list: ["tongue"],
	swallowed: null,
	achievement_kill_chain: [[null,-1000],[null,-2000],[null,-3000],[null,-4000],[null,-4000],[null,-5000],[null,-6000],[null,-7000],[null,-8000],[null,-9000],[null,-10000],[null,-11000],[null,-12000],[null,-13000],[null,-14000],[null,-15000]],
	tongue_length: 14,
	spit_power: 80,
	posthit_invicibility_period: 100,
	bounced_on_chain: null,
	jump_cheat: null,
	time_last_hit: null,
	last_got_gold: null,
	gold_counter: null,

	runtime_start: null,
},

tmp: {
	start_attack_cycle: 0,
	running: 0,
	last_shield: 0,
	shield: null,
	no_flinch_attack: 0,
	tongue_tip: null,
	tongue_shaft: null,

	//indicates whether the last press of jump was while in the air.
	pressed_jump_in_air: 0,

	started_using_ability_at_cycle: null,
	ctrl_attack: null,
	ctrl_tongue: null,
	last_played_fire_sfx: null,
	interacting_with: null,
	idleness_counter: null,
	idleness_level: null,
	spit_force: null,
	fired_talk: null,
	lookdown_time: null,

	in_solidity_fail: null,
},

consts: {
	JUMP_OUT_OF_WATER_BOOST: 1400,
	JUMP_OUT_OF_WATER_BOOST_HORIZONTAL: 200,
	FAT: 0,
	max_swallow_size: 16,
	powerup_name: "",
	powerup_recharge: 0,
},
	  
	  
on_hax: "hax_",

on_display_gold: "[ if( (cycle - vars.last_got_gold > 20) and (vars.gold_counter > 0), [spawn('text_flash',midpoint_x,midpoint_y-20,1,[set_var('txt','+'+vars.gold_counter)]), set(vars.gold_counter,0)], schedule(10,fire_event('display_gold')))]",

//give frogatto brief invincibility when we load
on_load: "[
	if(not lights, set(lights, circle_light(me, vars.lightSize))),
	set(invincible, 50),
	set(brightness, 255),
	set(tmp.started_using_ability_at_cycle, fold(map(mana_cooldown_time, {(key): -value}), a+b)),
]",

on_create: "[
	set(lights, circle_light(me, vars.lightSize)), 
	animation('stand'),
]",

on_enter_level: "[
	if(not level.id in vars.levels_visited, add(vars.levels_visited, [level.id])),
	animation('stand')
]",

on_load_checkpoint: "[
	if((not lights), set(lights, circle_light(me, vars.lightSize))),
	//TODO: Respawn frogatto with partial health, depending on difficulty level
	//set(hitpoints, (max_hitpoints*3)/4),
	set(hitpoints, max_hitpoints),
	set(level.player.vars.score, (level.player.vars.score*9)/10),

	/*make it so that if we had a swallowed object
	we create a fresh version of the object in our
	stomach.*/
	if(vars.swallowed, [
		set(obj.variations, vars.swallowed.variations),
		set(vars.swallowed, obj),
		set(obj.vars.removed_from_play, 1),
		fire_event(obj, 'swallowed')
		] where obj = object(vars.swallowed.type, midpoint_x, midpoint_y, facing)
	),
	fire_event('lose_powerup'),
	set(tmp.started_using_ability_at_cycle, fold(map(mana_cooldown_time, {(key): -value}), a+b)),

	//remove variations that aren't upgrades
	set(variations, filter(variations, 'v', strstr(v, 'upgrade') or v = 'fat')),
	animation('stand'),
	set(velocity_x, 0),
	set(velocity_y, 0),
	move_to_standing(),
	set(brightness, 255),

	schedule(2, fire_event('check_water'))
]",

on_enter_fall_spin_attack_anim: "[
	add(velocity_y, 500), 
	set(velocity_x, velocity_x/2), 
	set(tmp.no_flinch_attack, 1),
]",

on_enter_jump_anim: "choose_sfx('jump')",

on_enter_slide_anim: "if(IPHONE_SYSTEM, set(underwater_controls, 0))",
	  
on_leave_interact_anim: "fire_event(interacting_with, 'cancel_interaction')",

on_leave_fall_spin_attack_anim: "set(tmp.no_flinch_attack, 0)",

on_leave_jump_attack_anim: "[
	fire_event('leave_attack_anim'),
	set(attached_objects, []),
]",

on_leave_slide_anim: "[
	if(ctrl_left, facing(-1)),
	if(ctrl_right, facing(1)),
]",

on_enter_walk_anim: "[
	set(accel_x, vars.walk_accel),
	set(vars.bounced_on_chain,0),
]",

on_enter_run_anim: "[
	set(accel_x, vars.run_accel), 
	set(vars.bounced_on_chain,0),
]",

on_die: "[
	remove_object(tmp.tongue_tip),
	remove_object(tmp.tongue_shaft),
	spawn('die_cloud', midpoint_x, midpoint_y, facing),
]",

on_ctrl_left: "[
	set_facing(-1),
	if(tmp.left and tmp.left > cycle - 15 or tmp.running = 1, [
		walk(-1, 'run'),
		set(tmp.running, 1),
		]),
	set(tmp.left, cycle),
	set(tmp.right, null),
]",

on_ctrl_right: "[
	set_facing(1),
	if(tmp.right and tmp.right > cycle - 15 or tmp.running = 1, [
		walk(1, 'run'),
		set(tmp.running, 1),
		]),
	set(tmp.right, cycle),
	set(tmp.left, null),
]",

on_ctrl_jump: "[
	proto_event('playable_refactored', 'ctrl_jump'),
	set(tmp.pressed_jump_in_air, (not is_standing)),
	if(animation = 'slide', [
		facing(-facing), 
		animation('jump'), 
		set(velocity_x, -facing*800), 
		set(velocity_y, -1000),
	]),
]",

on_light_size: "set(lights, circle_light(me, vars.lightSize))",

on_ctrl_down: "if(animation = 'slide', animation('fall'))",

on_ctrl_attack: "
	if(not 'fat' in variations, 
		set(vars.current_ability, (vars.current_ability+1) % vars.ability_list.size))",
		
on_end_ctrl_up: "if((animation in ['enter_lookup', 'lookup']), stand())",

timer_frequency: 2,
on_timer: "[ //TODO: Can we put this in the ctrl event code?
	if(ctrl_right - ctrl_left != 0 and ctrl_right - ctrl_left != facing, set_facing(me, -facing)),
	if(ctrl_up and animation in ['stand','stand_up_slope','stand_down_slope'], animation('enter_lookup')),
	proto_event('playable_refactored', 'timer')]",
	   
on_start_level: "[
	zombie_object_cleanup(),
	fire_event('check_water'),
	spawn('shadow_small',mid_x,mid_y,1,set(child.parent, me)),
]",


on_process: "[
	/*[	set(tmp.old_tile_types, tile_types), //This prints the tile code we're standing on.
		if(old_tile_types != tile_types, debug(tile_types)),
	] where tile_types = tags_on(),*/
	
	//If we're standing on a springy object, force a collide_feet
	//event to make us bounce off it.
	if(velocity_y = 0 and standing_on and standing_on.springiness > 0,
			 fire_event('collide_feet', {collide_with: standing_on})),
			 
	if((not is_standing) and should_be_standing,
		animation('fall')),
		
	if((not FAT) and underwater and (not tmp.tongue_tip),
		if(IPHONE_SYSTEM, [
			swim(ctrl_x, ctrl_y),
			if((not ctrl_x) and (not ctrl_y), float()),
			if(ctrl_x < 0 and facing > 0 or ctrl_x > 0 and facing < 0, set(facing, -facing)),
		],[
			swim(
				(ctrl_right - ctrl_left)*if(ctrl_down or ctrl_up, 700, 1000), 
				(ctrl_down - ctrl_up)*if(ctrl_left or ctrl_right, 700, 1000) ),
			if((not (ctrl_left or ctrl_right or ctrl_up or ctrl_down)) and (animation in ['swim_side','swim_up','swim_down']),
			float()),
		])
	),

	if(ctrl_left, if(tmp.running, walk(-1, 'run'), walk(-1, 'walk'))),
	if(ctrl_right, if(tmp.running, walk(1, 'run'), walk( 1, 'walk'))),
	if(ctrl_down and (not (ctrl_left or ctrl_right)), crouch()),
	
	if(ctrl_tongue, add(tmp.ctrl_tongue,1), set(tmp.ctrl_tongue, 0)),
	if(ctrl_attack, add(tmp.ctrl_attack,1), set(tmp.ctrl_attack, 0)),

	if(not mana_shock_active, add(mana, mana_regen_per_frame)),
	use_mana_cooldowns(),
	
	if(ctrl_tongue, attack())
]",
	
	
on_process_fall: "[
	if(IPHONE_SYSTEM,
		if(underwater_controls, [
			add(velocity_x, (jump_glide*ctrl_x)/1000),
			add(velocity_y, (jump_glide*ctrl_y)/1000), 
		])
	),
	proto_event('playable_refactored', 'process_fall')]",

	
on_process_lookup: "[
	add(tmp.lookup_time, 1),
	if(tmp.lookup_time = 50, set(vertical_look, -200)),
]",

on_process_crouch: "[
	add(tmp.lookdown_time, 1), 
	if(tmp.lookdown_time = 50, set(vertical_look, 200)),
]",

on_leave_lookup_anim: "[
	set(tmp.lookup_time, 0), 
	set(vertical_look, 0),
]",

on_leave_crouch_anim: "[
	set(tmp.lookdown_time, 0), 
	set(vertical_look, 0),
]",


on_process_slide: "if(not can_slide, animation('fall'))",

on_check_water: "[
	if(underwater and (not FAT), animation('swim_side')), 
	if(IPHONE_SYSTEM, set(underwater_controls, underwater)),
]",

on_enter_water: "[
	sound('water-enter.ogg'),
	
	if(IPHONE_SYSTEM, set(underwater_controls, 1)),
	if(not FAT or tmp.tongue_tip, [
		float(), 
		set(has_feet, false),
	]),
	
	//splash if we are entering the water with reasonable velocity
	if(velocity_y > 200, [
		spawn('water_splash', midpoint_x, water_bounds[1]+10, if(1d2=2,facing,-facing)),
		spawn('water_particles', midpoint_x, water_bounds[1]+10, facing),
	]),
]",

on_exit_water: "[
	set(has_feet, true),
	animation('fall'),
	sound('water-exit.ogg'),
	schedule(60, fire_event('check_water')),
	
	if(velocity_y < -200, [
		spawn('water_splash', midpoint_x, previous_water_bounds[1]+10, choose([facing,-facing])),
		spawn('water_particles', midpoint_x, previous_water_bounds[1]+10, facing),
	]),
	
	if(velocity_y < 0, add(velocity_y, -JUMP_OUT_OF_WATER_BOOST)),
	set(velocity_x, (velocity_x*JUMP_OUT_OF_WATER_BOOST_HORIZONTAL)/100),
]",

on_end_ctrl_left: "[
	set(tmp.running, 0),
	if((not (ctrl_left or ctrl_right)) and animation in ['walk', 'run'], stand()),
]",

on_end_ctrl_right: "[
	set(tmp.running, 0),
	if((not (ctrl_left or ctrl_right)) and animation in ['walk', 'run'], stand()),
]",


on_collide_feet: "[
	if(IPHONE_SYSTEM and (not underwater), set(underwater_controls, 0)),
	
	if(collide_with and collide_with.springiness > 0, [
		bounce_on(me, collide_with),
	],[	
		set(velocity_x, velocity_x/2),
		if(has_feet and animation != 'spit' and animation != 'jump_attack', 
			if(velocity_y > 1300, [
				animation('land'),
			],[
				stand(), 
				sound(q(bumphead-${if(velocity_y>900,'medium','light')}.wav)),
			]),
		),
	]),
]",

on_collide_head: "[
	if(animation = 'jump', animation('bumphead')), 
	if(velocity_y < 0, set(velocity_y, 0)),
]",

on_collide_side: "[
	set(velocity_x, 0),
	if((animation in ['jump', 'fall']) and can_slide and (abs(velocity_x) > 200
			or ctrl_jump and tmp.pressed_jump_in_air), [
		animation('slide'),
		set(velocity_y, 0),
	]),
]",

//during the fall spin attack we bounce off enemies that we hit.
on_collide_object_attack: "
	if(collide_with_area = 'body' and animation = 'fall_spin_attack' and collide_with.springiness > 0 and velocity_y > 0,
		bounce_on(me, collide_with))",
	   
on_collide_object_body: " //TODO: Remove spin attack and shield from this.
	if(collide_with_area in ['attack','thrown'] and ((not collide_with.spat_out_at)
			or collide_with.spat_out_at < level.cycle - 20) and collide_with.team != team and collide_with.team != 'evil_harmless',
		if(not is_invincible,
			get_hit_by(collide_with),
			if(tmp.shield, fire_event(tmp.shield, 'flash'))),
		//If it wasn't the attack area that hit our body, respond to other areas
		//see if we're colliding with another object's interact area, in which case
		//we set it so we can interact with them.
		if(collide_with_area = 'interact',
			set(can_interact, 2))
	)",

on_grab_object: "if(not vars.swallowed, [ 
	sound('Gulp.wav'),
	remove_object(collide_with),
	if(animation in ['attack', 'jump_attack', 'up_attack'],
		set(attached_objects, [collide_with])),
	set(collide_with.vars.removed_from_play, 1),
	set(vars.swallowed, collide_with),
	fire_event(collide_with, 'swallowed'),
	add(gravity_shift, collide_with.vars.swallow_gravity),
	add(variations, ['fat'])
])",

on_collide_object_grab: "
	if(collide_with_area = 'body' and (not vars.swallowed),
		if(collide_with.tags.swallowable and collide_with.physical_size <= consts.max_swallow_size,
			fire_event('grab_object', {collide_with: collide_with}),
			collide_with.get_hit_by and collide_with.get_hit_by(me) //object is not swallowable, so do damage to it instead
		)
	)",

//if we couldn't return an object to play when spitting it, revert to
//having it inside us.
on_add_object_fail: "if(object and vars.swallowed = null, [
	set(object.vars.removed_from_play, 1),
	set(vars.swallowed, object),
	add(gravity_shift, object.vars.swallow_gravity),
	add(variations, ['fat']),
])",

//If we change our solid dimensions -- i.e. try to come back from being
//hurt, and we can't because we're on top of another solid object, then
//we take more damage.
on_change_solid_dimensions_fail: "[
	proto_event('playable_refactored', 'change_solid_dimensions_fail'),
	if(not is_invincible_posthit, animation(if(FAT, 'spit', 'hurt'))),
]",


on_end_enter_crouch_anim: "animation('crouch')",

on_end_crouch_anim: "if(ctrl_down, animation('crouch'), animation('leave_crouch'))",

on_end_leave_crouch_anim: "stand()",

on_enter_skid_anim: "if(abs(velocity_x) > 300 and (not underwater), [
	spawn_on_ref('dust_cloud_skid', midpoint_x + 36*facing, y2 - 10, facing),
	choose_sfx('slide'),
])",

on_enter_land_anim: "if(not underwater, [
	spawn_on_ref('dust_cloud_skid', midpoint_x + 20*facing, y2 - 8,  facing), 
	spawn_on_ref('dust_cloud_skid', midpoint_x - 20*facing, y2 - 8, -facing),
])",

on_end_roll_anim: "animation('crouch')",
on_leave_roll_anim: "stop_sound('loops/drumroll.ogg')",
on_end_turn_anim: "stand()",
on_end_jump_anim: "if(jump_cheat and ctrl_jump,animation('jump'), animation('fall'))",
on_end_bumphead_anim: "animation('fall')",
on_end_land_anim: "stand()",
on_end_walk_anim: "animation('walk')",

on_end_run_anim: "animation('run')",
on_process_run: "if(abs(velocity_x) > 300 and cycle%5=0 and (not underwater),
	spawn_on_ref('dust_cloud_run', midpoint_x - 30*facing, y2-10, -facing))",

//note:  using level.zoom to detect if in a cutscene or dialogue, in which case we don't do idle anims.
//TODO:  this fails to account for the epilogue.  Figure out some way to do this without setting a special tracker variable, since those are bug-prone.
on_end_stand_anim: "if((not FAT) and tmp.idleness_counter > 8 and level.zoom = 1, 
	[fire_event('idling'), set(tmp.idleness_counter, 0)],
	[animation('stand'), add(tmp.idleness_counter, 1)],
)",
	
on_leave_stand_anim: "[set(tmp.idleness_counter, 0), set(tmp.idleness_level, 0)]",
on_end_skid_anim: "stand()",
on_end_stand_up_slope_anim: "stand()",
on_end_stand_down_slope_anim: "stand()",

on_idling: "if(tmp.idleness_level < 6, [
	switch(1d3,
		1, animation('stand'),
		2, animation('stand'),
		3, animation('stand')
	),
	add(tmp.idleness_level, 1)
],[
	switch(1d3,
		1, animation('idle_eyeball'),
		2, animation('idle_croak'),
		3, animation('idle_croak')
		),
	set(tmp.idleness_level, 0)
])",
					
on_end_idle_eyeball_anim: "stand()",
on_end_idle_croak_anim: "stand()",

on_footfall: "choose_sfx('footfall')",

on_enter_spit_anim: "[set(tmp.spit_force, 0), set(variations, filter(variations, 'v', v != 'fat'))]",
on_process_spit: "[
	if(ctrl_attack or ctrl_tongue, add(tmp.spit_force, 1)),
	maintain_locomotion(),
]",
on_end_spit_anim: "if(underwater, float(), stand())",
on_leave_spit_anim: "if(vars.swallowed, [
	sound('Spit.wav'),
	
	set(green, 255), set(blue, 255),
	add(gravity_shift, -vars.swallowed.vars.swallow_gravity),
	set(vars.swallowed.vars.removed_from_play, 0),
	set(vars.swallowed.velocity_x, velocity_x + facing*(200 + tmp.spit_force*if(ctrl_up, vars.spit_power/2, vars.spit_power*2))),
	set(vars.swallowed.velocity_y, velocity_y - (600 + if(ctrl_up, 200 + tmp.spit_force*vars.spit_power))),

	//set the object's timestamp for when it was spat out, so we
	//can make ourselves invincible to it for a little while
	set(vars.swallowed.time_spat, level.cycle),
	set(vars.swallowed, null),

	//set the enemy to be dimensionless, meaning it will only collide
	//with the level. If it collides with another object we expect
	//it to die.
	set(vars.swallowed.solid_dimensions_in, ['thrown']),
	if(vars.swallowed.thrown_type, set(vars.swallowed.type, vars.swallowed.thrown_type)),
	set(vars.swallowed.animation, 'thrown'),

	set(vars.swallowed.midpoint_x, midpoint_x),
	set(vars.swallowed.y, y),
	resolve_solid(vars.swallowed, facing, 0, 50),
	resolve_solid(vars.swallowed, -facing, 0, 50),

	add_object(vars.swallowed),
	fire_event(vars.swallowed, 'spat'),
	if(underwater, set(has_feet, false)),
])",


on_child_spawned: "if(child.type = 'frogatto_playable_refactored.tongue_tip', [
	set(tmp.tongue_tip, child), 
	set(child.tmp.frog, me),
])",
					  

on_process_attack: "if((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left), [set(animation, 'walk_attack'), set(time_in_animation, time_in_animation),set(accel_x, vars.walk_accel)])",
on_process_walk_attack: "if((facing = 1 and (not (ctrl_right))) or (facing = -1 and (not (ctrl_left))), [set(animation, 'attack'), set(time_in_animation, time_in_animation)])",
on_end_walk_attack_anim: "animation('walk')",

on_end_energyshot_anim:			"stand()",
on_end_energyshot_jump_anim:	   "stand()",
on_end_energyshot_up_slope_anim:   "stand()",
on_end_energyshot_down_slope_anim: "stand()",

on_end_attack_anim: "[
	if(('fat' in variations), animation('swallow')),
	stand(),
]",
on_leave_attack_anim: "[if(tmp.tongue_tip, fire_event('remove_tongue')), set(attached_objects, [])]",

on_leave_up_attack_anim: "set(attached_objects, [])",
on_end_swallow_anim: "stand()",
on_end_enter_lookup_anim: "animation('lookup')",
on_end_lookup_anim: "animation('lookup')",
on_end_run_attack_anim: "[animation('skid'), set(tmp.running, 0)]",
on_end_up_attack_anim: "stand()",
on_end_jump_attack_anim: "animation('fall')",
on_end_fall_spin_attack_anim: "animation('fall')",
on_end_firebreath_begin_anim: "animation('firebreath_cycle')",
on_end_firebreath_cycle_anim: "if(shoot_fire_active,animation('firebreath_cycle'), animation('firebreath_end'))",
on_end_firebreath_end_anim: "stand()",
on_end_swim_side_idle_anim: "float()",
on_end_swim_side_anim: "if(underwater, animation('swim_side'), stand())",
on_end_swim_up_anim:   "if(underwater, animation('swim_up'),   stand())",
on_end_swim_down_anim: "if(underwater, animation('swim_down'), stand())",
on_end_item_get_begin_anim: "animation('item_get_hold')",
on_end_item_get_hold_anim: "animation('item_get_hold')",
on_end_item_get_end_anim: "animation('stand')",
on_end_hurt_anim: "animation(if((not FAT) and underwater, 'swim_side_idle', 'stand'))",

on_end_emote_geez_anim: "animation('stand')",
on_end_emote_oh_anim: "animation('stand')",
on_end_emote_impatient_anim: "animation('stand')",
on_end_emote_raisedfinger_anim: "animation('stand')",
on_end_emote_confused_anim: "animation('stand')",
on_end_emote_talk_anim: "animation('stand')",
on_end_emote_nod_anim: "animation('stand')",
on_end_emote_angry_anim: "animation('stand')",

animation: [
	{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "stand",
		duplicates: 6,
		rect: [2,2,33,34],
		frames: 3,
		duration: 6,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "freeze",
		duplicates: 6,
		rect: [2,2,33,34],
		frames: 3,
		duration: 100000000,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "stand",

		//blink variant
		rect: [107,2,138,34],
		frames: 3,
		duration: 6,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "stand_up_slope",
		x: 212,
		y: 2,
		w: 32,
		h: 35,
		solid_area: [9,9,23,31],
		frames: 3,
		duration: 6,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "stand_down_slope",
		x: 317,
		y: 2,
		w: 32,
		h: 35,
		solid_area: [9,9,23,31],
		frames: 3,
		duration: 6,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "lookup",
		rect: [37,233,68,265],
		frames: 1,
		duration: 3,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "enter_lookup",
		rect: [2,233,33,265],
		frames: 1,
		duration: 3,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "crouch",
		solid_area: [9,17,23,30],
		rect: [107,197,138,229],
		frames: 1,
		duration: 1,
		rotate_on_slope: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "enter_crouch",
		solid_area: [9,17,23,30],
		rect: [2,197,33,229],
		frames: 3,
		duration: 3,
		rotate_on_slope: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "leave_crouch",
		rect: [2,197,33,229],
		frames: 3,
		duration: 3,
		play_backwards: true,
		rotate_on_slope: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "walk",
		solid_area: [17,18,31,40],
		rect: [2,110,49,157],
		frames: 8,
		duration: 5,
		events: "10:30:footfall",
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "run",
		solid_area: [17,18,31,40],
		x: 410,
		y: 95,
		w: 48,
		h: 48,
		frames: 4,
		frames_per_row: 2,
		duration: 5,
		events: "0:10:footfall",
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "skid",
		solid_area: [17,18,31,40],
		x: 461,
		y: 40,
		w: 48,
		h: 48,
		frames: 1,
		duration: 10,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "turn",
		x: 387,
		y: 40,
		w: 32,
		h: 33,
		frames: 1,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "jump",
		solid_area: [9,13,23,35],
		x: 2,
		y: 38,
		w: 32,
		h: 48,
		frames: 2,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "bumphead",
		sound: "bumphead.wav",
		solid_area: [9,12,23,34],
		rect: [422,2,453,36],
		duration: 5,
		frames: 1,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "fall",
		solid_area: [9,13,23,35],
		x: 72,
		y: 38,
		w: 32,
		h: 48,
		duration: 12,
		frames: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "land",
		sound: "bumphead.wav",
		solid_area: [9,17,23,39],
		x: 142,
		y: 38,
		w: 32,
		h: 48,
		duration: 4,
		frames: 2,
	},{
		image: "characters/fat-frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swallow",
		x: 2,
		y: 269,
		w: 49,
		h: 38,
		duration: 6,
		frames: 6,
		solid_area: [6,13,20,35],
	},{
		image: "characters/fat-frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "spit",
		x: 314,
		y: 269,
		w: 34,
		h: 35,
		duration: 3,
		frames: 3,
		solid_area: [6,8,20,30],
	},{
		image: "characters/frogatto-spritesheet5.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		feet_width: 5,
		id: "attack",
		sound: "tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav",
		rect: [2,151,33,188],
		solid_area: [9,12,23,34],
		body_area: [16,11,30,36],
		frames: 8,
		duration: 2,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet5.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		feet_width: 5,
		id: "walk_attack",
		rect: [2,233,33,270],
		solid_area: [9,12,23,34],
		body_area: [16,11,30,36],
		frames: 4,
		duration: 4,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 3200,
		accel_y: 80,
		pad: 3,
		feet_width: 5,
		id: "run_attack",
		events: "6:7:8:9:10:11:run_attack_contact",
		sound: "slash.ogg",
		solid_area: [18,6,32,28],
		x: 2,
		y: 403,
		w: 68,
		h: 30,
		attack_area: [20,14,70,40],
		body_area: [0,0,30,40],
		frames: 5,
		duration: 3,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet5.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		feet_width: 5,
		id: "jump_attack",
		sound: "tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav",
		rect: [2,192,50,229],
		body_area: [6,11,24,36],
		solid_area: [16,10,30,32],
		frames: 8,
		duration: 2,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "firebreath_begin",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "firebreath_cycle",
		rect: [360,476,393,510],
		frames: 2,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "firebreath_end",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "hurt",
		rect: [271,351,303,383],
		frames: 1,
		duration: 18,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "interact",
		collide_x: 10,
		collide_y: 6,
		collide_w: 15,
		collide_h: 16,
		feet_x: 16,
		feet_y: 32,
		x: 72,
		y: 161,
		w: 32,
		h: 33,
		frames: 4,
		duration: 4,
		scale: 2,
		reverse: true,
		events: "15:interacting",
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 10,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "slide",
		x: 352,
		y: 40,
		w: 32,
		h: 34,
		duration: 30,
		frames: 1,
		solid_area: [14,8,28,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_side_idle",
		x: 3,
		y: 85,
		w: 39,
		h: 36,
		frames: 6,
		frames_per_row: 3,
		duration: 6,
		reverse: true,
		//(lost comment, location guessed) solid area not set as it would cause collision problems with the level
		//solid_area: [8,13,30,27]
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_down_idle",
		x: 129,
		y: 85,
		w: 39,
		h: 36,
		frames: 6,
		frames_per_row: 3,
		duration: 6,
		reverse: true,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_up_idle",
		x: 255,
		y: 85,
		w: 39,
		h: 36,
		frames: 6,
		frames_per_row: 3,
		duration: 6,
		reverse: true,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_side",
		sound: "Paddle1.ogg,Paddle2.ogg,Paddle3.ogg,Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg",
		x: 3,
		y: 163,
		w: 39,
		h: 36,
		frames: 3,
		duration: 10,
		//(lost comment, location guessed) solid area not set as it would cause collision problems with the level
		//solid_area: [8,13,30,27]
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_down",
		sound: "Paddle1.ogg,Paddle2.ogg,Paddle3.ogg,Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg",
		x: 129,
		y: 163,
		w: 39,
		h: 36,
		frames: 3,
		duration: 10,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_up",
		sound: "Paddle1.ogg,Paddle2.ogg,Paddle3.ogg,Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg",
		x: 255,
		y: 163,
		w: 39,
		h: 36,
		frames: 3,
		duration: 10,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "energyshot_jump",
		rect: [1,415,41,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [12,14,26,36],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "energyshot_down_slope",
		rect: [45,415,85,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,15,28,37],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "energyshot_up_slope",
		rect: [89,415,129,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,15,28,37],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "energyshot",
		rect: [133,415,173,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,14,28,36],
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_begin",
		rect: [1,335,32,367],
		frames: 4,
		duration: 10,
	},
	{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_hold",
		rect: [106,335,137,367],
		frames: 1,
		duration: 30,
	},
	{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_end",
		rect: [1,335,32,367],
		frames: 4,
		duration: 10,
		play_backwards: "yes",
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_begin",
		rect: [1,335,32,367],
		frames: 4,
		duration: 10,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_geez",
		rect: [1,1,36,38],
		solid_area: [11,13,25,35],
		frames: 8,
		reverse: true,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet4.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_oh",
		rect: [1,1,36,38],
		solid_area: [11,13,25,35],
		frames: 15,
		frames_per_row: 5,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_confused",
		rect: [1,52,36,89],
		solid_area: [11,13,25,35],
		frames: 14,
		frames_per_row: 7,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_impatient",
		rect: [323,1,358,38],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 4,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_raisedfinger",
		rect: [1,144,36,181],
		solid_area: [11,13,25,35],
		frames: 14,
		frames_per_row: 7,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_talk",
		rect: [1,236,36,273],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 8,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_nod",
		rect: [323,175,358,212],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 4,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet4.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_angry",
		rect: [1,127,36,164],
		solid_area: [11,13,25,35],
		frames: 20,
		frames_per_row: 5,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet-idle.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "idle_eyeball",
		rect: [1,1,32,33],
		frames: 43,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet-idle.png",
		accel_x: 0,
		accel_y: 0,
		pad: 7,
		body_area: "all",
		feet_width: 5,
		id: "idle_croak",
		rect: [3,37,34,69],
		frames: 25,
		duration: 6,
	},
],



particle_system: {
	id: "invincible_particles",
	type: "simple",
	min_y: 0,
	max_y: 50,
	min_x: 0,
	max_x: 40,
	spawn_rate: 500,
	time_to_live: 20,
	animation: [{
			id: "sparkle",
			image: "props/items.png",
			rect: [139,74,149,84],
			frames: 4,
			pad: 3,
			duration: 6,
		},{

			//
			//same thing, but skip the first frame
			id: "sparkle",
			image: "props/items.png",
			rect: [153,74,163,84],
			frames: 3,
			pad: 3,
			duration: 4,
		},{

			//
			//same thing, but skip the first 2 frames
			id: "sparkle",
			image: "props/items.png",
			rect: [167,74,177,84],
			frames: 2,
			pad: 3,
			duration: 6,
		},{

			//
			//same thing, but skip the first 3 frames
			id: "sparkle",
			image: "props/items.png",
			rect: [181,74,191,84],
			frames: 1,
			pad: 3,
			duration: 6,
		},
	],
},


variations: {
	fat: "[
		map(filter(doc.animation, value.image in images_to_convert), 'anim',
		set(anim.image, regex_replace(anim.image, 'frogatto', 'fat-frogatto'))) where
		images_to_convert = ['characters/frogatto-spritesheet1.png',
							 'characters/frogatto-spritesheet3.png',
							 'characters/frogatto-spritesheet4.png'],
		set(doc.consts, 'FAT', 1), set(doc.consts.jump_power, 1200),
		set(doc.consts.jump_boost, 80), set(doc.consts.jump_glide, 20),
		map(filter(doc.animation, value.id = 'walk'), 'anim', set(doc.anim.accel_x, 1300)),
		map(filter(doc.animation, value.id = 'run'), 'anim', set(doc.anim.accel_x, 1900)),
	]",
},


object_variation: [
	{
		id: "fat",
		set_str: [
			{
				_target: "filter(elements.animation, image = 'characters/frogatto-spritesheet1.png')",
				image: "characters/fat-frogatto-spritesheet1.png",
			},{
				_target: "filter(elements.animation, image = 'characters/frogatto-spritesheet3.png')",
				image: "characters/fat-frogatto-spritesheet3.png",
			},{
				_target: "filter(elements.animation, image = 'characters/frogatto-spritesheet4.png')",
				image: "characters/fat-frogatto-spritesheet4.png",
			},{
				_target: "elements.consts",
				FAT: 1,
				jump_power: 1200,
				jump_boost: 80,
				jump_glide: 20,
			},{
				_target: "filter(elements.animation, id = 'walk')",
				accel_x: 1300,
			},{
				_target: "filter(elements.animation, id = 'run')",
				accel_x: 1900,
			},{
				_target: "self",
			},
		],
	},
],

object_type: [
	//------------------------- TONGUE/HEAD -------------------------
	
	{
		id: "tongue_shaft",
		always_active: true,
		serializable: false,
		zsub_order: 5,
		solid_dimensions: [],
		
		properties: {
			is_player_body_part: 1,
			myLength: "def(x,y,z,a) sqrt(ly^2 + lx^2) where lx = abs(x-z) where ly = abs(y-a)",
			length: "myLength(x_1,y_1,x_2,y_2)",
			set_ends: "def(new_x1,new_y1,new_x2,new_y2) [set(vars.x_1,new_x1),set(vars.y_1,new_y1),set(vars.x_2,new_x2),set(vars.y_2,new_y2),fire_event(me,'create'),]",
		},
		
		on_create: "[
				set(midpoint_x, (x_2+x_1)/2),
				set(y, (y_2+y_1)/2 - (length/2)),
				set(draw_area, [0, 0, img_w/2, length/2]),
				set(activation_area, [min(x_1,x_2) -200, min(y_1,y_2) -200, abs(x_1-x_2) +200, abs(y_1-y_2) +200]),  //xywh
				set(rotate,(angle(x_1,y_1,x_2,y_2)-90) )
			]",
			
		animation: {
			id: "default",
			image: "characters/frogatto-tongueB.png",
			rect: [0,0,7,7],
			frames: 1,
			no_remove_alpha_borders: true,
		},
	},
	
	
	{
		id: "frogatto_head",
		serializable: false,
		
		properties: {
			is_player_body_part: 1,
		},
		
		on_spawned: "switch(vars.angle, -90, animation('up'), -45, animation('updiag'), 0, animation('side'), 45, animation('downdiag'), 90, animation('down'))",
		
		animation: [
			{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "up",
				rect: [2,1,35,26],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "updiag",
				rect: [2,30,35,55],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "side",
				rect: [2,59,35,84],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "downdiag",
				rect: [2,88,35,113],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "down",
				rect: [2,117,35,142],
			},
		],
	},
	
	
	{
		id: "tongue_tip",
		always_active: true,
		serializable: false,
		zsub_order: 6,
		solid_dimensions: ["player","common","boss","thrown"],
		
		properties: {
			is_player_body_part: 1,
			attack_damage: 0,
			team: "'player'",
			yhead_offset: 12,
			ybase_offset: 8,
			x_offset: "0*facing",
			tongue_duration: 16,

			//
			//possible TODO: query this from tmp.frog
			length_per_time: "def(time) tmp.frog.tongue_length*(tongue_duration/2 - abs(tongue_duration/2 - time))",
			set_shaft: "def(time,angle) [	tmp.shaft.set_ends(	tmp.froghead.midpoint_x + x_offset,
																tmp.froghead.midpoint_y + ybase_offset,
																tmp.froghead.midpoint_x + (length_per_time(time)*cos(angle)) * facing + x_offset,
																tmp.froghead.midpoint_y + ybase_offset + (length_per_time(time)*sin(angle))  )]",
			adjust_position: "def(time,angle)	[set(midpoint_x, tmp.froghead.midpoint_x + (length_per_time(time)*cos(angle)) * facing  + x_offset + if(facing = 1, 2,0)), 
												set(midpoint_y, tmp.froghead.midpoint_y + ybase_offset + (length_per_time(time)*sin(angle)) + if(facing = -1 and angle = 0, -1, 0) ),
												set(rotate, angle * facing)]",
			process_tongue: "def() [set_shaft(vars.timer, tongue_angle),adjust_position(vars.timer,tongue_angle),if(vars.timer >= tongue_duration,die()),fire_event('drag_victim'),if(vars.timer = tongue_duration/2, animation('flash')),add(vars.timer,1)]",
		},
		
		vars: {
			timer: 1,
			tongue_angle: 0,
			swallowed: null,
		},
		
		tmp: {
			frog: null,
			froghead: null,
			shaft: null,
		},
		
		consts: {
			damage_cooldown: 10,
			max_swallow_size: 16,
		},
		
		on_spawned: "[	spawn('frogatto_playable_refactored.tongue_shaft',x,y,1,set(tmp.shaft, child)),
						spawn('frogatto_playable_refactored.frogatto_head', tmp.frog.midpoint_x,tmp.frog.midpoint_y-yhead_offset, facing, [set_var('angle',tongue_angle), set(parent,tmp.frog),set(tmp.froghead, child)]),
						]",
		
		on_process: "process_tongue()",
		
		on_die: "[
			if(vars.swallowed, [
				set(tmp.frog.vars.swallowed, vars.swallowed),
				add(tmp.frog.variations, ['fat']),
				fire_event(tmp.frog,'end_attack_anim'),
			]),
			set(tmp.shaft.hitpoints, 0), 
			set(tmp.shaft, null),
			set(tmp.froghead.hitpoints, 0), 
			set(tmp.froghead, null), 
			set(tmp.frog.tmp.tongue_tip, null), 
			if((not vars.swallowed) and tmp.frog.underwater, set(tmp.frog.has_feet, false)),
		]",

		// If we snag something early, fast-forward us to where the tongue is at the same position, but retracting.
		on_stopearly: "[
			set(vars.timer, newtime), 
			set(tmp.frog.time_in_animation,newtime),
		] where newtime = vars.timer + 2*abs(max((tongue_duration/2 - vars.timer), 0))",
		
		on_drag_victim: "[
			if(vars.swallowed and (level.cycle - vars.cycle_grabbed > 1), [
				set(vars.swallowed.midpoint_x, last_x),
				set(vars.swallowed.midpoint_y, last_y),
			]),
			set(last_x, midpoint_x), set(last_y, midpoint_y),
		]",
						
		on_grab_objects: "if((not vars.swallowed) and collide_with.hitpoints, [
			fire_event(collide_with, 'been_grabbed'),
			remove_object(collide_with),
			set(attached_objects, [collide_with]), set(vars.cycle_grabbed, level.cycle),
			set(collide_with.vars.removed_from_play, 1),
			sound('Gulp.wav'),
			set(vars.swallowed, collide_with), fire_event(collide_with, 'swallowed'),
			add(level.player.gravity_shift, collide_with.vars.swallow_gravity),
		])",
		
		on_collide_object_grab: "
			if((collide_with_area = 'body' or collide_with_area = 'thrown') and (not vars.swallowed) and collide_with != level.player, [
				fire_event('stopearly'),
				animation('flashsnag'),
				if(tag_ and (not tag_ in keys(level.player.enemies_tasted)), [
					add(level.player.enemies_tasted, {(tag_): true}),
					//adding 1 since the list won't have been updated yet, plus adding to casual the count of enemies exclusive to the 'challenging' difficulty level, which is only the wartfly, right now.
					if(size(level.player.enemies_tasted) + if(level.player.difficulty >= level.player.difficulty_challenging, 1, 2) >= 37, achievement('frogourmet'))
				]) where tag_ = collide_with.frogourmet_tag,
				if(is_swallowable,
					fire_event('grab_objects', {collide_with: collide_with}), //fire an event to grab the object. We do it in a separate event in case we try to swallow multiple objects at once.
					if(collide_with.get_hit_by, collide_with.get_hit_by(me)) //object is not swallowable, so do damage to it instead
				),
			]) where is_swallowable = collide_with.tags.swallowable and collide_with.physical_size <= consts.max_swallow_size",
		
		on_create: "animation('initial')",
		on_end_initial_anim: "animation('normal')",
		on_end_flash_anim: "animation('normal')",
		on_end_clung_anim: "animation('clung')",
		on_end_flashsnag_anim: "animation('clung')",
		
		animation: [
			{
				id: "initial",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 4,
				rect: [307,351,339,383],

				//grab_area=solid:all
				grab_area: [8,8,25,20,"solid"],
			},{
				id: "normal",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 100,
				rect: [379,351,411,383],

				//grab_area=solid:all
				grab_area: [8,8,25,20,"solid"],
			},{
				id: "flashsnag",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 2,
				rect: [415,351,447,383],
			},{
				id: "flash",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 2,
				rect: [343,351,375,383],
			},{
				id: "clung",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 100,
				rect: [451,351,483,383],
			},
		],
	},


	//------------------------- HEAD FOR ENERGYSHOT -------------------------
	//
	{
		id: "frogatto_head_energyshot",
		serializable: false,
		zsub_order: 12,
		
		properties: {
			is_player_body_part: 1,
		},
		
		on_spawned: "[
			set(parent, spawner), 
			schedule(9,die()),
			switch(vars.angle, 
				-90, animation('up'), 
				-45, animation('updiag'), 
				  0, animation('side'), 
				 45, animation('downdiag'), 
				 90, animation('down')
			),
		]",
		
		animation: [
			{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "up",
				rect: [178,415,218,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "updiag",
				rect: [222,415,262,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "side",
				rect: [266,415,306,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "downdiag",
				rect: [310,415,350,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "down",
				rect: [354,415,394,458],
			},
		],
	},
	
	
	//------------------------- SHOTS -------------------------
	{
		id: "bubble_shot",
		prototype: ["shot"],
		
		properties: {
			team: "'player'",
			dies_when_hit: 0,
			attack_damage: 20,
			damage_cooldown: 10,
		},
		
		vars: {
			team: "player",
		},
		
		on_spawned: "set(vars.parent_obj, spawner)",
		on_end_normal_anim: "animation('pop')",
		on_end_pop_anim: "die()",
		
		on_enter_pop_anim: "[
			set(velocity_x,0),
			set(velocity_y,0),
			sound('bubble-pop'+1d5+'.wav'),
		]",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 3,
				duration: 8,
				rect: [62,2,71,11],
				attack_area: "all",
			},{
				image: "effects/particles2.png",
				pad: 3,
				id: "pop",
				frames: 2,
				duration: 4,
				rect: [101,2,110,11],
			},
		],
	},

	
	{
		id: "fire_shot",
		prototype: ["shot"],
		zorder: "@include data/zorders.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_when_hit: 0,
			attack_damage: 50,
			damage_cooldown: 10,
			damage_type: "'fire'",
		},
		
		on_spawned: "[
			set(vars.parent_obj, spawner),
			set(lights, circle_light(me, 150)),
			schedule(6,animation('pop')),
		]",
		
		on_end_normal_anim: "animation('normal')",
		on_end_pop_anim: "die()",
		
		on_enter_pop_anim: "[
			set(velocity_x,0),
			set(velocity_y,-200-1d100),
			facing(if(1d2=2,1,-1)),
			set(zsub_order,-10),
		]",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 4,
				duration: 2,

				//rect=3,2,12,11
				rect: [2,113,15,130],
				attack_area: "all",
			},{
				image: "effects/particles2.png",
				pad: 3,
				id: "pop",
				frames: 3,
				duration: 2,

				//rect=6,30,12,36
				rect: [2,134,15,151],
			},
		],
	},

	
	{
		id: "energyshot",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorders.cfg:near_player_foreground_effects",
		
		properties: {
			attack_damage: 20,
			team: "'player'",
			damage_type: "'fire'",
		},
		
		vars: {
			exploded: 0,
		},
		
		on_create: "[
			set(time_in_animation, 1d6),
			sound('energyshot.ogg'),
			schedule(50,die()),
			spawn('frogatto_playable_refactored.energyshot_bloom',midpoint_x,midpoint_y,0),
			add_particles('particles'),
		]",
	
		on_process: "[
			set(velocity_x,velocity_x*0.97),
			set(velocity_y,velocity_y*0.97),
			set(lights, circle_light(me, wave(cycle*100+1d20)/100)),
		]",

		// When we die we want to keep the particles coming. So, we turn into a particle_system_holder object and set our hitpoints to the number of cycles we want to keep the particles running for. We schedule turning into the particle system holder next frame, because we want to remain as we are this frame so any remaining collisions can be properly resolved.
		on_die: "[
			set(hitpoints, 30),
			if((not vars.exploded), [
				set(vars.exploded, 1), 
				spawn('frogatto_playable_refactored.energyshot_bloom',midpoint_x,midpoint_y,0),
				sound('energyshot-impact'+1d5+'.wav'), 
				set(hitpoints, 30), set(particles.spawn_rate, 0), 
				schedule(0, [
					set(type, 'particle_system_holder'), 
					fire_event('create'),
				])
			])
		]",
		
		on_end_anim: "animation('normal')",
		
		animation: {
			body_area: "all",
			attack_area: [0,0,10,10],
			id: "normal",
			image: "effects/particles2.png",
			x: 3,
			y: 15,
			w: 10,
			h: 10,
			pad: 3,
			frames: 4,
			duration: 2,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 3,
			max_y: 5,
			spawn_rate: 1000,
			time_to_live: 20,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 84,
				y: 19,
				w: 7,
				h: 7,
				pad: 3,
				frames: 4,
				scale: 2,
				duration: 5,
			},
		},
	},
	
	
	{
		id: "energyshot_bloom",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorders.cfg:near_player_foreground_effects",
		zsub_order: -10,

		//When our animation ends we want to disappear and transfer to being a particle_system_holder which will keep the particle system going.
		on_end_anim: "[
			set(hitpoints, 30), 
			set(type, 'particle_system_holder'), 
			fire_event('create'),
		]",

		//we want to spawn a bunch of particles at the start, and then stop, so
		//we schedule an event to stop spawning immediately after we are created.
		on_create: "[
			add_particles('particles'), 
			schedule(1, fire_event('stop_spawning_particles')),
		]",
		
		on_stop_spawning_particles: "set(particles.spawn_rate, 0)",
		
		animation: {
			id: "sparkle",
			image: "effects/powerup-fx.png",
			x: 122,
			y: 2,
			w: 21,
			h: 23,
			pad: 3,
			frames: 8,
			frames_per_row: 4,
			duration: 2,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			spawn_rate: 10000,
			time_to_live: 20,
			min_x: 10,
			max_x: 20,
			min_y: 10,
			max_y: 20,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 1000,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 84,
				y: 19,
				w: 7,
				h: 7,
				pad: 3,
				frames: 4,
				scale: 2,
				duration: 5,
			},
		},
	},
	
	
	{
		id: "homingshot_bloom",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorders.cfg:near_player_foreground_effects",
		zsub_order: -10,
		
		on_end_anim: "die()",

		animation: {
			id: "sparkle",
			image: "effects/homing-shot-init.png",
			rect: [1,1,31,31],
			frames:9,
			frames_per_row:3,
			duration: 2,
			pad: 3,
		},
	},


	{
		id: "homingshot_impact",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorders.cfg:near_player_foreground_effects",
		zsub_order: -10,

		//when our animation ends we want to disappear and transfer to being
		//a particle_system_holder which will keep the particle system going.
		on_end_anim: "[
			set(hitpoints, 30), 
			set(type, 'particle_system_holder'), 
			fire_event('create'),
		]",

		//we want to spawn a bunch of particles at the start, and then stop, so
		//we schedule an event to stop spawning immediately after we are created.
		on_create: "[
			add_particles('particles'), 
			schedule(1, fire_event('stop_spawning_particles')),
		]",
		
		on_stop_spawning_particles: "set(particles.spawn_rate, 0)",
		
		animation: {
			id: "sparkle",
			image: "effects/homing-shot-impact.png",
			rect: [1,1,31,41],
			frames:11,
			duration: 3,
			pad: 3,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 9,
			max_y: 13,
			spawn_rate: 1000,
			time_to_live: 24,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 1,
				y: 227,
				w: 7,
				h: 7,
				pad: 3,
				frames: 8,
				frames_per_row:4,
				scale: 2,
				duration: 3,
			},
		},
	},
	
	
	{
		id: "homingshot",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorders.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			attack_damage: 50,
			damage_type: "'fire'",
			team: "'player'",
			speed: 700,
			accel_speed: 0.2,
			decay: 0.99,
			multiplier_x: "cos(angle_to(me,vars.target_lock))",
			multiplier_y: "sin(angle_to(me,vars.target_lock))",
			my_angle: "angle_to(me,vars.target_lock)",
			nearest_enemy: "choose(filter(level.active_chars, value.team = 'evil'), -distance(value, self)) or level.player",
		},
		
		vars: {
			exploded: 0,
			target_lock: null,
		},
		
		on_create: "[
			set(time_in_animation, 1d6),
			sound('homing.wav'),
			schedule(150,die()),
			set(target_lock, nearest_enemy),
			spawn('frogatto_playable_refactored.homingshot_bloom',midpoint_x,midpoint_y,0), 
			add_particles('particles'),
		]",
		
		on_process: "[
			if(target_lock, [
				set(velocity_x, median(-speed, velocity_x*decay + multiplier_x*speed*accel_speed, speed)),
				set(velocity_y,median(-speed,velocity_y*decay+multiplier_y*speed*accel_speed,speed)),
			],[
				set(velocity_x, 600*sign(velocity_x)),
				set(velocity_y, 600*sign(velocity_y)),
				set(target_lock, nearest_enemy),
			]),
			set(lights, circle_light(me, wave(cycle*100+1d20)/100)),
		]",

		// When we die we want to keep the particles coming. So, we turn into a particle_system_holder object and set our hitpoints to the number of cycles we want to keep the particles running for. We schedule turning into the particle system holder next frame, because we want to remain as we are this frame so any remaining collisions can be properly resolved.
		on_die: "[
			set(hitpoints, 30), 
			if(not vars.exploded, [
				set(vars.exploded, 1), 
				spawn('frogatto_playable_refactored.homingshot_impact', midpoint_x, midpoint_y, 0, set(child.rotate,my_angle)),
				sound('homingimpact.wav'), 
				set(hitpoints, 30), 
				set(particles.spawn_rate, 0), 
				schedule(0, [
					set(type, 'particle_system_holder'), 
					fire_event('create'),
				])
			])
		]",
					
		timer_frequency: 21,
		on_timer: "if((not target_lock in level.active_chars) or target_lock = level.player, set(target_lock, nearest_enemy))",
		
		on_end_anim: "[animation('normal')]",
		
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x: 1,
			y: 208,
			w: 15,
			h: 15,
			pad: 3,
			frames: 4,
			duration: 1,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 9,
			max_y: 13,
			spawn_rate: 1000,
			time_to_live: 24,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 1,
				y: 227,
				w: 7,
				h: 7,
				pad: 3,
				frames: 8,
				frames_per_row:4,
				scale: 2,
				duration: 3,
			},
		},
	},

],

}
