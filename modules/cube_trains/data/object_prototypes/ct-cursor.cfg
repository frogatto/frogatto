{
id: "ct-cursor",
prototype: ["player_input","ct-block"],
reverse_global_vertical_zordering: true,
zsub_order: 9,
timer_frequency: 50,

properties: {
	_findStringIndex: "def(index, target) if(pieces[index] = target, index, _findStringIndex(index+1, target))",
	
	select_piece: "def(delta) [
		if(is_int(delta), [
			set(self.vars.piece_selected, newIndex), 
			preview.safeAnimation(pieces[newIndex].type),
			fire_event(self, 'render_depth'),
			fire_event(self, 'selected_new_piece', {piece: pieces[newIndex]}), //Script trigger.
		]	where newIndex = if(rangefive < 0, size(pieces)-1, rangefive) 
			where rangefive = (piece_selected+delta)%size(pieces),
		[	set(self.vars.piece_selected, newIndex),
			preview.safeAnimation(pieces[newIndex].type),
			fire_event(self, 'render_depth'),
			fire_event(self, 'selected_new_piece', {piece: pieces[newIndex]}), //Script trigger.
		]	where newIndex = _findStringIndex(0, delta) ),
		sound('tiny-clatter-1.wav', 0.8),
		]",

	rotate_view: "def(delta) if(self.vars.limits and map_unlocked, [
		#Crd gets rotated by 90 degrees cw or ccw. Delta is ±1.#
		add_snapsnapshot_undo,
		//clearUndo(),
		map(filter(level.chars, 'lc', lc.location), 'obj', 
			obj.applyRotate(delta)),
		fire_event(self, 'render_depth'),
		set(self.vars.limits, {	#rotate the limits of the level, to match up with the new level data#
			'max' -> best_between(rotmax, rotmin, def(a,b) a>b),
			'min' -> best_between(rotmin, rotmax, def(a,b) a<b)
			}
			where rotmin = self.getRotateZ(self.vars.limits.min, delta)
			where rotmax = self.getRotateZ(self.vars.limits.max, delta)),
		set(vars.groupMap, {
			'offset': gmOffset,
			'size': list_add(realMaxs, gmOffset),
		})
		where gmOffset = list_subtract([0,0,0],realMins)
		where realMaxs = best_between(rotMaxs, rotMins, def(a,b) a>b)
		where realMins = best_between(rotMaxs, rotMins, def(a,b) a<b)
		where rotMaxs = self.getRotateZ(list_subtract(vars.groupMap.size, vars.groupMap.offset), delta)
		where rotMins = self.getRotateZ(list_subtract([0,0,0], vars.groupMap.offset), delta),
		fire_event('rebuild_all_pathing_nodes'),
		map_lock(3),
		])",
	
	render_depth: "def(new_loc_, steps)
		map(range(steps+1), 'step', schedule(step, 
			map(play_objs, 'pob', [ /*We'll apply alpha above and darken below for sense of depth.*/
				pob.set_depth_effect(new_loc[2] - pob.vars.location[2], is_volumetric_piece(pob) and is_volumetric_piece(pieces[piece_selected])),
		])) where new_loc = [new_loc_[0], new_loc_[1], ((new_loc_[2] * 1.0) * (step)  + (vars.location[2] * 1.0) * (steps - step))/steps]
		) where play_objs = filter(level.chars, 'ch', ch.vars.location and not ch in [context.self, context.self.vars.preview])",
	
	applyRotate: "def(delta) [
		setToGrid(dest), 
		schedule(0, fire_event('snap_cursor')),
		set(self.vars.entrances, []),
		set(tmp.camOffset, [level.camera_position[0]-self.x, level.camera_position[1]-self.y])
		] where dest = self.getRotateZ(self.vars.location, delta)",
			
	is_volumetric_piece: "def(piece) piece.type in [
	'ct-block-5', 'ct-bridge-tiny-19', 'ct-bridge-tiny-37', 'ct-legs-5', 'ct-tunnel-1', 'ct-tunnel-3', 'ct-tunnel-7', 'ct-tunnel-9', 'ct-windows-large-5', 'ct-edge-hedge-1', 'ct-edge-hedge-3', 'ct-edge-hedge-7', 'ct-edge-hedge-9', 
	'ct-raise-1', 'ct-raise-3', 'ct-raise-7', 'ct-raise-9', 
	'ct-ground-raise-1', 'ct-ground-raise-3', 'ct-ground-raise-7', 'ct-ground-raise-9', 
	'ct-metaraise-1', 'ct-metaraise-3', 'ct-metaraise-7', 'ct-metaraise-9', 
	]",
	
	block_value: "def(objs, value) 0",
	
	move: "def(delta) move_to(list_add(vars.location, delta))",
			
	move_to: "def(loc) if(can_move_to(loc),[
			setToGrid(loc),
			if(loc[2] != vars.location[2], render_depth(loc, 10))
			])",
			
	can_move_to: "def(loc) is_in_limits(loc) or is_in_limits(list_subtract(loc, [0,0,1]))",
	
	additionalPlacementRequirementsMet: "def(obj, at_pos) debug_fn('${self.type}`s additionalPlacementRequirementsMet blindly OKd a {obj.type} at {at_pos}. This function should be overridden to surpress this message.', 1)",
	
	level_coordinate_from_position: "def(pos) if(level.player.width, [ #Return the 3D point that the mouse is pointing to. Derived from setToGrid(), defined in ct-block.cfg.#
		pos[0]/level.player.width-(pos[1]/level.player.height+self.vars.location[2]+pos[0]/level.player.width)/2,
		(pos[1]/level.player.height+self.vars.location[2]+pos[0]/level.player.width)/2,
		self.vars.location[2]], [0,0,0])",

	get_placement_delta: "def(toAdd, toRemove=[], _previous=[], add_first=0) #things to add[, things to remove[, the results of a previous call to this function[, add_first = 0(false) or 1(true)]]]#
		if(not size(toAdd),
			if(not size(toRemove), {},
				if(objToRemove,
					map_merge({'remove' -> [objToRemove]}, get_placement_delta(toAdd, toRemove[1:size(toRemove)]+next_remove_call, map_merge(previous, {'remove' -> [objToRemove]})))
					where next_remove_call = map(neighbours_to_remove, 'nf', {'pos' -> nf.vars.location, 'group' -> nf.vars.group[0]})
					where neighbours_to_remove = filter(
						flatten(transform([[0,0,0], [1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]],
							potentially_at_coord(list_add(toRemove[0].pos, v), newChars)
						)),
						'potential_failure',
						(not potential_failure.placementRequirementsMet(newChars).ok)),
					get_placement_delta(toAdd, toRemove[1:size(toRemove)], previous)
					) where newChars = potential_chars([{'remove' -> [objToRemove]}, previous])
					where objToRemove = find(potentially_at_coord(toRemove[0].pos, potential_chars([previous])), 'obj', toRemove[0].group in obj.vars.group and (obj.vars.editable or context.vars.edit_all))
				),
			if(can_add_current_object.ok,
				list_reduce([{'add' -> [current_object]}, childrens_results, peers_results, clear_results], def(u,v) map_merge(u,v)),
				map_merge({'error' -> [can_add_current_object.error]}, peers_results)
				) where can_add_current_object = current_object.placementRequirementsMet(
					potential_chars([childrens_results, peers_results, previous, clear_results]))
				where childrens_results = get_placement_delta( #We'll only return these results if we can place the current piece. That way, we can place an object and have it fail without placing all it's scenery too. (Build, _then_ wallpaper.)#
					transform(
						current_object.additionalBlocks(level.chars), 
						{'id' -> v['id'], 'pos' -> list_add(toAdd[0]['pos'], v['pos'])}),
					[],
					list_reduce([{'add' -> [current_object]}, peers_results, previous, clear_results], def(u,v) map_merge(u,v)))
				where clear_results = get_placement_delta([],transform(current_object.incompatible_ghost_groups, {'group' -> v, 'pos' -> toAdd[0]['pos']}), peers_results #Change peers_results to [] if things start acting up along the lines of 'why won't this object place'.#)
				where peers_results = get_placement_delta(toAdd[1:size(toAdd)], toRemove, previous) #These will be returned as they can probably be placed independantly of the current piece.#
				where current_object = object(toAdd[0]['id'], x,y,1,{'location' -> toAdd[0]['pos']})
			)
		where previous = if(_previous, _previous, {})",

	potential_chars: "def(_delta)
		if(not delta['remove'], 
			level.chars + delta['add'], 
			filter(level.chars + delta['add'], 'newCharacter', not newCharacter in delta['remove'])
			)
		where delta = list_reduce(_delta, def(u,v) map_merge(u,v))",

/*
Does not work:
set(setfoo, def(bar) set(foo, def() debug(bar)) )
setfoo(5)
foo()

Works:
set(setfoo, def(bar) set(foo, def() debug(bar)) where bar=bar ) 
setfoo(4)
foo()
*/

	apply_placement_delta: "def(delta, zoom_pos, do_zoom=false) [
		map(filter(delta['add'], 'da', not da in delta['remove'] or da.consts.meta), 'toAdd', [
			add_object(toAdd),
			toAdd.setToGrid(toAdd.location),
			toAdd.set_branch(vars.target_value),
			add(score, toAdd.vars.cost),
			]),
		map(filter(deltaRemove, 'dr', dr in level.chars and (not dr.consts.meta)), 'toRemove', [
			fire_event(remove, 'remove'),
			remove_object(remove),
			add(score, -remove.vars.cost),
			set(completed_level, 0), self.vars.buttons.return.set_skin(),
			] where remove = find(level.chars, 'lc', lc = toRemove)),
		if(delta['add'] or delta['remove'], 
			addUndo({	'redo' -> def() apply_placement_delta(tmpDelta, zoom_pos, true),
						'undo' -> def() apply_placement_delta({'add' -> deltaRemove, 'remove' -> tmpAdd}, zoom_pos, true), 
						}) ) where zoom_pos=zoom_pos,
		//if(delta.error, 0),
		if(do_zoom, move_to(zoom_pos)), //This makes it so that we can zoom to where we are working, when we undo/redo.
		fire_event('update_score'),
		] where deltaRemove = unique(delta['remove'])
		where tmpAdd = delta['add'] // This must be where-defined, because it doesn't work here. ^----^. :(
		where tmpDelta = delta",
		
	place_piece: "def(position_in) if(((not pieces[piece_selected] in 
									meta_placers(
										map(at_coord(position), value.type)))
									or edit_all) and map_unlocked, [
		if(size(filter(pd['add'], 'pds', not pds.consts.meta)) > 0, [
			clearRedo(),
			apply_placement_delta(pd, position_in),
			vars.preview.do_place_effect,
			sound('laying-track-b-2.wav', 1.0),
			],[
			vars.message.add_text(head(pd.error)), //Although we may have more than one error message, we'll take take one at a time for simplicity's sake. To display all the error messages, just remove the head function.. In addition, we only display the error messages when we couldn't place a piece. This way, we'll not get pointless errors.
			]),
		schedule(10, fire_event('render_depth')),
		fire_event(self, 'placed_piece'), //Script trigger.
		] where pd = get_placement_delta(pdArg)
		where pdArg = [{'id' -> pieces[piece_selected], 'pos' -> position}],
		vars.preview.do_place_effect)
		where position = list_add(position_in, block_offset(pieces[piece_selected]))",

	remove_piece: "def(position) if(map_unlocked, [
		clearRedo(),
		if(pd.remove, sound('laying-track-b-1.wav', 0.5)),
		apply_placement_delta(pd, position),
		] where pd = get_placement_delta([], pdArg)
		where pdArg = transform(object(pieces[piece_selected]).incompatible_ghost_groups, {'group' -> v, 'pos' -> list_add(position, block_offset(pieces[piece_selected]))}))",

	block_offset: "def(position)
		switch(position,
			'ct-block-5',			[0,0,-1],
			'ct-windows-large-5',	[0,0,-1],
			'ct-water-5',			[0,0,-1],
			'ct-legs-5',			[0,0,-1],
			'ct-ground-support-5',	[0,0,-1],
			'ct-bridge-tiny-19',	[0,0,-1],
			'ct-bridge-tiny-37',	[0,0,-1],
			[0,0,0])",
				
	meta_placers: "def(list_of_types)
		map(list_of_types, switch(
			value,
			'ct-glr-13', 'ct-metatrack-13',
			'ct-glr-17', 'ct-metatrack-17',
			'ct-glr-39', 'ct-metatrack-39',
			'ct-glr-79', 'ct-metatrack-79',
			'ct-glr-19', 'ct-metatrack-19',
			'ct-glr-37', 'ct-metatrack-37',
			'ct-track-13', 'ct-metatrack-13',
			'ct-track-17', 'ct-metatrack-17',
			'ct-track-39', 'ct-metatrack-39',
			'ct-track-79', 'ct-metatrack-79',
			'ct-track-19', 'ct-metatrack-19',
			'ct-track-37', 'ct-metatrack-37',
			value,
			))",

	//How to use Undo: In the function that's actually *doing* the action, add the call to addUndo. If the function should invalidate the redo stack, then call clearRedo BEFORE the function where you call addUndo. We don't want to clear the redo stack when we're undoing the function.
	#action: {'unfn' -> function[, 'undat' -> unfn arg 'refn' -> function, 'redat' -> refn arg]} - Here, we execute 'undo' to undo the original action, and 'redo' to undo the undo.
	addUndo: "def(action) if(action.undo, 
		[add(self.vars.undo, [action]), set(self.vars.undoButton.animation, 'active')])",
	_addRedo: "def(action) if(action.redo, 
		[add(self.vars.redo, [action]), set(self.vars.redoButton.animation, 'active')], 
		[set(self.vars.redo, []), set(self.vars.redoButton.animation, 'disabled')])",
	clearUndo: "def() [
		set(self.vars.redo, []),
		set(self.vars.undo, []),
		set(self.vars.undoButton.animation, 'disabled'),
		set(self.vars.redoButton.animation, 'disabled')]",
	clearRedo: "def() [
		set(self.vars.redo, []),
		set(self.vars.redoButton.animation, 'disabled')]",
	
	undo: "if(size(self.vars.undo) and map_unlocked, [
		schedule(1, if(size(self.vars.undo) = 1, set(self.vars.undoButton.animation, 'disabled'))),
		action.undo(),
		set(self.vars.undo, self.vars.undo[0:size(self.vars.undo)-1]),
		_addRedo(action),
		map_lock(5),
		] where action = self.vars.undo[size(self.vars.undo)-1])",

	redo: "if(size(self.vars.redo) and map_unlocked, [
		if(size(self.vars.redo) = 1, set(self.vars.redoButton.animation, 'disabled')),
		action.redo(),
		set(self.vars.redo, self.vars.redo[0:size(self.vars.redo)-1]),
		#Don't add to undo here because when we called the redo function it already added an undo.#
		map_lock(5),
		] where action = self.vars.redo[size(self.vars.redo)-1])",
		
	add_snapsnapshot_undo: "[
		addUndo({	'undo': def() [	set(self.vars.toLoad, sl + {map:[]}),	//Save ATTRIBUTES, but not blocks. We'll need the blocks in their unserialized form.
								fire_event(self, 'quick_load'),
								schedule(2, [ //We have to wait for quick load to do it's thing. It's possible we should just transport the minimal functionality we need back to here instead of using the event.
									map(oldBlocks, [add_object(value)]),
									schedule(2, [
										fire_event('reset_pathing_node_paramaters'),
										fire_event('rebuild_all_pathing_nodes'),
										fire_event('refresh_entrances_cache'),
										]),
									]),
								],
					'hack': [sl, oldBlocks],	//This isn't used by addUndo, but is needed to force the sl where to be evaluated instead of inlined. If it's inlined, it'll calculate it's data when the undo is run -- not particularly useful.
					'redo': def() [message.add_text('An error occured in the redo function. Sorry.'), /*TODO report bug here*/]} + {hack:null}) //The idea with this line is to introduce a placeholder redo function which we'll replace in two frames. This is kind of hacky, but we can't know what objects the function will produce before we... uh, actually run it. Stupid casuality. This preserves deletes in the redo stack, which are keyed to object.
				where sl = serialized_level
				where oldBlocks = blocks_in_play,
		schedule(3, fire_event(self, 'replace_redo_with_current_snapshot')), //Note: The above logic is mostly duplicated in this event.
		]",
	
	reset_pathing_node_paramaters: "[
		set(vars.groupMap, {
			'offset': gmOffset,
			'size': maxs,
			'objs': generate_clear_groups_cache(maxs)})
		where maxs = list_add(
			best_of(transform(blocks_in_play, v.location) + [toLoad['limits']['max']], def(a,b) a>b), #We find the maximum value we have a block at, or the maximum value we could place a block at via limits.#
			gmOffset) #This offsets the smallest block so it's at origin, since we can't have negative list indexes.#
		where gmOffset = list_subtract([0,0,0],mins)
		where mins = best_of(transform(blocks_in_play, v.location) + [toLoad['limits']['min']], def(a,b) a<b), #Minimum value. See above comment.#
		]",
	
	toggle_erase_mode: "set_erase_mode(not self.vars.erase_button.pressed)",
	
	set_erase_mode: "def(target) [
		self.vars.erase_button.set_to(target),
		self.vars.preview.erase_colour(target),
		]",
	
	generate_clear_groups_cache: "def(maxs) transform(range(maxs[0]+1), transform(range(maxs[1]+1), transform(range(maxs[2]+1), [])))",
	
	serialized_level: "serialized_level_",
	serialized_level_: "
		{	'id': 'custom',	//We start with a basic, empty template. Then, we overwrite what data we have in it with the data in toLoad. This means that we can have level-specific data which won't be hosed when we save/load. If toLoad is empty, this means that we'll now have to fill it in manually -- but the template will help us with that. Next, we overwrite all data so far with the current savable state of the level. This updates our save data with our new blocks. We'll print the data to console and queue it to save to a global variable, so that we can load it later. The new data is also -- somewhere, somehow -- getting set to toLoad.#
			'limits': {'max': [1,1,1],'min': [-1,-1,-1]}, 
			'name': 'Custom Level', 
			'map': [],
		}
		+ toLoad 			//Then we apply what we loaded to it. This makes saving is non-destructive to custom events.
		+ {	'map' -> map(	//Next, we save the new map. (This is most likely to have been modified.)
				filter(level.chars, 'ch', 
					(not ch.consts.nosave) and size(ch.vars.group)), 
				'saves', 
				[saves.type, saves.location, saves.vars.save_val, saves.branch])}
		+ if(not vars.edit_all, {	//If we're not editing, save score and completion status. Otherwise, we are editing, and we will assume we should generate a 'fresh' level for someone to solve.
			'score' -> vars.score,
			'complete' -> vars.completed_level
			},{
			'score' -> 0,
			'complete' -> 0,
			})",
			
	blocks_in_play: "filter(level.chars, 'lc', lc.vars.location and lc!=self and not lc.type in ['ct-preview', 'ct-preview.underlay', 'ct-preview.grid-5'])",
	real_max_limit: "best_of(transform(blocks_in_play, v.vars.location) + [[ 1, 1, 1]], def(a,b) a>b)",
	real_min_limit: "best_of(transform(blocks_in_play, v.vars.location) + [[-1,-1,-1]], def(a,b) a<b)",
		
	selectedGrid: "def(mpos)
		level_coordinate_from_position(list_subtract(hitpoint, [128,191]))					//This formula takes the x/y of a tile, not the midpoint x/y.
		where hitpoint = choose(hitpoints, -distance(	list_multiply(mpos,  [1,1.75]),		//1 and 1.75 scale the values to compensate for the tilted perspective of the cameras. Here, it means that we'll favour horizontal distances over vertical ones.
														list_multiply(value, [1,1.75])))
		where hitpoints = map(hitBoxOffsets, 'hitBoxOffset',
			list_subtract(mpos, 
				[mod(mpos[0]-nudge[0]+hitBoxOffset[0],rwidth)-width, 
				 mod(mpos[1]-nudge[1]+hitBoxOffset[1],rheight)-height]))
		where hitBoxOffsets = [	[0,if(location[2]%2, -height, 0)], 
								[width, if(location[2]%2, 0, height)]]		//Since the game is on a diagonal grid, and we can check for only straight grids, we'll just have two 'closest matches' from two straight grids. If we offset one of them, then we'll get the diamond-shaped pattern we need.
		where rwidth = width*2 where rheight = height*2						//Real height and width. This compensates for the zoomed 2px coordinate system of Frogatto or something.
		where nudge = [20,5] 												//Does the fine-grain alignment to bring the hitboxes into true with the graphics. It compensates for the margin in each graphic.
		",
	
	abs_mouse_xy: "def(index) ctrl_mice[index][:2]",

	if_shift: "def(a,b=null) if(303 in key_input or 304 in key_input, a, b)",
	if_ctrl:  "def(a,b=null) if(305 in key_input or 306 in key_input, a, b)",
	if_alt:   "def(a,b=null) if(307 in key_input or 308 in key_input, a, b)",
	
	map_lock: "def(frames) [fire_event(self, 'add_map_lock'), schedule(frames, fire_event(self, 'remove_map_lock'))]",
	map_unlocked: "tmp.map_lock = 0",
},

vars: {
	toLoad: {},
	keymode: "dvorak",
	keymap: {
		"dvorak": { "block alt": "e", "block value down": "a", "block value up": "o", "debug2": 283, "help": 282, "high": "z", "load": 285, "low": 305, "next branch": "b",   "place": 304,   "print": 284, "redo": "r", "rotate ccw": "-", "rotate cw": "\\", "select left": "<",  "select right": ";", "trains": " ", "undo": "u", "unplace": "q", "copy": "c", "paste": "v", "hotblock 1": "1", "hotblock 2": "2", "hotblock 3": "3", "hotblock 4": "4", "hotblock 5": "5", "hotblock 6": "6", "hotblock 7": "7", "hotblock 8": "8", "hotblock 9": "9", "hotblock 0": "0", },
		"qwerty": {																					 "help": 282, "high": "/", "load": 285, "low": 305, "next branch": "b",   "place": 304,   "print": 284, "redo": "r", "rotate ccw": "'", "rotate cw": ";",  "select left": "\\", "select right": "z", "trains": " ", "undo": "u", "unplace": "x", "copy": "c", "paste": "v", "hotblock 1": "1", "hotblock 2": "2", "hotblock 3": "3", "hotblock 4": "4", "hotblock 5": "5", "hotblock 6": "6", "hotblock 7": "7", "hotblock 8": "8", "hotblock 9": "9", "hotblock 0": "0", },
		"azerty": { "block alt": "d", "block value down": "q", "block value up": "s", "debug2": 283, "help": 282, "high": ":", "load": 285, "low": 305, "next branch": "b", /*"place": 304,*/ "print": 284, "redo": "r", "rotate ccw": "=", "rotate cw": ")",  "select left": "<",  "select right": "w", "trains": " ", "undo": "u", "unplace": "x", "copy": "c", "paste": "v", "hotblock 1": "1", "hotblock 2": "2", "hotblock 3": "3", "hotblock 4": "4", "hotblock 5": "5", "hotblock 6": "6", "hotblock 7": "7", "hotblock 8": "8", "hotblock 9": "9", "hotblock 0": "0", },
		},
	pieces: ["ct-block-5"],
	piece_selected: 5,
	groups: ["ground","support","track"],

	target_value: "normal",
	mutually_exclusive_groups: [ #MEGs are groups can't be in the same tile. IIRC, each element of a list is exclusive of all other elements, regardless of order. This is so that you don't get bugs where you can build a track and then a bush on the same tile, but not a bush and then a track.
		[ "track", "ground", "water" ], 
		[ "center", "ground", "support", "water"], #Factor out 'center' here to make trees placable inside supports. This will need the graphics rejiggered.
		[ "center", "ground", "track" ], 
		[ "edge 1", "ground" ], [ "edge 3", "ground" ], [ "edge 7", "ground" ], [ "edge 9", "ground" ], 
		[ "edge 2", "awning 5" ], [ "edge 4", "awning 5" ], [ "edge 6", "awning 5" ], [ "edge 8", "awning 5" ], 
		[ "edge 2", "ground", "support" ], [ "edge 4", "ground", "support" ], [ "edge 6", "ground", "support" ], [ "edge 8", "ground", "support" ], 
		[ "awning 1", "support" ], [ "awning 2", "support" ], [ "awning 3", "support" ], [ "awning 4", "support" ], [ "awning 5", "support" ], [ "awning 6", "support" ], [ "awning 7", "support" ], [ "awning 8", "support" ], [ "awning 9", "support" ], 
		[ "awning 1", "ground" ], [ "awning 2", "ground" ], [ "awning 3", "ground" ], [ "awning 4", "ground" ], [ "awning 5", "ground" ], [ "awning 6", "ground" ], [ "awning 7", "ground" ], [ "awning 8", "ground" ], [ "awning 9", "ground" ],
		[ "water", "water surface"],
	],
	limits: {
		"max": [ 1, 1, 1],
		"min": [-1,-1,-1],
	},
	name: "level name here",
	group: ["player"],
	entrances: [],	#entrances for us to spawn trains from
	ped_utils: [],	#objects the pedestrians can use
},
consts: {
	nosave: 1,
},

//on_debug2: "[debug_fn(get_clipboard_text(), get_clipboard_text())]",
//on_debug2: "debug(if(size(at_position) > 0, 'Here: ', 'Nothing here.') + list_cat(map(at_position, 'ap', ap.type + ' (z${str(ap.zorder)}/${str(ap.zoffset)}) ')) )",
on_debug2: "fire_event('map_to_clipboard')",

on_create: "[
	proto_event('player_input', 'create'),
	proto_event('ct-block', 'create'),
	screen_flash([0,0,0,255], screen_fade_in_delta(), screen_fade_steps()),
	]",
	
on_first_cycle: "[//debug('HI THERE'), //By Gregory Clark. Good book. Do recommend.
	proto_event('player_input', 'first_cycle'), #Don't proto ct-block, it'll expect the stuff we're setting up here and crash.#
	#set(fragment_shaders, ['fragment.gl']), set(vertex_shaders, ['vertex.gl']), set(shader.dst_factor, 500),#
	setToGrid(location),
	fire_event('quick_load'),
	[	set(text_ctrl.vars.txt, '[]'),
		set(text_ctrl.vars.size, 1),
		set(text_ctrl.z, 99999),
		add_object(text_ctrl),
		set(vars.text_ctrl, text_ctrl),
		set(level.focus, [text_ctrl]),
	]	where text_ctrl = object('text_controller', x, y, 0, {'centered'->0}),
	[	set(vars.preview, pre),
		add_object(pre),
		set(pre.animation, pieces[piece_selected].type)
	]	where pre = object('ct-preview'),
	fire_event('render_depth'),
	fire_event('setup_buttons'),
	]",
		
on_setup_buttons: "[
	spawn('ct-ui-back-1', 0,0,1, [
		set(child.vars.reference_anchor, child.getCameraAnchor(1)),
		]),
	spawn('ct-ui-back-2', 0,0,1, [
		set(child.vars.reference_anchor, child.getCameraAnchor(2)),
		]),
	spawn('ct-ui-back-3', 0,0,1, [
		set(child.vars.reference_anchor, child.getCameraAnchor(3)),
		]),
	spawn('ct-ui-back-7', 0,0,1, [
		if(self.vars.displayCopyButtons, 
			set(child.vars.reference_anchor, child.getCameraAnchor(7)),
			set(child.vars.reference_anchor, list_subtract(child.getCameraAnchor(7), [110,0]))),
		]),
	
	set(vars.buttons, button),
	add_object(button.nav1),
		set(button.nav1.vars.reference_anchor, button.nav3.getCameraAnchor(3)), 
		set(button.nav1.vars.offset, [margin*2-button.nav3.img_w, margin]),
		//set(button.nav1.parent, button.nav3),
		set(button.nav1.vars.action, fire_event(self, 'button_down')),
	add_object(button.nav3),
		set(button.nav3.vars.reference_anchor, button.nav3.getCameraAnchor(3)), 
		set(button.nav3.vars.offset, margin),
		set(button.nav3.vars.action, fire_event(self, 'button_right')),
	add_object(button.nav7),
		set(button.nav7.vars.reference_anchor, button.nav3.getCameraAnchor(3)), 
		set(button.nav7.vars.offset, [margin*2-button.nav3.img_w, margin*2-button.nav3.img_h]),
		set(button.nav7.parent, button.nav3),
		set(button.nav7.vars.action, fire_event(self, 'button_left')),
	add_object(button.nav9),
		set(button.nav9.vars.reference_anchor, button.nav3.getCameraAnchor(3)), 
		set(button.nav9.vars.offset, [margin, margin*2-button.nav3.img_h]),
		set(button.nav9.parent, button.nav3),
		set(button.nav9.vars.action, fire_event(self, 'button_up')),
	add_object(button.navl5),
		set(button.navl5.vars.reference_anchor, button.nav3.getCameraAnchor(3)), 
		set(button.navl5.vars.offset, [margin*3-button.nav3.img_w*2, margin]),
		set(button.navl5.parent, button.nav3),
		set(button.navl5.vars.action, fire_event(self, 'ctrl_low')),
	add_object(button.navg5),
		set(button.navg5.vars.reference_anchor, button.nav3.getCameraAnchor(3)), 
		set(button.navg5.vars.offset, [margin*3-button.nav3.img_w*2, margin*2-button.nav3.img_h]),
		set(button.navg5.parent, button.nav3),
		set(button.navg5.vars.action, fire_event(self, 'ctrl_high')),
	add_object(button.navccw),
		set(button.navccw.vars.reference_anchor, button.nav3.getCameraAnchor(3)), 
		set(button.navccw.vars.offset, [margin, margin*3-button.nav3.img_h*2]),
		set(button.navccw.parent, button.nav3),
		set(button.navccw.vars.action, [fire_event(self, 'srv1'), fire_event(self, 'clearRedo')]),
	add_object(button.navcw),
		set(button.navcw.vars.reference_anchor, button.nav3.getCameraAnchor(3)), 
		set(button.navcw.vars.offset, [margin*2-button.nav3.img_w, margin*3-button.nav3.img_h*2]),
		set(button.navcw.parent, button.nav3),
		set(button.navcw.vars.action, [fire_event(self, 'srvl1'), fire_event(self, 'clearRedo')]),
		
	add_object(button.trains),
		set(button.trains.vars.reference_anchor, button.trains.getCameraAnchor(2)), 
		set(button.trains.vars.offset, [0, margin+2]),
		set(button.trains.vars.action, fire_event(self, 'trains')),
	
	#toolbox buttons, 1st corner.#
	add_object(button.toolbox),
		set(button.toolbox.vars.reference_anchor, button.toolbox.getCameraAnchor(1)), 
		set(button.toolbox.vars.offset, [-margin+1, margin+1]),
		set(button.toolbox.vars.targets, tools.toolbox),
	add_object(button.toolccw),
		set(button.toolccw.vars.reference_anchor, button.nav3.getCameraAnchor(1)), 
		set(button.toolccw.vars.offset, [64 - margin*2 + button.toolccw.img_w, margin]),
		set(button.toolccw.parent, button.toolbox),
		set(button.toolccw.vars.action, [fire_event(self, 'rotate_piece_ccw'), ]),
	add_object(button.toolcw),
		set(button.toolcw.vars.reference_anchor, button.nav3.getCameraAnchor(1)), 
		set(button.toolcw.vars.offset, [64 - margin, margin]),
		set(button.toolcw.parent, button.toolbox),
		set(button.toolcw.vars.action, [fire_event(self, 'rotate_piece_cw'), ]),
	add_object(button.erase),
		set(button.erase.vars.reference_anchor, button.nav3.getCameraAnchor(1)), 
		set(button.erase.vars.offset, [64 - margin, margin - button.erase.img_h + margin]),
		set(button.erase.parent, button.toolbox),
		set(self.vars.erase_button, button.erase),
		
	add_object(button.score),
		set(button.score.vars.reference_anchor, button.score.getCameraAnchor(9)), 
		set(button.score.vars.offset, [-55, 14]),
		schedule(2, fire_event('update_score')),
		set(self.vars.scoredisp, button.score),
	add_object(button.msgr),
		set(button.msgr.vars.reference_anchor, button.score.getCameraAnchor(9)), 
		set(button.msgr.vars.offset, [-55, 14 + 20]),
		set(button.msgr.z, 1000000),
		set(self.vars.message, button.msgr),
		
	add_object(button.return),
		set(button.return.vars.action, fire_event(self, 'exit_level')),
		set(button.return.vars.offset, -margin),
	add_object(button.reset),
		set(button.reset.vars.action, [fire_event(self, 'reset'), fire_event(self, 'clearRedo')]),
		set(button.reset.vars.reference_anchor, button.return.getAnchor(4, list_add(button.return.getCameraAnchor(7), [button.return.img_w - margin, 0]))),
		set(button.reset.vars.offset, -margin),
	add_object(button.undo),
		set(button.undo.vars.action, fire_event(self, 'undo')),
		set(button.undo.vars.reference_anchor, button.return.getAnchor(4, list_add(button.return.getCameraAnchor(7), [button.return.img_w - margin*2 + button.undo.img_w, 0]))),
		set(button.undo.vars.offset, -margin),
		set(self.vars.undoButton, button.undo),
	add_object(button.redo),
		set(button.redo.vars.action, fire_event(self, 'redo')),
		set(button.redo.vars.reference_anchor, button.return.getAnchor(4, list_add(button.return.getCameraAnchor(7), [button.return.img_w + button.undo.img_w + button.redo.img_w - margin*3, 0]))),
		set(button.redo.vars.offset, -margin),
		set(self.vars.redoButton, button.redo),
	if(self.vars.displayCopyButtons, [
		add_object(button.copy),
			set(button.copy.vars.action, fire_event(self, 'map_to_clipboard')),
			set(button.copy.vars.reference_anchor, button.return.getAnchor(4, list_add(button.return.getCameraAnchor(7), [button.return.img_w + button.undo.img_w + button.redo.img_w + button.copy.img_w - margin*4, 0]))),
			set(button.copy.vars.offset, -margin),
		add_object(button.paste),
			set(button.paste.vars.action, fire_event(self, 'map_from_clipboard')),
			set(button.paste.vars.reference_anchor, button.return.getAnchor(4, list_add(button.return.getCameraAnchor(7), [button.return.img_w + button.undo.img_w + button.redo.img_w + button.copy.img_w + button.paste.img_w - margin*5, 0]))),
			set(button.paste.vars.offset, -margin),
		]),
	
	] where button = {	'nav1' -> object('ct-button-nav-1'), 
						'nav3' -> object('ct-button-nav-3'), 
						'nav7' -> object('ct-button-nav-7'), 
						'nav9' -> object('ct-button-nav-9'), 
						'navl5' -> object('ct-button-nav--5'), 
						'navg5' -> object('ct-button-nav-+5'), 
						'navccw' -> object('ct-button-nav-ccw'), 
						'navcw' -> object('ct-button-nav-cw'),
						'toolbox' -> object('ct-tool-pane'), 
						'toolccw' -> object('ct-button-nav-ccw'), 
						'toolcw' -> object('ct-button-nav-cw'),
						'trains' -> object('ct-button-trains'),
						'erase' -> object('ct-button-erase'),
						'score' -> object('ct-score-widget'),
						'msgr' -> object('ct-message-widget'),
						'return' -> object('ct-button-return'),
						'undo' -> object('ct-button-undo'),
						'redo' -> object('ct-button-redo'),
						'reset' -> object('ct-button-reset'),
						'copy' -> object('ct-button-copy'),
						'paste' -> object('ct-button-paste'),
						}
	where margin = -5",
		
on_ctrl_left: "move([-1,-1,0])",
on_ctrl_right: "move([1,1,0])",
on_ctrl_up: "move([1,-1,0])",
on_ctrl_down: "move([-1,1,0])",
on_ctrl_high: "move([0,0,1])",
on_ctrl_low: "move([0,0,-1])",

on_button_left: "move([0,-1,0])",
on_button_right:"move([0,1,0])",
on_button_up:   "move([1,0,0])",
on_button_down: "move([-1,0,0])",

on_update_score: "vars.scoredisp.update(vars.score)",

on_print: "[
	//debug('Saved Map Data: (copy the following) \\n\\n${str(saved)}\\n\\n'),
	set_clipboard_text(str(saved)),
	set(registry.ct_quicksave, saved),
	] where saved =	serialized_level",
	
on_quick_load: "[
	map(toLoad.map, 'data', [	obj.setToGrid(data[1]), 
								set(obj.vars.save_val, data[2]), 
								obj.set_branch(data[3]), 
								add_object(obj)] 
								where obj = object(data[0])),
	map(filter(level.chars, 'ch', find(ch.vars.group, 'grp', grp != 'player')), 'old', fire_event(old, 'remove')),
	if(toLoad['limits'], 
		set(vars.groupMap, {
			'offset': gmOffset,
			'size': maxs,
			'objs': generate_clear_groups_cache(maxs)})
		where maxs = list_add(
			best_of(transform(toLoad.map, v[1]) + [toLoad['limits']['max']], def(a,b) a>b), #We find the maximum value we have a block at, or the maximum value we could place a block at via limits.#
			gmOffset) #This offsets the smallest block so it's at origin, since we can't have negative list indexes.#
		where gmOffset = list_subtract([0,0,0],mins)
		where mins = best_of(transform(toLoad.map, v[1]) + [toLoad['limits']['min']], def(a,b) a<b), #Minimum value. See above comment.#
		[
		set(vars.groupMap, {
			'offset': [0,0,0],
			'size': [0,0,0],
			'objs': generate_clear_groups_cache([0,0,0])
			}),
		//debug('Warning: didn`t load groupmap due to missing limits in map data.')
		]),
	fire_event('render_depth'),
	if(toLoad['name'],
		title(toLoad['name']),
		//debug('Warning: No name found in level data.')
		),
	set(vars.name, toLoad['name']),
	set(vars.limits, toLoad['limits']),
	set(vars.identification, toLoad['id']),
	set(vars.score, 0+toLoad['score']),
	schedule(2, fire_event('update_score')),
	set(vars.completed_level, 0+toLoad['complete']),
	set(vars.entrances, []),
	//set(self.vars.undo, []),
	//set(self.vars.redo, []),
	//schedule(1, fire_event('disable_undo_and_redo_buttons')),
	setToGrid([0,0,0]),
	fire_event('render_depth'),
	schedule(1, fire_event('render_depth')),
	schedule(1, fire_event('rebuild_all_pathing_nodes')),
	//set(vars.end_script, toLoad['end script']),
	eval(toLoad['start script']), //This is not a security thing, because ffl is secure, right?
	schedule(3, fire_event('finished_load_level')), //Script trigger. Waits 3 because buttons take a while.
	]",												//Called here because we'll probably want it a-fresh when we reload the level.
	
on_render_depth: "render_depth(vars.location, 1)",
on_render_depth_slowly: "render_depth(vars.location, 10)",

on_disable_undo_and_redo_buttons: "[set(self.vars.undoButton.animation, 'disabled'), set(self.vars.redoButton.animation, 'disabled')]",

on_place: "place_piece(self.vars.location)",
on_unplace: "remove_piece(self.vars.location)",
		
on_rebuild_all_pathing_nodes: "[
	#debug('REBUILDING'),#
	set(vars.groupMap, {
		'offset': vars.groupMap['offset'],
		'size': vars.groupMap['size'],
		'objs': generate_clear_groups_cache(vars.groupMap['size'])
		}),
	transform(level.chars, fire_event(v, 'add_to_cache')),
]",

on_trains: "[
	swallow_event(),
	schedule(5+1d15, sound('whistle-${choose([3,4,5,7])}.wav', 0.3)),
	set(vars.happy_entrances, 0),
	map(filter(level.active_chars, 'lc', 'train' in lc.vars.group), 'trains', [
		fire_event(trains.vars.on_track, 'train_exit', trains),
		fire_event(trains.vars.on_track, 'train_exit2', trains),
		remove_object(trains),
		]),
	map(vars.entrances, 've', fire_event(ve, 'start_spawn')),
# 		if(trains_are_running, 
			map(vars.entrances, 've', fire_event(ve, 'stop_spawn')),
			map(vars.entrances, 've', fire_event(ve, 'start_spawn'))),
		set(trains_are_running, not trains_are_running),
#		]",

on_process: "[
	proto_event('player_input', 'process'),
	proto_event('ct-block', 'process'),
	
	/*	
    debug_chart('fps', constrain(0, performance().fps, 100)),
    debug_chart('cycles_per_second', constrain(0, performance().cycles_per_second, 100)),
    debug_chart('delay', constrain(0, performance().delay, 100)),
    debug_chart('draw', constrain(0, performance().draw, 100)),
    debug_chart('process', constrain(0, performance().process, 100)),
    debug_chart('flip', constrain(0, performance().flip, 100)),
    debug_chart('nevents', constrain(0, performance().nevent, 100)),
    debug_chart('time', time()%100),
	*/
	
	set(keys_already_down, keys),
	if(size(nkd) > 0, [ 			//debug(keys),
		if(not 308 in keys, [
			if(kmap['low']			in nkd, fire_event('ctrl_low')),
			if(kmap['high']			in nkd, fire_event('ctrl_high')),
			if(kmap['help']			in nkd, fire_event('help')),
			if(kmap['debug2']		in nkd, fire_event('debug2')),
			if(kmap['load']			in nkd, if(clip_data or registry.ct_quicksave, [set(toLoad, clip_data or registry.ct_quicksave), fire_event('quick_load')]) where clip_data = if(is_map(clip_data_), clip_data_) where clip_data_ = eval(get_clipboard_text())),
			if(kmap['print']		in nkd, fire_event('print')),
			if(kmap['place']		in nkd, fire_event('place')),
			if(kmap['unplace']		in nkd, fire_event('unplace')),
			if(kmap['select left']	in nkd, select_piece(1)),
			if(kmap['select right']	in nkd, select_piece(-1)),
			if(kmap['rotate cw']	in nkd, [rotate_view(1), clearRedo()]),
			if(kmap['rotate ccw']	in nkd, [rotate_view(-1), clearRedo()]),
			if(kmap['trains']		in nkd, fire_event('trains')),
			if(kmap['block alt']	in nkd, map(at_pos, 'blk', fire_event('block_alt', blk))),
			if(kmap['next branch']	in nkd, next_branch),
			if(kmap['undo']			in nkd, undo),
			if(kmap['redo']			in nkd, redo),
			
			if(257 in nkd, [set(keymode, 'dvorak'), debug('now using dvorak keymap')]),
			if(258 in nkd, [set(keymode, 'qwerty'), debug('now using qwerty keymap')]),
			if(259 in nkd, [set(keymode, 'azerty'), debug('now using azerty keymap')]),
			#if( 27 in nkd, abort()),# #Well, it does…#
			if( 8 in nkd and 306 in keys, abort()),
			
			if(kmap['hotblock 0']	in nkd, select_piece(vars.hotblocklist[0])),
			if(kmap['hotblock 1']	in nkd, select_piece(vars.hotblocklist[1])),
			if(kmap['hotblock 2']	in nkd, select_piece(vars.hotblocklist[2])),
			if(kmap['hotblock 3']	in nkd, select_piece(vars.hotblocklist[3])),
			if(kmap['hotblock 4']	in nkd, select_piece(vars.hotblocklist[4])),
			if(kmap['hotblock 5']	in nkd, select_piece(vars.hotblocklist[5])),
			if(kmap['hotblock 6']	in nkd, select_piece(vars.hotblocklist[6])),
			if(kmap['hotblock 7']	in nkd, select_piece(vars.hotblocklist[7])),
			if(kmap['hotblock 8']	in nkd, select_piece(vars.hotblocklist[8])),
			if(kmap['hotblock 9']	in nkd, select_piece(vars.hotblocklist[9])),
		],[
			if(true or self.vars.displayCopyButtons, [
				if(kmap['copy']		in nkd, fire_event('map_to_clipboard')),
				if(kmap['paste']	in nkd, fire_event('map_from_clipboard')),
			]),
		]),
	])	where nkd = filter(keys, 'key', not key in keys_already_down),
	if(kmap['block value up']	in keys and cycle%5 = 1, block_value(at_pos, 1)),
	if(kmap['block value down']	in keys and cycle%5 = 1, block_value(at_pos, -1)),
	
	if(edit_all,
		text_ctrl.set_text(	'pos: ${str(location)}\\n' + //TODO: Move over to ct-cursor-edit.
						   	('Adding a ${colour}${pieces[piece_selected]}.\\n' where colour = if(vars.target_value = 'normal', '', vars.target_value + ' ')) + 
							if(size(at_pos) > 0, 'Here: ', '') + list_cat(map(at_pos, 'ap', ap.type + ' (z${str(ap.zorder)}) ')) + '\\n' + 
							list_cat(map(at_pos, 'ap', if(mess, mess+' ', '') where mess = ap.message)))),
	set(text_ctrl.x, midpoint_x-125/2), set(text_ctrl.y, y+260/2),
	
	if(tmp.scrolling, [
		set(xy, newxy),
		if(can_move_to(newLoc),
			set(location, newLoc),
			set(xy, xy),
		) where newLoc = selectedGrid([newxy[0]+img_h/2, newxy[1]+img_w/2])
		]) where newxy = list_add(xy, list_single_divide(tmp.scroll_magnitude, 10)),
	
	] where keys = key_input
	where kmap = keymap[keymode]
	where at_pos = at_position",
		
"on_mouse_down*": "if(not handled,
	switch(/*dump*/(mouse_button),
	1, monitor_for_drag	(1),
	2, start_scroll		(2),
	3, monitor_for_drag	(3),
	4, if_ctrl(fire_event('ctrl_low'), fire_event(self, 'rotate_piece_ccw')), 
	5, if_ctrl(fire_event('ctrl_high'), fire_event(self, 'rotate_piece_cw')),
	6, undo,
	7, redo,
	'mouse error')
	where monitor_for_drag = def(button_num) if(not tmp.scrolling, set(tmp.monitor_for_drag, abs_mouse_xy(mouse_index)))
	where start_scroll = def(mouse_btn) [
		set(tmp.scrolling, abs_mouse_xy(mouse_index)), 
		set(tmp.scroll_magnitude, [0,0]),
		set(tmp.monitor_for_drag, null),
		set(tmp.dragging, null),
		set(vars.preview.alpha, 0),
		[	set(tmp.scroll_marker, scrlm),
			add_object(scrlm),
		] where scrlm = object('${type}.scroll-marker', abs_mouse_xy(mouse_index)[0], abs_mouse_xy(mouse_index)[1], true)]
	)",
		
"on_mouse_up*": "[
	if(not tmp.dragging or tmp.scrolling,
		if((not handled) and vars.preview.setToGrid,
			switch(mouse_button, 
				1, [if(not erase_button.pressed,	place_piece(selectedGrid([mouse_x, mouse_y])),
													remove_piece(selectedGrid([mouse_x, mouse_y]))),
				set(tmp.monitor_for_drag, null)],
				2, null,
				3, [remove_piece(selectedGrid([mouse_x, mouse_y])),
				set(tmp.monitor_for_drag, null)],
				)),
		switch(mouse_button,
			1, end_drag,
			2, end_scroll,
			3, end_drag)
			where end_drag = [set(tmp.dragging, null), set(tmp.monitor_for_drag, null)]
			where end_scroll = [set(tmp.scrolling, null), if(tmp.scroll_marker, remove_object(tmp.scroll_marker))]),
	if(drag_mode_is_horizontal = false, [
		setToGrid(rloc),
		render_depth(rloc, 5),
		set(drag_mode_is_horizontal, null),
		] where rloc = map(location, round(value))),
	]",
	
"on_mouse_move*": "[
	if(not tmp.dragging or tmp.scrolling,
		if((not handled) and vars.preview.setToGrid and vars.preview.underlay.setAllToGrid, [ //Need to check. The order these are defined in is non-deterministic, and *sometimes* this function will run first.
			[	vars.preview.setToGrid(new_position_offset),
				vars.preview.warn_colour(level.player.is_in_limits(new_position_offset)),
				vars.preview.underlay.setAllToGrid(new_position),
			] where new_position_offset = list_add(
				new_position,
				block_offset(pieces[piece_selected]))
			where new_position = selectedGrid([mouse_x, mouse_y]),
			if(tmp.monitor_for_drag and distance(tmp.monitor_for_drag, abs_mouse_xy(mouse_index)) > 20, [ //DRAG THRESHOLD//
				set(tmp.dragging, abs_mouse_xy(mouse_index)),
				set(tmp.drag_mode_is_horizontal, if(mouse_button=4, false, true)),
				vars.preview.set_alpha(0),
				],
				vars.preview.set_alpha(255))
			]),
		if(tmp.dragging, [
			if(drag_mode_is_horizontal,
				[	set(xy, newxy),
					if(can_move_to(newLoc),
						set(location, newLoc),
						set(xy, xy)
					),
				],
				if(can_move_to(newGridLoc), [	
					setToGrid(newGridLoc),
					render_depth(location, 1),
				]) where newGridLoc = location[0:2]+[location[2]+(abs_mouse_xy(mouse_index)[1] - tmp.dragging[1])/100.0]),
			set(tmp.dragging, abs_mouse_xy(mouse_index)),
			]  where newLoc = selectedGrid([newxy[0]+img_h/2, newxy[1]+img_w/2])
			where newxy = list_subtract(xy, list_subtract(abs_mouse_xy(mouse_index), tmp.dragging)),
			set(tmp.scroll_magnitude, list_subtract(abs_mouse_xy(mouse_index), tmp.scrolling)),
		)
	),
	set(vars.last_mouse_coords, [mouse_x, mouse_y])]",
	
on_snap_cursor: "[set(level.camera_position, [self.x*100+tmp.camOffset[0]*100,self.y*100+tmp.camOffset[1]*100])]",

on_train_home: "abort()",

//Next three functions: arg is a map. Key a gives the first train.	
on_train_crashed: "vars.message.add_text('A train ran out of track.')", //${arg.error}
on_train_wrong_branch: "vars.message.add_text('Problem: A train from a ${arg.a.vars.target_branch} entrance is on track for a ${arg.b.vars.target_branch} entrance.')",
on_train_right_branch: "[
	[
		set(vars.happy_entrances, totalHome), 
		if(totalHome = size(entrances), 
			fire_event('won_level', arg))
	]	where totalHome = vars.happy_entrances + 2 /* arg.a and arg.b */,
	[
		set(ps.midpoint_x, arg.a.mid_x/2+arg.b.mid_x/2),
		set(ps.midpoint_y, arg.a.mid_y/2+arg.b.mid_y/2),
		add_object(ps),
	]	where ps = object('ct-train-home-effect', x, y, facing)
	]",

on_srv1: "rotate_view(1)", //perhaps "scene rotate view one"?
on_srvl1: "rotate_view(-1)",

on_undo: "undo",
on_redo: "redo",

on_map_to_clipboard: "[
	//set_clipboard_text(),
	//debug('copying hello to clipboard'),
	set_clipboard_text(dump('{\n' + str(
		map_cat_delim(filter(serialized_level, value), ',\n')
		) + '\n}' )),
	] where map_cat_delim = def(list, delim) list_cat_delim(map(keys(list), if(is_string(value), q(') + value + q('), str(value)) + ': ' + if(is_string(list[value]), '~' + list[value] + '~', str(list[value]))), delim)",
on_map_from_clipboard: "
	if(clip_data, [
		set(toLoad, clip_data), 
		fire_event('quick_load'),
	]#, debug('Error loading map from clipboard.')#) where clip_data = if(is_map(clip_data_), clip_data_) where clip_data_ = eval(get_clipboard_text())",


#The rotation vars were originally designed (and is still used) for camera rotation. The var is the inverse of what we would normally do when just rotating it.
on_rotate_piece_cw:  "[if(next, select_piece(next)) where next = object(pieces[piece_selected]).vars.ccw, fire_event('play_rotate_sound')]",
on_rotate_piece_ccw: "[if(next, select_piece(next)) where next = object(pieces[piece_selected]).vars.cw,  fire_event('play_rotate_sound')]",
on_play_rotate_sound: "sound('tick-1.wav', 0.5)",

on_reset: "if(map_unlocked, [
	set(self.vars.toLoad, self.vars.toRevert),
	fire_event(self, 'quick_load'),
	add_snapsnapshot_undo,
	map_lock(3),
	] where sl = serialized_level
	where oldBlocks = filter(level.chars, value.vars.location))",

on_won_level: "[
	set(completed_level, 1),
	vars.message.add_text('Victory achieved. Good work.'),
	fire_event('add_map_lock'),
	//Might want to disable buttons/mouse/placing, here.
	
	set(background.alpha, 0),
	set(background.z, 100050),
	add_object(background),
	[	map(range(1, slow_fade_duration+1), schedule(value, set(background.alpha, decimal(value)/slow_fade_duration*200))),
		schedule(slow_fade_duration, [
			set(vtxt.z, 100055),
			set(vtxt.mid_xy, [level.camera_position[2]/2, level.camera_position[3]/2-100]),
			set(vtxt.use_absolute_screen_coordinates, true),
			vtxt.set_text({'text':'Success!', align:'center', size:3}),
			add_object(vtxt),
			
			set(vsubtxt.z, 100055),
			set(vsubtxt.mid_xy, [level.camera_position[2]/2, level.camera_position[3]/2-50]),
			set(vsubtxt.use_absolute_screen_coordinates, true),
			vsubtxt.set_text({'text':'You beat the level. Good work.', align:'center', size:1}),
			add_object(vsubtxt),
			
			[map(pop_items, schedule((index+1)*pop_delay, value)),
			schedule((size(pop_items)+1)*pop_delay, [
					set(return_button.event_handlers.create, 'swallow_event()'), 
					set(return_button.event_handlers.first_cycle, 'swallow_event()'),
					set(return_button.vars.action, execute(self, fire_event('exit_level'))), 
					set(return_button.mid_xy, [level.camera_position[2]/2-55+25, level.camera_position[3]/2+100]),
					set(return_button.z, 100055),
					set(return_button.help_text, 'Return to the main map.'),
					add_object(return_button),
					
					set(cancel_button.event_handlers.create, 'swallow_event()'), 
					set(cancel_button.event_handlers.first_cycle, 'swallow_event()'),
					set(cancel_button.vars.action, execute(self, remove_screen + make_return_button_green + [fire_event(self, 'remove_map_lock')])),
					set(cancel_button.mid_xy, [level.camera_position[2]/2+55, level.camera_position[3]/2+100]),
					set(cancel_button.z, 100055),
					add_object(cancel_button),
				]) where remove_screen = map([return_button, cancel_button, vtxt, vsubtxt, background] + pop_objs, remove_object(value))
				where return_button = object('ct-button-return')
				where cancel_button = object('ct-button-cancel'),
				
			] where pop_delay = 10
			where pop_items = zip(([[
					pop_objs[0].set_text({'text':'Track Tiles: ${total_tracks}', align:'center', size:1}),
					],[
					pop_objs[1].set_text({'text':'Supports: ${total_supports}', align:'center', size:1}),
					],[
					pop_objs[2].set_text({'text':'Hedges: ${total_hedges}', align:'center', size:1}),
					],[
					pop_objs[3].set_text({'text':'Total: ${total_hedges+total_tracks+total_supports} objects', align:'center', size:1}),
					],[
					pop_objs[4].set_text({'text':'Score: ${vars.score}', align:'center', size:1}),
					],
				] where
				total_tracks = size(filter(level.chars, q(track) in value.vars.group)),
				total_supports = size(filter(level.chars, q(support) in value.vars.group and not q(ground) in value.vars.group)),
				total_hedges = size(filter(level.chars, q(plant) in value.vars.bonus)) ),
				map(pop_objs, [
					set(value.use_absolute_screen_coordinates, true),
					set(value.mid_xy, [level.camera_position[2]/2, level.camera_position[3]/2+index*15-10]),
					set(value.z, 100055),
					add_object(value),
				]),
				a+b)
			where pop_objs = [
					object('text_controller'), //Tracks Placed
					object('text_controller'), //Supports Build
					object('text_controller'), //Bushes Planted
					object('text_controller'), //Total Pieces
					object('text_controller'), //Score
				],
			]),
	]	where slow_fade_duration = 20,
	
	//fire_event('exit_level'),
	] where
	background = object('ct-credits-whiteness'),
	vtxt = object('text_controller'),
	vsubtxt = object('text_controller'),
	make_return_button_green = [self.vars.buttons.return.set_skin({'normal':'normal-green','down':'down-green'})]
	",

on_exit_level: "[
	add(mainMapPlayer.vars.saved_maps, {(toLoad.id or 'custom'): serialized_level}),
	screen_flash([0,0,0,0], screen_fade_out_delta(), screen_fade_steps()+3),
	schedule(screen_fade_steps()+1, [
		teleport('titlescreen.cfg', '', 'instant', mainMapPlayer),
		screen_flash([0,0,0,255], screen_fade_in_delta(), screen_fade_steps()),
		]),
	]",
	
on_clearRedo: "clearRedo()",

on_replace_redo_with_current_snapshot: "[
			set(self.vars.undo, list_replace_elements(
				self.vars.undo, 
				index_to_replace, 
				self.vars.undo[index_to_replace] + {
					redo: def() [
						fire_event(self, 'add_snapsnapshot_undo'),
						set(self.vars.toLoad, sl + {map:[]}),	//Save ATTRIBUTES, but not blocks. We'll need the blocks in their unserialized form.
						fire_event(self, 'quick_load'),
						schedule(2, [ //We have to wait for quick load to do it's thing. It's possible we should just transport the minimal functionality we need back to here instead of using the event.
							map(oldBlocks, [add_object(value), ]),
								schedule(2, [ //Note: This logic is mostly duplicated above, in the property that calls it.
									fire_event('reset_pathing_node_paramaters'),
									fire_event('rebuild_all_pathing_nodes'),
									fire_event('refresh_entrances_cache'),
									]),
							]),
						],
					'hack': [sl, oldBlocks],	
					} + {hack: null}
					where sl = serialized_level
					where oldBlocks = blocks_in_play
				)),
			] where index_to_replace = size(self.vars.undo)-1",
			
on_reset_pathing_node_paramaters: "reset_pathing_node_paramaters",

on_refresh_entrances_cache: "set(vars.entrances, filter(level.chars, value.consts.is_entrance))",

on_add_snapsnapshot_undo: "add_snapsnapshot_undo",

on_window_resize: "[
	map(filter(level.chars, value.use_absolute_screen_coordinates), remove_object(value)),
	fire_event('setup_buttons')]",
	
on_add_map_lock: "set(tmp.map_lock, tmp.map_lock+1)",
on_remove_map_lock: "if(tmp.map_lock > 0, set(tmp.map_lock, tmp.map_lock-1))",

object_type: [{
	id: "scroll-marker",
	z: 101,
	use_absolute_screen_coordinates: true,
	always_active: true,
	serializable: false,
	on_end_anim: "animation('normal')",
	on_create: "set(z, 101)",
	animation: [
			{
				"@base": true,
				"scale": 1
			},
			{
				"duration": 5,
				"frames": 2,
				"id": "normal",
				"image": "experimental/spiderbot.png",
				"pad": 0,
				"rect": [87,65,94,72]
			}
		],
	},{
	id: "dbg",
	z: 150,
	always_active: true,
	on_end_anim: "animation('normal')",
	on_create: "set(z, 150)",
	animation: [
			{
				"@base": true,
				"scale": 1
			},
			{
				"duration": 5,
				"frames": 2,
				"id": "normal",
				"image": "experimental/spiderbot.png",
				"pad": 0,
				"rect": [87,65,94,72]
			}
		],
	},],
}