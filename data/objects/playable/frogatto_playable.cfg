{
id: "frogatto_playable",
prototype: ["playable"],
hitpoints: 4,
mass: 5,
friction: 2000,
solid_area: [9,8,23,30],
traction_in_water: 1000,
affected_by_currents: true,
feet_width: 5,
zorder: "@include data/zorder.cfg:player",

editor_info: {
	help: "This sets where Frogatto starts on a given level, if the game starts on that level or if the player is teleported to that level without a specific object as a destination. Instances placed in-level will be ignored if there is already a playable character the player is playing.",
	category: "player",
},

//these spritesheets get switched for fat frogatto, so we can't compile them.
no_compile_image: "characters/frogatto-spritesheet1.png,characters/frogatto-spritesheet3.png,characters/frogatto-spritesheet4.png",
load_variations: "fat",

properties: {
#-------------------------- attack/damage handlers --------------------------#
	flinch_threshold: 0, //Used to trigger when we do that little 'jump' when we get hurt. Since we always want to do it, we've got the variable set to 0. It defaults to 3, otherwise.
	player_specific_damage_response: "def() -> commands execute(me, if(FAT, shoot_spit_attack, animation('hurt') ))",

	play_hurt_sounds: "def(string|null type) -> commands
		switch(type,
			'bite', sound('hurt-bite'+1d3+'.wav'),
			'stab', sound('hurt-stab'+1d2+'.wav'),
			'slash', sound('hurt-slash'+1d3+'.wav'),
			'organic-bludgeon', sound('hurt-organic-bludgeon.wav'),
			sound('TakeDamage.wav')
		)",

#-------------------------- general handlers --------------------------#
	zombie_object_cleanup: "def() -> commands [remove_object(_tongue_tip), set(_tongue_tip, null)]",

	is_player_body_part: 1,

	_started_falling_cycle: { type: "null|int" },

	can_jump: "def() -> bool
	  bool(is_standing and (animation not in ['interact', 'fall', 'jump', 'start_jump']) or 
	      //after frogatto starts falling off a ledge, give the player
		  // a little grace in allowing them to still initiate a jump.
	      _started_falling_cycle != null and animation = 'fall' and
		  cycle < _started_falling_cycle+10)",
	
	bounce_on: "def(object frog, object obj) -> commands [
		set(frog.velocity_y,
			-max(obj.spring_amount,
				((frog.velocity_y*obj.springiness)/100 * (100 - abs(bounce_angle)))/100
			)
		),
		add(frog.velocity_x, 
			((frog.velocity_y*obj.springiness)/100*bounce_angle)/100
		),
		fire_event(obj, 'bounced_on'),
		set(vars.bounced_on_chain, new_bounced_on_chain),
		if(vars.new_bounced_on_chain > 8, achievement('jackalope')),
		] where bounce_angle = (obj.bounce_roundness*(frog.midpoint_x - obj.midpoint_x))/(max(1, obj.w)),
				new_bounced_on_chain = if(obj.team != 'evil', 0, vars.bounced_on_chain + 1)",
	
	register_annoyed_npc: "def(string name) -> commands debug('Recorded ' + name + ' as annoyed.')",
	
	do_post_victory_transport: "def(object target_level, object target_obj) -> commands execute(me,[
									standard_victory_music,
									title('Victory!',200),
									do_cinematic_float(
									[
									def() schedule(1, sinusoidal_transition(90, 0.0, 1.0, 2, 1, level, 'zoom')),
									def() schedule(89, set(level.player.control_lock, null)),
									def() schedule(90, if(target_level and target_obj, teleport(target_level, target_obj, 'iris'))),
									def() schedule(92, screen_flash([0,0,0,255], [0,0,0,0], 100)),
									def() schedule(92+100, screen_flash([0,0,0,255], [0,0,0,-3], 85)),
									]
									)
								])",
	do_post_victory_without_transport: "def(commands post_landing_todos) -> commands execute(me,[
					standard_victory_music,
					title('Victory!',200),
					do_cinematic_float(
					[def() schedule(119, set(level.player.control_lock, null)),
					def() schedule(60, sinusoidal_transition(100, 1.0, 1.0, 1, 1, level, 'zoom')),
					def() schedule(160, set(level.zoom, 1.0))] + post_landing_todos
					)
				])",
	do_cinematic_float: "def(commands additional_landing_todos) -> commands [
							set(level.player.control_lock, []),
							animation('floating_spin'),
							do_upon_landing( def() animation('emote_victory') ),
							map(additional_landing_todos, do_upon_landing( value )),
							sinusoidal_transition(period/4, 0.0, 1.0, 1, 1, level, 'zoom'),
							sinusoidal_transition(period, 1.0, 1.0, 0, -200, level.player, 'velocity_y'),
							schedule(1*(period/4),animation('floating_spin_fast')),
							schedule(2*(period/4),animation('floating_spin_faster')),
							schedule(period - period/8,animation('floating_spin')),
						] where period = 400",
	
	do_upon_landing: "def(commands todo) -> commands add(_todo_upon_landing, [todo])",
	fullfill_todo_upon_landing: "[map(_todo_upon_landing,value()),set(_todo_upon_landing, null)]",
	
	_todo_upon_landing: {type: "[commands]|null", default: null}, 
	
	
	/*tracking key presses:  we can accomplish mouseup, mousedown, and mouse-held by doing the following:
	 By setting the cycle on which a key is pressed, we limit ourselves to a set of keys that need to be re-checked on later frames to see if they're still held down.  We don't need to register key-tracking up-front, as having an access of ctrl_keyboard in on_process will make this implicit (though any gap of more than one cycle in on_process tracking will break continuity of key-holds).
	 
	 On the first frame, we set the current cycle a key has been pressed at.  We leave this alone if the key continues being pressed (which allows us to know how long it's been pressed), or if a key is released, we null this out. */
	
	_key_store: { type: "{string -> int|null}", default: {} },
	track_key: "def(string key_name) ->commands if(key_name in ctrl_keys, if(not key_name in _key_store, add(_key_store, {(key_name) -> cycle})), set(_key_store[key_name], null))",
	ctrl_keyboard: "def(string key_name) ->int|null if(key_name in _key_store, (cycle - _key_store[key_name]), null )",

	spawn_on_ref: "def(string name, decimal x, decimal y, int facing) -> commands [
		set(obj.parent, self.standing_on),
		add_object(obj),
		] where obj = object(name, x, y, facing)",
        	
#-------------------------- cheat codes --------------------------#
	//in the spirit of early cheat codes, this is meant to make testing later levels more balanced against how powerful the player would normally be on such a level; it immediately empowers the player as though the player has purchased a bunch of late game upgrades.  This way we don't fall into making the levels easy enough to pass on a mere 2 hearts.
	//note that the way to enter this code is to type ctrl+d to bring up the debug prompt, type "hax", press return to execute the code, and then press escape to turn off the debug prompt.
	hax: "[
		map(range(ability_list_full.size), schedule(value,fire_event('hax'))),
		set_item_amount('tongue_extension', 2),
		set_item_amount('greater_mana_talisman', 1),
		set_item_amount('lesser_mana_talisman', 1),
		add_item('acquirable_attractor', 1),
	]",
	hax_: "[
		set(level.player.driver.max_hitpoints, 10), 
		set(level.player.driver.hitpoints, 10),
		set(level.player.mana, 5000), 
		map(ability_list_full, add_ability(value)),
		]",	
	choppa: "set(vars.jump_cheat,1)",
	smite: "map(level.chars, if(value.team = 'evil', set(value.hitpoints, 0)))",
	supes: "[hax,choppa,set(invincible,-1)]",


#-------------------------- inventory handlers --------------------------#
	
		#-- Passive Items --#
	item_list_full: "['lesser_mana_talisman','greater_mana_talisman','tongue_extension']",
	//future ones we'll be adding "['mana_container','medium_mana_talisman','heart_container','heart_container_piece']",


		#-- Abilities --#
	ability_list_full: "['firebreath','energyshot','homingshot','acidbreath']",
	add_ability: "def(string name) -> commands
		if((not name in ability_list) asserting name in ability_list_full, 
			set(level.player.ability_list, sort(level.player.ability_list + [name], index(ability_list_full, a) < index(ability_list_full, b))))",


#-------------------------- attack/ability handlers --------------------------#
	uninterruptible_animations: "['turn', 'crouch', 'enter_crouch','interact'] + emote_animations + cinematic_animations + attack_animations",
	
	emote_animations: "['emote_victory', 'emote_angry', 'emote_nod', 'emote_talk', 'emote_raisedfinger', 'emote_impatient', 'emote_confused', 'emote_oh', 'emote_geez']",
	cinematic_animations: "['item_get_begin', 'item_get_hold', 'item_get_end']",
	interruptible_cinematic_animations: "['floating_spin', 'floating_spin_fast', 'floating_spin_faster']",
	attack_animations: "['jump_attack', 'energyshot', 'attack', 'walk_attack', 'firebreath_begin','firebreath_cycle','firebreath_end', 'spit']",



	maintain_locomotion: "def() -> commands [if(ctrl_left, set(accel_x,1600)), if(ctrl_right, set(accel_x,1600))]",

	//NOTE: regarding channelled attacks, especially those which consume a low amount of mana per frame.
	// Problem:  if your only requirement to initiate the attack is the mana/frame cost, then you will "sputter" when your mana is low.  For example, if it takes 20 mana to fire a round, and it takes 10 frames to recharge that much (say, recharging 2 mana/frame), you'll go from firing a constant steam of one projectile/frame, to firing only one projectile every 10 frames 
	// Visually, this actually looks kinda cool on the fire attack, but it's problematic, because the high cooldown means that this sputtering version is as effective as the real thing even if you have no mana!
	// There are a few options to prevent this, we've gone with both 1 and 2 for now:
	// 1] when mana is exhausted, incur a "mana shock" timeout where all mana-based abilities are unuseable for a few moments.
	// 2] keep burning mana at the same rate, regardless of whether the powerup is being used, for the full cooldown duration of the ability.
	// 3] incur a startup cost to initiate the ability at all; if something costs 2 mana/frame, maybe charge 40 mana to start the ability up at all.
	// 4] rather than a startup cost, require the player to have at least > X mana to use the ability.  This differs from 2] in not actually consuming that startup cost, just requiring you to have it.
	attack: "def() -> commands 
		if('fat' in variations, tongue(), 
			if(underwater, shoot_bubble(),
				switch(ability_list[current_ability],
					'tongue', tongue(),
					'firebreath', mana_shock_guard(shoot_fire()),
					'energyshot', mana_shock_guard(shoot_energy_shot()),
					'homingshot', mana_shock_guard(shoot_homing_shot()),
					'acidbreath', mana_shock_guard(shoot_acid())
				)
			) 
		)",
		
	spawn_tongue: "def(decimal angle) -> commands
			[if(animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'run', 'enter_lookup', 'lookup','skid', 'land'], animation('attack')),
			if(animation in ['jump', 'fall', 'start_jump'], animation('jump_attack')),
			spawn('${self.type}.tongue_tip', if(facing > 0, x + 30, x), y + 46, {facing: facing, _tongue_angle:angle, _frog: me})]",
	
	tongue: "def() -> commands
			if(ctrl_tongue_counter > 1, null,
				if('fat' in variations,
					if(not (animation in ['interact']), shoot_spit_attack ),
					[
						if(animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'run', 'enter_lookup', 'lookup','skid', 'land', 'jump', 'start_jump', 'fall'],
							if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, spawn_tongue(-45),
								if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, spawn_tongue(45),
									if(ctrl_up, spawn_tongue(-90), if(ctrl_down, spawn_tongue(90), spawn_tongue(0))))))
					]
				)
			)",
	
	
#-------------------------- mana --------------------------#
	mana_base_regen_coefficient: "10*(0.5 + if(has_item('lesser_mana_talisman'), 0.3333) + if(has_item('greater_mana_talisman'), 0.6667))",
	
	//This is a pretty carefully-tuned non-linear function that makes low levels of mana give much faster regen, so that you're not stuck helpless on levels without base combat available.  The purpose then of mana isn't primarily about "running out", but about keeping high-consumption techniques harder to use.  Basically this makes the ability to use techniques scale with the amount of mana you have, which matters because the actual usefulness value in the game changes accordingly (being able to do a pea-shooter attack is priceless when you have almost no mana)
	mana_regen_per_frame: "mana_base_regen_coefficient*max(0.1,((max_mana-(mana/3))/decimal(max_mana))^8)",
	
	mana_costs: "{'firebreath' : 35, 'homingshot' : 1000, 'energyshot' : 200, 'acidbreath' : 650}",
	
	//mana_cooldown_time: how long mana keeps burning and the interval between which the ability can't deal damage
	mana_cooldown_time: "{'firebreath' : 10, 'homingshot' : 0, 'energyshot' : 0, 'acidbreath' : 0}", 
	
	//ability_charge_time: how long an ability needs to "charge up" before you can fire it again 
	ability_charge_time: "{'firebreath' : 0, 'homingshot' : 30, 'energyshot' : 5, 'acidbreath' : 60}",
	
	//check all the standard criterion for whether the ability can be used.
	ability_is_charged_up: "def(string ability_name) -> bool 
		(not mana_shock_active)
		and mana >= mana_costs[ability_name]
		and min(
			ability_charge_time[ability_name],
			cycle-tmp.started_using_ability_at_cycle[ability_name]
			) >= ability_charge_time[ability_name]",
	
	//check if we need to burn mana after having just used this ability
	ability_is_cooling_down: "def(string ability_name) -> bool 
		min(
			mana_cooldown_time[ability_name],
			cycle - tmp.started_using_ability_at_cycle[ability_name]
			) < mana_cooldown_time[ability_name]",
	
	//used for regular, active consumption - note that we DON'T subtract mana if we're cooling down, otherwise we'd double-dip
	use_mana_for_ability: "def(string ability_name) -> commands [
		if(not ability_is_cooling_down(ability_name),
			add(mana, -mana_costs[ability_name])),
		set(me.tmp.started_using_ability_at_cycle[ability_name], cycle)
		]",
	
	//used in the process loop to burn cooldown mana for any recently used powers
	use_mana_cooldowns: "def() -> commands map(ability_list_full, if(ability_is_cooling_down(value), add(me.mana, -mana_costs[value]) ))",
	
	
#-------------------------- attacks --------------------------#
	shoot_bubble: "def()  -> commands
		if(cycle%8=0,	[spawn('${self.type}.bubble_shot',midpoint_x+10*facing,midpoint_y,facing, [set(child.velocity_x,if((ctrl_up or ctrl_down) and (not(ctrl_left or ctrl_right)),1d100-50,400+1d100)*facing + me.velocity_x),set(child.velocity_y,1d100-50 + if(ctrl_up,-400-1d100,0) + if(ctrl_down,400+1d100,0) + me.velocity_y)]),sound('bubble-blow'+1d8+'.wav') ])",

	shoot_fire_active: "ctrl_tongue_counter > 1 and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('firebreath') and (animation in ['firebreath_begin','firebreath_cycle','firebreath_end'])",
	
	shoot_fire: "def() -> commands [if((not (shoot_fire_active)) and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('firebreath'), animation('firebreath_begin')), shoot_fire_internal()]",
	
	shoot_fire_internal: "def() -> commands if( ability_is_charged_up('firebreath') and
		animation in ['firebreath_begin','firebreath_cycle','firebreath_end'], [spawn('${self.type}.fire_shot',midpoint_x+1d10*facing,midpoint_y+4,facing, 
			[set(child.velocity_x,(1500+1d250)*facing),set(child.velocity_y,1d900-450)]), use_mana_for_ability('firebreath'), if(cycle >= (tmp.last_played_fire_sfx + 12) or tmp.last_played_fire_sfx = null, [sound('firebreath'+1d5+'.wav'),set(tmp.last_played_fire_sfx,cycle)])])",


	shoot_acid: "def() -> commands [if((not (shoot_acid_active)) and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('acidbreath'), animation('acidbreath_begin')), shoot_acid_internal()]",

	shoot_acid_active: "ctrl_tongue_counter > 1 and (not animation in ['enter_crouch', 'crouch']) and ability_is_charged_up('acidbreath') and (animation in ['acidbreath_begin','acidbreath_cycle','acidbreath_end'])",
			
	shoot_acid_internal: "def() -> commands if( ability_is_charged_up('acidbreath') and
		animation in ['acidbreath_begin','acidbreath_cycle','acidbreath_end'], [spawn('${self.type}.acid_shot',midpoint_x+1d10*facing,midpoint_y+4,facing, 
			[set(child.velocity_x,(500+1d150)*facing),set(child.velocity_y,1d400-250)]), use_mana_for_ability('acidbreath'), if(cycle >= (tmp.last_played_fire_sfx + 12) or tmp.last_played_fire_sfx = null, [sound('firebreath'+1d5+'.wav'),set(tmp.last_played_fire_sfx,cycle)])])",


	shoot_homing_shot: "def() -> commands
		if(ability_is_charged_up('homingshot') and (not animation in energyshot_anim_list), [schedule(1,animation(energyshot_anim)), homingshot_fire_projectile(energyshot_angle), energyshot_spawn_head(), use_mana_for_ability('homingshot')])",
	
	homingshot_fire_projectile: "def(angle) -> commands spawn('${self.type}.homingshot', midpoint_x + 45*facing*cos(angle), midpoint_y + 40*sin(angle), facing, [set(child.velocity_x, velocity_x/4 + 2000 * cos(angle) * facing), set(child.velocity_y, velocity_y/4 + 2000 * sin(angle))])",

	
	shoot_energy_shot: "def() -> commands
		if(ability_is_charged_up('energyshot') and (not animation in energyshot_anim_list), [schedule(1,animation(energyshot_anim)) ,energyshot_fire_projectile(energyshot_angle), energyshot_spawn_head(), use_mana_for_ability('energyshot')])",
	
	energyshot_fire_projectile: "def(angle) -> commands spawn('${self.type}.energyshot', midpoint_x + 45*facing*cos(angle), midpoint_y + 40*sin(angle), facing, [set(child.velocity_x, velocity_x/4 + 2000 * cos(angle) * facing), set(child.velocity_y, velocity_y/4 + 2000 * sin(angle))])",
	
	energyshot_angle: "if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, -45,
				if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, 45,
					if(ctrl_up, -90, if(ctrl_down, 90, 0))))",
	
	energyshot_spawn_head: "def() -> commands spawn('${self.type}.frogatto_head_energyshot',midpoint_x,midpoint_y-8,facing, [set(child.vars.head_angle,energyshot_angle)])",
	
	energyshot_anim: "switch(null, //If nothing is to be switched upon, then the function switches based on the first true key.
		me.animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'enter_lookup', 'lookup','skid', 'land'], if(abs(slope_standing_on) < 20, 'energyshot', if(slope_standing_on*facing > 0, 'energyshot_down_slope', 'energyshot_up_slope')),
		me.animation in ['jump', 'fall'], 'energyshot_jump',
		'energyshot')",
	
	energyshot_anim_list: "['energyshot','energyshot_up','energyshot_down','energyshot_jump','energyshot_crouch','energyshot_swim_side','energyshot_swim_down','energyshot_swim_up']",

	super_fireball_fire_projectile: "commands :: spawn('${self.type}.super_fireball', mid_x + 45*facing, mid_y, facing, [set(child.velocity_x, velocity_x/4 + 800 * cos(angle) * facing), set(child.velocity_y, velocity_y/4 + 800 * sin(angle))]) where angle = 0",

	super_energyshot_fire_projectile: "commands :: spawn('${self.type}.super_energyshot', mid_x + 5*facing, mid_y, facing, [set(child.velocity_x, 300 * cos(angle) * facing), set(child.velocity_y, 300 * sin(angle))]) where angle = 0",

	super_homingshot_fire_projectile: "commands :: spawn('${self.type}.super_homingshot', mid_x, mid_y, facing)",

	shoot_spit_attack: "commands :: [if(not animation = 'spit', [animation('spit'), schedule(8, [spit_attack_fire_projectile,set(variations, [])]) ]),
								]",
	
	spit_attack_fire_projectile: "commands :: 
			if(swallowed_object,
			[switch(true,
			ability_list[current_ability] = 'firebreath', [super_fireball_fire_projectile,set(swallowed_object, null)],
			ability_list[current_ability] = 'energyshot', [super_energyshot_fire_projectile,set(swallowed_object, null)],
			ability_list[current_ability] = 'homingshot', [super_homingshot_fire_projectile,set(swallowed_object, null)],
			(ability_list[current_ability] in ['tongue','homingshot','acidbreath']),[
				sound('Spit.wav'),
				
				set(green, 255), set(blue, 255),
				add(gravity_shift, -swallowed_object.vars.swallow_gravity),
				set(swallowed_object.vars.removed_from_play, 0),
				set(swallowed_object.velocity_x, velocity_x + facing*(200 + 7*if(ctrl_up or ctrl_down, spit_power/2, spit_power*2))),
				set(swallowed_object.velocity_y, velocity_y - (600 + if(ctrl_up, if(ctrl_down, -200,200 + 7*spit_power)))),
			
				//set the object's timestamp for when it was spat out, so we can make ourselves invincible to it for a little while.
				set(swallowed_object.time_spat, level.cycle),
				set(swallowed_object, null),
			
				//set the enemy to be in the thrown dimension, meaning it will only collide with the level. If it collides with another object, it should pass through that object in terms of solidity (any collision should actually be handled by body/attack areas, and most likely we expect it to die).
				set(swallowed_object.solid_dimensions_in, ['thrown']),
				if(swallowed_object.thrown_type, set(swallowed_object.type, swallowed_object.thrown_type)),
				set(swallowed_object.animation, 'thrown'),
			
				set(swallowed_object.midpoint_x, midpoint_x + velocity_x/10),
				set(swallowed_object.midpoint_y, midpoint_y - if(is_standing, 2, 22*sign(-velocity_y))),
				resolve_solid(swallowed_object, facing, 0, 50),
				resolve_solid(swallowed_object, -facing, 0, 50),
			
				add_object(swallowed_object),
				fire_event(swallowed_object, 'spat'),
				if(underwater, set(has_feet, false)),
			]),  set(current_ability, index(ability_list,'tongue'))])",

#-------------------------- item management --------------------------#
	has_item: "def(string item_name) -> bool items_carried[item_name] > 0",
	
	number_of_item: "def(string item_name) -> int if(has_item(item_name), items_carried[item_name], 0)",
	
	add_item: "def(string item_name, int count) -> commands
		set(level.player.items_carried, map_merge(level.player.items_carried, {(item_name) : count}))
		asserting item_name != '' | {message:'Attempting to get an item out of inventory, but the item type given is an empty string.', name:item_name, count:count}",
	
	set_item_amount: "def(string item_name, int count) -> commands
		add(level.player.items_carried, {(item_name) : count}) //This sets the amount, because lists when added to overwrite values if the key already exists.
		asserting item_name != '' | {message:'Attempting to set an item in inventory, but the item type given is an empty string.', name:item_name, count:count}",
	
			
#-------------------------- sfx for material-interactions --------------------------#
	tagged_sfx: "def(string action) -> [null|{keys : [string], sound : commands}] switch(action,
		'slide', [
			{keys: ['wood'],	   sound: sound('slide-wood'+1d13+'.wav')},
			{keys: ['foliage'],	sound: sound('slide-foliage'+1d10+'.wav')},
			{keys: ['dirt'],	   sound: sound('slide-dirt'+1d4+'.wav')},
			{keys: ['stone'],	  sound: sound('slide-stone'+1d10+'.wav')},
			{keys: ['wood_solid'], sound: sound('slide-wood-solid'+1d5+'.wav')},
			{keys: ['metal'],	  sound: sound('slide-metal'+1d9+'.wav')},
			{keys: ['padding'],	sound: sound('footstep-slide-padding'+1d4+'.wav')},
			{keys: ['plastic'], sound: sound('footstep-slide-watercooler'+1d6+'.wav')},
			],
		'jump', [
			{keys: ['wood'],	   sound: [base_sound, sound('jump-wood'+1d10+'.wav',0.7)]},
			{keys: ['foliage'],	sound: [base_sound, sound('jump-foliage'+1d8+'.wav')]},
			{keys: ['padding'],	sound: [base_sound, sound('footstep-jump-padding'+1d7+'.wav')]},
			{keys: ['plastic'], sound: [base_sound, sound('footstep-jump-watercooler'+1d6+'.wav')]},
			{keys: ['dirt'],	   sound: [base_sound, sound('jump-dirt'+1d9+'.wav')]},
			{keys: ['stone'],	  sound: [base_sound, sound('footstep-run-stone'+1d8+'.wav')]},
			{keys: ['wood_solid'], sound: [base_sound, sound('jump-wood-solid'+1d3+'.wav',0.6)]},
			{keys: ['metal'],	  sound: [base_sound, sound('footstep-run-metal'+1d5+'.wav',0.6)]},
			{keys: ['default'],	sound: [base_sound, sound('JumpSoft.ogg')]},
			] where base_sound = null /*sound('JumpSoft.ogg')*/,
		'footfall', ([
			{keys: ['wood'],	   sound: [sound('footstep-'+run+'wood'+if(running,1d10,1d7)+'.wav',if(running,0.7,1.0))]},
			{keys: ['foliage'],	sound: [sound('footstep-'+run+'foliage'+if(running,1d9,1d6)+'.wav')]},
			{keys: ['plastic'], sound: sound('footstep-run-watercooler'+1d5+'.wav')},
			{keys: ['dirt'],	   sound: [sound('footstep-'+run+'dirt'+if(running,1d9,1d10)+'.wav')]},
			{keys: ['stone'],	  sound: [sound('footstep-'+run+'stone'+if(running,1d8,1d10)+'.wav')]},
			{keys: ['padding'],	sound: [sound('footstep-'+run+'padding'+if(running,1d7,1d7)+'.wav')]},
			{keys: ['wood_solid'], sound: [sound('footstep-'+run+'wood-solid'+if(running,1d7,1d8)+'.wav',0.6)]},
			{keys: ['metal'],	  sound: [sound('footstep-'+run+'metal'+if(running,1d5,1d5)+'.wav',0.8)]},
			{keys: ['default'],	sound: [sound('footstep'+1d4+'.wav')]},
			] where run = if(animation in ['run'],'run-',''),
					running = (animation in ['run']) )
		)",
	
#-------------------------- movement commands --------------------------#
		
	should_be_standing: "bool <- self.animation in ['stand', 'stand_up_slope', 'stand_down_slope', 'run', 'walk', 'land', 'lookup', 'crouch', 'enter_crouch', 'leave_crouch', 'turn', 'roll','skid']",
	
	set_facing: "def(int direction) -> commands
		if(self.facing != direction and (not (self.animation in ['interact', 'slide'])), [
			facing(direction),
			if(self.is_standing, animation('turn')),
		])",
	
	resume_standing_or_walking: "if(ctrl_left or ctrl_right, [if(ctrl_left, start_moving(-1)), if(ctrl_right, start_moving(1))], start_standing)",
		
	start_standing: "commands :: 
		if(abs(self.velocity_x) > 240 and (not self.animation in ['walk']), animation('skid'),
			if(abs(self.slope_standing_on) < 20, if(not self.animation in ['stand'], animation('stand')),
				if(self.slope_standing_on*self.facing > 0,
					animation('stand_down_slope'),
					animation('stand_up_slope')
				)
			)
		)",
	
	//sets rotation based on frogatto's relative velocity.  This tries to make frogatto tilt forward/backward if he's jumping with a lot of velocity behind him.  Has a factor which tries to dampen it markedly if the x_velocity is low, so if frogatto's jumping straight up and down, he doesn't wobble back and forth wildly.
	set_aerial_rotation: "def(decimal coefficient) -> commands set(rotate,coefficient*magnitude*angle/4.0) where angle = atan(decimal(velocity_y)/(velocity_x)) where magnitude = min(1.0,decimal(abs(velocity_x)*1.5)/sqrt(velocity_x^2 + velocity_y^2))",
	
	should_roll: "bool :: (cycle - tmp.last_landed_hard < 24)",
	should_continue_roll: "def(int dir) -> bool (animation = 'roll') and ((cycle - tmp.last_landed_hard < 12) or ((dir = 1 and ctrl_right) or (dir = -1 and ctrl_left)))",	
	
	start_moving:	//only for tracking movement keypresses, NOT for any actual gameplay logic
									"def(int dir) -> commands [set_facing(dir), 
										if(last_pressed(dir) and last_pressed(dir) > cycle - 15 or _running = 1, [
											process_movement_internal(-1, 'run'),
											set(_running, 1),
										]),
										
										if(dir = 1, [set(tmp.ctrl_right, cycle),set(tmp.ctrl_left, null)]),
										if(dir = -1, [set(tmp.ctrl_left, cycle),set(tmp.ctrl_right, null)])
	
									] where last_pressed = def(dir) if(dir = 1, tmp.ctrl_right, tmp.ctrl_left)",
	
	process_movement: "def(int direction) -> commands [if(should_roll, process_movement_internal(direction, 'roll'),
											if(_running, process_movement_internal(direction, 'run'), process_movement_internal(direction, 'walk')))]",

	process_movement_internal: //gameplay logic and animation logic for movement
	"def(int dir, string anim) -> commands
			if(self.is_standing, [
				switch(anim,  //things that should happen every frame
					'walk', 	set(accel_x, walk_accel),
					'run', [set(accel_x, run_accel), if(animation = 'walk', set(animation, 'run'))],
					'roll', set(accel_x, roll_accel) ),
				 if((not should_roll) and (animation = 'roll'), animation(anim)),
	
				//things that should only happen when the move begins
				if((not self.animation in ['walk', 'run', 'roll', 'start_jump', 'jump', 'fall'] + uninterruptible_animations ), [
					animation(anim),
                    if(anim = 'roll', if((cycle - tmp.last_landed_hard < 2), sound('frogatto-fall-roll.wav', 0.5))),
					if(anim = 'run', sound('runSoft.wav')),
				])
			],
			
			//Frogatto is in the air, so make him glide.
			if(not self.is_standing or self.animation in ['slide', 'swim_up', 'swim_down', 'swim_side'],
				add(self.velocity_x, jump_glide*dir))
		)",
	
	stop_moving: "commands :: if(not should_continue_roll(facing), [set(_running, 0), if((not (ctrl_left or ctrl_right)) and animation in ['walk', 'run', 'roll'], start_standing)])",
	
	//Function to attempt to make Frogatto crouch; does checking to make
	//sure he's in a state that allows entering a crouch.
	crouch: "def() -> commands
		if((not self.animation in uninterruptible_animations ) and self.is_standing, 
			animation('enter_crouch'))",
	  		
	//Function to enter swimming frames.
	swim: "def(decimal dirx, decimal diry) -> commands
		if(dirx or diry, [
			if(self.animation != anim_wanted, animation(anim_wanted)),
			add(self.velocity_x, (swim_accel*dirx)/1000),
			add(self.velocity_y, (swim_accel*diry)/1000),
		]) where anim_wanted = if(abs(diry) > 500, if(diry < 0, 'swim_up', 'swim_down'), 'swim_side'),
		         swim_accel = 140",
		
	//function to decide if frogatto can slide down a wall
	can_slide: "bool <- boolean(
		(not FAT)
		and solid(self.level, if(self.facing > 0, self.solid_rect.x2+1, self.solid_rect.x-1), (self.solid_rect.y + self.solid_rect.y2*2)/3)
		and (self.velocity_y < 300 and self.velocity_y > -1000 or self.ctrl_jump and self.tmp.pressed_jump_in_air) )",


#-------------------------- constants --------------------------#
		
	light_radius: "60",
	jump_power: "1200",
	jump_boost: "90",
	jump_glide: "if(not consts.FAT, 30, 20)", //20: But keep this where it is.
	walk_accel: "1600",
	roll_accel:  "2200",
	run_accel:  "2800",
	
	tongue_length: "int <- 14 + number_of_item('tongue_extension')*6",
	spit_power: "80",
	posthit_invicibility_period: "100",
	
	jump_out_of_water_boost: "1400",
	jump_out_of_water_boost_horizontal: "200",
	
#-------------------------- vars --------------------------#
	
		#-- money --#
	coins: { type: "int", default: 0 },
	coins_total_obtained: { type: "int", default: 0 },
	last_got_gold: null,
	gold_counter: null,
	
		#-- items and achievements --#
	enemies_tasted: { type: "{string -> bool}|null", default: null }, //A running tally of how many of what kind of enemy we have tasted. Used for the Frogourmet achivement.
	items_carried: { type: "{string -> int}", default: {"tongue" : 1} }, //Used to keep track of what items we have. Access via has_item, add_item, etc.

	num_partial_hearts: { type: "int", default: 0 }, //Used by partial_max_heart_object.cfg
	name: "Frogatto",  //intended for use in dialogues; if we need to do string substitution at some point when we have multiple characters
	
	current_ability: { type: "int", default: 0 },
	ability_list: { type: "[string]", default: ["tongue"] },
	
	swallowed_object: { type: "custom_obj|null", default: null},
	achievement_kill_chain: [[null,-1000],[null,-2000],[null,-3000],[null,-4000],[null,-4000],[null,-5000],[null,-6000],[null,-7000],[null,-8000],[null,-9000],[null,-10000],[null,-11000],[null,-12000],[null,-13000],[null,-14000],[null,-15000]],
	
	bounced_on_chain: null,
	jump_cheat: null,
	time_last_hit: null,

	starting_systemclock_of_entire_playthrough: { type: "int|null", default: null },

#-------------------------- temporary vars --------------------------#
	last_landed_hard: { type: "int", default: -30 },
	_running: { type: "bool", default: false },
	_tongue_tip: { type: "custom_obj|null", default: null },

	//indicates whether the last press of jump was while in the air.
	pressed_jump_in_air: { type: "int|null", default: null },

	started_using_ability_at_cycle: { type: "int|null", default: null },
	ctrl_attack_counter: { type: "int|null", default: null },
	ctrl_tongue_counter: { type: "int|null", default: null },
	last_played_fire_sfx: { type: "int|null", default: null },
	interacting_with:  { type: "int|null", default: null },
	idleness_counter: { type: "int|null", default: null },
	idleness_level: { type: "int|null", default: null },
	fired_talk: { type: "int|null", default: null },
	lookdown_time: { type: "int|null", default: null },

	in_solidity_fail: { type: "int|null", default: null },

},

consts: {
	FAT: 0,
},
	  
	  
on_hax: "hax_",

on_display_gold: "[
	if( cycle - vars.last_got_gold > 20 and vars.gold_counter > 0, [
		spawn('text_flash',midpoint_x,midpoint_y-20,1,[
			set_var('txt','+'+vars.gold_counter)]), 
		set(vars.gold_counter,0)
	], 
		schedule(10,fire_event('display_gold'))
	),
]",

//give frogatto brief invincibility when we load
on_load: "[
	if(not lights, set(lights, circle_light(me, light_radius))),
	set(invincible, 50),
	set(brightness, 255),
	set(tmp.started_using_ability_at_cycle, fold(map(mana_cooldown_time, {(key): -value}), a+b)),
]",

on_create: "[
	set(lights, circle_light(me, light_radius)), 
	animation('stand'),
]",

on_enter_level: "[
	if(not level.id in vars.levels_visited, add(vars.levels_visited, [level.id])),
	animation('stand')
]",

on_load_checkpoint: "[
	if((not lights), set(lights, circle_light(me, light_radius))),
	set(hitpoints, (max_hitpoints*4-difficulty)/4),
	set(level.player.vars.score, (level.player.vars.score*9)/10),

	//Make it so that if we had a swallowed object we create a fresh version of the object in our stomach.
	if(swallowed_object, [
		set(obj.variations, swallowed_object.variations),
		set(swallowed_object, obj),
		set(obj.vars.removed_from_play, 1),
		fire_event(obj, 'swallowed')
		] where obj = object(swallowed_object.type, midpoint_x, midpoint_y, facing)
	),
	
	fire_event('lose_powerup'),
	set(tmp.started_using_ability_at_cycle, fold(map(mana_cooldown_time, {(key): -value}), a+b)),

	animation('stand'),
	set(velocity_x, 0),
	set(velocity_y, 0),
	move_to_standing(),
	set(brightness, 255),

	schedule(2, fire_event('check_water'))
]",

on_enter_jump_anim: "choose_sfx('jump')",

on_enter_slide_anim: "[
	set(rotate, 0),
	if(IPHONE_SYSTEM, set(underwater_controls, 0)),
	set(tmp.pressed_jump_in_air, true),
	set(velocity_y, 0),
]",
	  
on_leave_interact_anim: "fire_event(interacting_with, 'cancel_interaction')",

on_leave_jump_attack_anim: "[
	fire_event('leave_attack_anim'),
	set(attached_objects, []),
]",

on_leave_slide_anim: "[
	if(ctrl_left, facing(-1)),
	if(ctrl_right, facing(1)),
]",

on_enter_walk_anim: "[
	set(vars.bounced_on_chain,0),
]",

on_enter_run_anim: "[
	set(vars.bounced_on_chain,0),
]",

on_die: "[
	remove_object(_tongue_tip),
	spawn('die_cloud', midpoint_x, midpoint_y, facing),
]",

on_ctrl_jump: "[
	proto_event('playable', 'ctrl_jump'),
	set(tmp.pressed_jump_on_cycle, cycle),
	if(animation = 'slide', [
		set(tmp.pressed_jump_in_air, false),
		facing(-facing), 
		animation('start_jump'), 
		set(velocity_x, -facing*800), 
		set(velocity_y, -1000),
	], set(tmp.pressed_jump_in_air, (not can_jump()))),
]",

on_ctrl_left: "start_moving(-1)",

on_ctrl_right: "start_moving(1)",

on_end_ctrl_left: "stop_moving",

on_end_ctrl_right: "stop_moving",

on_ctrl_down: "if(animation = 'slide', animation('fall'))",

on_ctrl_attack: "set(current_ability, (current_ability+1) % ability_list.size)",
		
on_end_ctrl_up: "if((animation in ['enter_lookup', 'lookup']), start_standing)",

timer_frequency: 2,
on_timer: "[ //TODO: Can we put this in the ctrl event code?
	if(ctrl_right - ctrl_left != 0 and ctrl_right - ctrl_left != facing, set_facing(-facing)),
	if(ctrl_up and animation in ['stand','stand_up_slope','stand_down_slope'], animation('enter_lookup')),
	proto_event('playable', 'timer')]",
	   
on_start_level: "[
	zombie_object_cleanup(),
	fire_event('check_water'),
	spawn('shadow_small',mid_x,mid_y,1,set(child.parent, me)),
]",


on_process: "[
	/*[	set(tmp.old_tile_types, tile_types), //This prints the tile code we're standing on.
		if(old_tile_types != tile_types, debug(tile_types)),
	] where tile_types = tags_on(),*/
	
	//If we're standing on a springy object, force a collide_feet
	//event to make us bounce off it.
	if(velocity_y = 0 and standing_on and standing_on.springiness > 0,
			 fire_event('collide_feet', {collide_with: standing_on})),
			 
	if((not is_standing) and should_be_standing,
		[animation('fall'),
		 set(_started_falling_cycle, cycle)]),

	if(ctrl_jump and (not ctrl_down) and (not tmp.pressed_jump_in_air) and (cycle - tmp.pressed_jump_on_cycle < 12 or jump_cheat),
		add(velocity_y, -jump_boost)),
		
	if((not FAT) and underwater and (not _tongue_tip),
		if(IPHONE_SYSTEM, [
			swim(ctrl_x, ctrl_y),
			if((not ctrl_x) and (not ctrl_y), float()),
			if(ctrl_x < 0 and facing > 0 or ctrl_x > 0 and facing < 0, set(facing, -facing)),
		],[
			swim(
				(ctrl_right - ctrl_left)*if(ctrl_down or ctrl_up, 700, 1000), 
				(ctrl_down - ctrl_up)*if(ctrl_left or ctrl_right, 700, 1000) ),
			if((not ctrl_left or ctrl_right or ctrl_up or ctrl_down) and animation in ['swim_side','swim_up','swim_down'],
				float()),
		])
	),

	[if(ctrl_left, process_movement(-1)), if(ctrl_right, process_movement(1))],
	if(should_continue_roll(facing), process_movement(facing), if(animation = 'roll' and (not (ctrl_left or ctrl_right)), stop_moving)),
	if(ctrl_down and (not (ctrl_left or ctrl_right)), crouch()),
	
	if(ctrl_tongue, add(ctrl_tongue_counter,1), set(ctrl_tongue_counter, 0)),
	if(ctrl_attack, add(ctrl_attack_counter,1), set(ctrl_attack_counter, 0)),

	if(not mana_shock_active, add(mana, mana_regen_per_frame)),
	use_mana_cooldowns(),
	
	track_key('i'),
	if(ctrl_keyboard('i') = 1, suspend_level('inventory-screen.cfg') ),
	
	if(ctrl_tongue, attack())
]",

on_process_start_jump: "[set_aerial_rotation(-2)]",
	
on_process_jump: "[if(velocity_y > 0, animation('fall')),set_aerial_rotation(-1)]",
	
on_process_fall: "[
	if(IPHONE_SYSTEM,
		if(underwater_controls, [
			add(velocity_x, (jump_glide*ctrl_x)/1000),
			add(velocity_y, (jump_glide*ctrl_y)/1000), 
		])
	),
	set_aerial_rotation(-1),
	proto_event('playable', 'process_fall')]",

on_leave_fall_anim: "set(rotate,0)",
	
on_process_lookup: "[
	add(tmp.lookup_time, 1),
	if(tmp.lookup_time = 50, set(vertical_look, -200)),
]",

on_process_crouch: "[
	add(tmp.lookdown_time, 1), 
	if(tmp.lookdown_time = 50, set(vertical_look, 200)),
]",

on_leave_lookup_anim: "[
	set(tmp.lookup_time, 0), 
	set(vertical_look, 0),
]",

on_leave_crouch_anim: "[
	set(tmp.lookdown_time, 0), 
	set(vertical_look, 0),
]",


on_process_slide: "if(not can_slide, animation('fall'))",

on_check_water: "[
	if(underwater and (not FAT), float()),
]",

on_enter_water: "[
	sound('water-enter.ogg'),
	set(tmp.bubbles_die_here, me.midpoint_y),
	
	//TODO: Do we want underwater controls so soon?
	if(IPHONE_SYSTEM, set(underwater_controls, 1)),
	if(not FAT or _tongue_tip, float()), //Calling float removes feet, too.
	
	//splash if we are entering the water with reasonable velocity
	if(velocity_y > 200, [
		spawn('water_splash', midpoint_x, water_bounds[1]+10, if(1d2=2,facing,-facing)),
		spawn('water_particles', midpoint_x, water_bounds[1]+10, facing),
	]),
]",

on_exit_water: "[
	set(has_feet, true),
	animation('fall'),
	sound('water-exit.ogg'),
	schedule(60, fire_event('check_water')),
	
	if(velocity_y < -200, [
		spawn('water_splash', midpoint_x, previous_water_bounds[1]+10, choose([facing,-facing])),
		spawn('water_particles', midpoint_x, previous_water_bounds[1]+10, facing),
	]),
	
	if(velocity_y < 0, add(velocity_y, -jump_out_of_water_boost)),
	set(velocity_x, (velocity_x*jump_out_of_water_boost_horizontal)/100),
]",


on_collide_feet: "[
	if(IPHONE_SYSTEM and (not underwater), set(underwater_controls, 0)),

	schedule(8,fullfill_todo_upon_landing),

	if(collide_with and collide_with.springiness > 0, [
		bounce_on(me, collide_with),
	],[	
		set(velocity_x, velocity_x/2),
		if(has_feet and animation not in uninterruptible_animations,
			[if(velocity_y > 1300, [animation('land'),sound('bumphead-light.wav',0.5)], start_standing),
			if(velocity_y>900,choose_sfx('jump'),choose_sfx('footfall')),
			
			if((hypot(velocity_x,velocity_y) > 1500) and (abs(velocity_x) > 700), set(tmp.last_landed_hard, cycle))
			],
		),
	]),
]",

on_collide_head: "[
	if(animation in ['start_jump', 'jump'], animation('bumphead')), 
	if(velocity_y < 0, set(velocity_y, 0)),
	set(tmp.pressed_jump_in_air, true),
]",

on_collide_side: "[
	set(velocity_x, 0),
	if(animation in ['start_jump', 'jump', 'fall']
			and can_slide
			and (abs(velocity_x) > 200 or ctrl_jump and tmp.pressed_jump_in_air), [
		animation('slide'),
		set(velocity_y, 0),
		sound('wall-catch'+1d5+'.wav'),
	]),
]",
	   
on_collide_object_body: "
	if(collide_with_area in ['attack','thrown'] and ((not collide_with.spat_out_at)
			or collide_with.spat_out_at < level.cycle - 20) and collide_with.team != team and collide_with.team != 'evil_harmless',
		if(not is_invincible, get_hit_by(collide_with)),
		if(collide_with_area = 'interact', set(can_interact, 2)) ) //If it wasn't the attack area that hit our body, respond to other areas. See if we're colliding with another object's interact area, in which case we set it so we can interact with them.
",

//if we couldn't return an object to play when spitting it, revert to having it inside us.
on_add_object_fail: "if(object and swallowed_object = null, [
	set(object.vars.removed_from_play, 1),
	set(swallowed_object, object),
	add(gravity_shift, object.vars.swallow_gravity),
	add(variations, ['fat']),
])",

//If we change our solid dimensions -- i.e. try to come back from being hurt, and we can't because we're on top of another solid object, then we take more damage.
on_change_solid_dimensions_fail: "[
	proto_event('playable', 'change_solid_dimensions_fail'),
	if(not is_invincible_posthit, if(FAT, shoot_spit_attack(), animation('hurt')) ),
]",


on_end_enter_crouch_anim: "animation('crouch')",

on_end_crouch_anim: "if(ctrl_down, animation('crouch'), animation('leave_crouch'))",

on_end_leave_crouch_anim: "start_standing",

on_enter_skid_anim: "if(abs(velocity_x) > 300 and (not underwater), [
	spawn_on_ref('dust_cloud_skid', midpoint_x + 36*facing, y2 - 10, facing),
	choose_sfx('slide'),
])",

on_enter_land_anim: "if(not underwater, [
	spawn_on_ref('dust_cloud_skid', midpoint_x + 20*facing, y2 - 8,  facing), 
	spawn_on_ref('dust_cloud_skid', midpoint_x - 20*facing, y2 - 8, -facing),
])",


on_end_turn_anim: "start_standing",
on_end_start_jump_anim: "animation('jump')",
on_end_jump_anim: "animation('jump')",
on_end_fall_anim: "animation('fall')",
on_end_bumphead_anim: "animation('fall')",
on_end_land_anim: "start_standing",
on_end_roll_anim: "animation('roll')",
on_end_walk_anim: "animation('walk')",

on_end_run_anim: "animation('run')",
on_process_run: "if(abs(velocity_x) > 300 and cycle%5=0 and (not underwater),
	spawn_on_ref('dust_cloud_run', midpoint_x - 30*facing, y2-10, -facing))",

//note:  using level.zoom to detect if in a cutscene or dialogue, in which case we don't do idle anims.
//TODO:  this fails to account for the epilogue.  Figure out some way to do this without setting a special tracker variable, since those are bug-prone.
on_end_stand_anim: "if((not FAT) and tmp.idleness_counter > 8 and level.zoom = 1, 
	[fire_event('idling'), set(tmp.idleness_counter, 0)],
	[animation('stand'), add(tmp.idleness_counter, 1)],
)",
	
on_leave_stand_anim: "[set(tmp.idleness_counter, 0), set(tmp.idleness_level, 0)]",
on_end_skid_anim: "start_standing",
on_end_stand_up_slope_anim: "start_standing",
on_end_stand_down_slope_anim: "start_standing",

on_idling: "if(tmp.idleness_level < 6, [
	animation('stand'),
	add(tmp.idleness_level, 1),
],[
	if(1d4!=4, animation('idle_croak'), animation('idle_eyeball')),
	set(tmp.idleness_level, 0),
])",
					
on_end_idle_eyeball_anim: "start_standing",
on_end_idle_croak_anim: "start_standing",

on_footfall: "choose_sfx('footfall')",

on_process_spit: "maintain_locomotion()",
on_end_spit_anim: "if(underwater, float(), start_standing)",


on_child_spawned: "if(child.type = '${self.type}.tongue_tip', [
	set(_tongue_tip, child), 
	set(child.tmp.frog, me),
])",
					  

on_process_attack: "if(facing = 1 and ctrl_right or facing = -1 and ctrl_left, [
	set(animation, 'walk_attack'),
	set(time_in_animation, time_in_animation), //This carries the time in animation over to walk_attack. First we set the animation, which sets time_in_animation to 0, then we run the set() command, which sets time in animation to whatever the old time_in_animation was, when we evaluated the command. It is, contrary to appearances, not just a tautological operation.
	set(accel_x, walk_accel),
])",
on_process_walk_attack: "if(facing = 1 and (not ctrl_right) or facing = -1 and (not ctrl_left), [
	set(animation, 'attack'), 
	set(time_in_animation, time_in_animation), //See comment in on_process_attack.
])",
on_end_walk_attack_anim: "animation('walk')",

on_end_energyshot_anim:            "start_standing",
on_end_energyshot_jump_anim:       "start_standing",
on_end_energyshot_up_slope_anim:   "start_standing",
on_end_energyshot_down_slope_anim: "start_standing",

on_end_floating_spin_anim: "animation('floating_spin')",
on_end_floating_spin_fast_anim: "animation('floating_spin_fast')",
on_end_floating_spin_faster_anim: "animation('floating_spin_faster')",

on_end_attack_anim: "[
	if(('fat' in variations), animation('swallow')),
	start_standing,
]",
on_leave_attack_anim: "[
	if(_tongue_tip, fire_event('remove_tongue')), 
	set(attached_objects, []),
]",

on_end_swallow_anim: "start_standing",
on_end_enter_lookup_anim: "animation('lookup')",
on_end_lookup_anim: "animation('lookup')",
on_end_jump_attack_anim: "animation('fall')",
on_end_firebreath_begin_anim: "animation('firebreath_cycle')",
on_end_firebreath_cycle_anim: "if(shoot_fire_active,animation('firebreath_cycle'), animation('firebreath_end'))",
on_end_firebreath_end_anim: "start_standing",
on_end_acidbreath_begin_anim: "animation('acidbreath_cycle')",
on_end_acidbreath_cycle_anim: "animation('acidbreath_end')",
on_end_acidbreath_end_anim: "start_standing",
on_end_swim_side_idle_anim: "float()",
on_end_swim_side_anim: "if(underwater, animation('swim_side'), start_standing)",
on_end_swim_up_anim:   "if(underwater, animation('swim_up'),   start_standing)",
on_end_swim_down_anim: "if(underwater, animation('swim_down'), start_standing)",
on_end_item_get_begin_anim: "animation('item_get_hold')",
on_end_item_get_hold_anim: "animation('item_get_hold')",
on_end_item_get_end_anim: "animation('stand')",
on_end_hurt_anim: "animation(if((not FAT) and underwater, 'swim_side_idle', 'stand'))",

on_end_emote_geez_anim: "animation('stand')",
on_end_emote_oh_anim: "animation('stand')",
on_end_emote_impatient_anim: "animation('stand')",
on_end_emote_raisedfinger_anim: "animation('stand')",
on_end_emote_confused_anim: "animation('stand')",
on_end_emote_talk_anim: "animation('stand')",
on_end_emote_nod_anim: "animation('stand')",
on_end_emote_angry_anim: "animation('stand')",
on_end_emote_victory_anim: "animation('emote_victory2')",
on_end_emote_victory2_anim: "animation('stand')",

animation: [
	{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "stand",
		duplicates: 6,
		rect: [2,2,33,34],
		frames: 3,
		duration: 6,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "stand",
		//blink variant
		rect: [107,2,138,34],
		frames: 3,
		duration: 6,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "stand_up_slope",
		x: 212,
		y: 2,
		w: 32,
		h: 35,
		solid_area: [9,9,23,31],
		frames: 3,
		duration: 6,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "stand_down_slope",
		x: 317,
		y: 2,
		w: 32,
		h: 35,
		solid_area: [9,9,23,31],
		frames: 3,
		duration: 6,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "lookup",
		rect: [37,233,68,265],
		frames: 1,
		duration: 3,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "enter_lookup",
		rect: [2,233,33,265],
		frames: 1,
		duration: 3,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "crouch",
		solid_area: [9,17,23,30],
		rect: [107,197,138,229],
		frames: 1,
		duration: 1,
		rotate_on_slope: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "enter_crouch",
		solid_area: [9,17,23,30],
		rect: [2,197,33,229],
		frames: 3,
		duration: 3,
		rotate_on_slope: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "leave_crouch",
		rect: [2,197,33,229],
		frames: 3,
		duration: 3,
		play_backwards: true,
		rotate_on_slope: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "walk",
		solid_area: [17,18,31,40],
		rect: [2,110,49,157],
		frames: 8,
		duration: 5,
		events: "10:30:footfall",
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "run",
		solid_area: [17,18,31,40],
		x: 410,
		y: 95,
		w: 48,
		h: 48,
		frames: 4,
		frames_per_row: 2,
		duration: 5,
		events: "0:10:footfall",
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "skid",
		solid_area: [17,18,31,40],
		x: 461,
		y: 40,
		w: 48,
		h: 48,
		frames: 1,
		duration: 10,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "turn",
		x: 387,
		y: 40,
		w: 32,
		h: 33,
		frames: 1,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet7.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "start_jump",
		solid_area: [9,13,23,35],
		x: 1,
		y: 103,
		w: 32,
		h: 48,
		frames: 5,
		duration: 3,
	},{
		image: "characters/frogatto-spritesheet7.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "jump",
		solid_area: [9,13,23,35],
		x: 1,
		y: 1,
		w: 32,
		h: 48,
		frames: 5,
		reverse: true,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "bumphead",
		sound: "bumphead.wav",
		solid_area: [9,12,23,34],
		rect: [422,2,453,36],
		duration: 5,
		frames: 1,
	},{
		image: "characters/frogatto-spritesheet7.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "fall",
		solid_area: [9,13,23,35],
		x: 1,
		y: 52,
		w: 32,
		h: 48,
		duration: 2,
		frames: 12,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "land",
		solid_area: [9,17,23,39],
		x: 142,
		y: 38,
		w: 32,
		h: 48,
		duration: 4,
		frames: 2,
	},{
		image: "characters/frogatto-spritesheet7.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "roll",
		x: 1,
		y: 154,
		w: 32,
		h: 33,
		duration: 3,
		frames: 8,
	},{
		image: "characters/fat-frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swallow",
		x: 2,
		y: 269,
		w: 49,
		h: 38,
		duration: 6,
		frames: 6,
		solid_area: [6,13,20,35],
	},{
		image: "characters/fat-frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "spit",
		x: 314,
		y: 269,
		w: 34,
		h: 35,
		duration: 3,
		frames: 3,
		solid_area: [6,8,20,30],
	},{
		image: "characters/frogatto-spritesheet5.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		feet_width: 5,
		id: "attack",
		sound: "tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav",
		rect: [2,151,33,188],
		solid_area: [9,12,23,34],
		body_area: [16,11,30,36],
		frames: 8,
		duration: 2,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet5.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		feet_width: 5,
		id: "walk_attack",
		rect: [2,233,33,270],
		solid_area: [9,12,23,34],
		body_area: [16,11,30,36],
		frames: 4,
		duration: 4,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet5.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		feet_width: 5,
		id: "jump_attack",
		sound: "tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav",
		rect: [2,192,50,229],
		body_area: [6,11,24,36],
		solid_area: [16,10,30,32],
		frames: 8,
		duration: 2,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "firebreath_begin",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "firebreath_cycle",
		rect: [360,476,393,510],
		frames: 2,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "firebreath_end",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "acidbreath_begin",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "acidbreath_cycle",
		rect: [360,476,393,510],
		frames: 2,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "acidbreath_end",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "hurt",
		rect: [271,351,303,383],
		frames: 1,
		duration: 18,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "interact",
		collide_x: 10,
		collide_y: 6,
		collide_w: 15,
		collide_h: 16,
		feet_x: 16,
		feet_y: 32,
		x: 72,
		y: 161,
		w: 32,
		h: 33,
		frames: 4,
		duration: 4,
		scale: 2,
		reverse: true,
		events: "15:interacting",
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "slide",
		x: 352,
		y: 40,
		w: 32,
		h: 34,
		duration: 30,
		frames: 1,
		solid_area: [14,8,28,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_side_idle",
		x: 3,
		y: 85,
		w: 39,
		h: 36,
		frames: 6,
		frames_per_row: 3,
		duration: 6,
		reverse: true,
		//(lost comment, location guessed) solid area not set as it would cause collision problems with the level
		//solid_area: [8,13,30,27]
	},{ //TODO: These aren't used, but should they be?
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_down_idle",
		x: 129,
		y: 85,
		w: 39,
		h: 36,
		frames: 6,
		frames_per_row: 3,
		duration: 6,
		reverse: true,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_up_idle",
		x: 255,
		y: 85,
		w: 39,
		h: 36,
		frames: 6,
		frames_per_row: 3,
		duration: 6,
		reverse: true,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_side",
		sound: "Paddle1.ogg,Paddle2.ogg,Paddle3.ogg,Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg",
		x: 3,
		y: 163,
		w: 39,
		h: 36,
		frames: 3,
		duration: 10,
		//(lost comment, location guessed) solid area not set as it would cause collision problems with the level
		//solid_area: [8,13,30,27]
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_down",
		sound: "Paddle1.ogg,Paddle2.ogg,Paddle3.ogg,Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg",
		x: 129,
		y: 163,
		w: 39,
		h: 36,
		frames: 3,
		duration: 10,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "swim_up",
		sound: "Paddle1.ogg,Paddle2.ogg,Paddle3.ogg,Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg",
		x: 255,
		y: 163,
		w: 39,
		h: 36,
		frames: 3,
		duration: 10,
		solid_area: [12,8,26,30],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "energyshot_jump",
		rect: [1,415,41,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [12,14,26,36],
	},{ //TODO: Energyshot animations are broken anyway. And should follow the slope they're on?
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "energyshot_down_slope",
		rect: [45,415,85,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,15,28,37],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "energyshot_up_slope",
		rect: [89,415,129,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,15,28,37],
	},{
		image: "characters/frogatto-spritesheet2.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "energyshot",
		rect: [133,415,173,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,14,28,36],
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_begin",
		rect: [1,335,32,367],
		frames: 4,
		duration: 10,
	},
	{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_hold",
		rect: [106,335,137,367],
		frames: 1,
		duration: 30,
	},
	{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_end",
		rect: [1,335,32,367],
		frames: 4,
		duration: 10,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_geez",
		rect: [1,1,36,38],
		solid_area: [11,13,25,35],
		frames: 8,
		reverse: true,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet4.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_oh",
		rect: [1,1,36,38],
		solid_area: [11,13,25,35],
		frames: 15,
		frames_per_row: 5,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_confused",
		rect: [1,52,36,89],
		solid_area: [11,13,25,35],
		frames: 14,
		frames_per_row: 7,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_impatient",
		rect: [323,1,358,38],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 4,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_raisedfinger",
		rect: [1,144,36,181],
		solid_area: [11,13,25,35],
		frames: 14,
		frames_per_row: 7,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_talk",
		rect: [1,236,36,273],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 8,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_nod",
		rect: [323,175,358,212],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 4,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet4.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_angry",
		rect: [1,127,36,164],
		solid_area: [11,13,25,35],
		frames: 20,
		frames_per_row: 5,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet-idle.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "idle_eyeball",
		rect: [1,1,32,33],
		frames: 43,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet-idle.png",
		accel_x: 0,
		accel_y: 0,
		pad: 7,
		body_area: "all",
		feet_width: 5,
		id: "idle_croak",
		rect: [3,37,34,69],
		frames: 25,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "floating_spin",
		rect: [3,436,34,477],
		frames: 8,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "floating_spin_fast",
		rect: [3,436,34,477],
		frames: 8,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "floating_spin_faster",
		rect: [3,436,34,477],
		frames: 8,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet6.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_victory",
		rect: [1,1,33,33],
		solid_area: [10,6,24,28],
		frames: 18,
		frames_per_row: 9,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet6.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "emote_victory2",
		rect: [73,73,105,105],
		solid_area: [10,6,24,28],
		frames: 7,
		duration: 4,
	},],


variations: {
	fat: "[
		map(filter(doc.animation, value.image in images_to_convert), 'anim',
		set(anim.image, regex_replace(anim.image, 'frogatto', 'fat-frogatto'))) where
		images_to_convert = ['characters/frogatto-spritesheet1.png',
							 'characters/frogatto-spritesheet3.png',
							 'characters/frogatto-spritesheet4.png'],
		set(doc.consts, 'FAT', 1),
		map(filter(doc.animation, value.id = 'walk'), 'anim', set(doc.anim.accel_x, 1300)),
		map(filter(doc.animation, value.id = 'run'), 'anim', set(doc.anim.accel_x, 1900)),
	]",
},


object_variation: [
	{
		id: "fat",
		set_str: [
			{
				_target: "filter(elements.animation, image = 'characters/frogatto-spritesheet1.png')",
				image: "characters/fat-frogatto-spritesheet1.png",
			},{
				_target: "filter(elements.animation, image = 'characters/frogatto-spritesheet3.png')",
				image: "characters/fat-frogatto-spritesheet3.png",
			},{
				_target: "filter(elements.animation, image = 'characters/frogatto-spritesheet4.png')",
				image: "characters/fat-frogatto-spritesheet4.png",
			},{
				_target: "elements.consts", //So the constant is variable.
				FAT: 1,
			},{
				_target: "filter(elements.animation, id = 'walk')",
				accel_x: 1300,
			},{
				_target: "filter(elements.animation, id = 'run')",
				accel_x: 1900,
			},{
				_target: "self",
			},
		],
	},
],

object_type: [
	#-------------------------- TONGUE/HEAD --------------------------#
	{
		id: "tongue_shaft",
		always_active: true,
		serializable: false,
		zsub_order: 5,
		solid_dimensions: [],
		is_strict: true,
		
		properties: {
			_x_1: { type: "decimal", init: "mid_x" },
			_x_2: { type: "decimal", init: "mid_x+1" },
			_y_1: { type: "decimal", init: "mid_y" },
			_y_2: { type: "decimal", init: "mid_y+1" },

			is_player_body_part: "1",
			length: "decimal :: lib.math.length(_x_1,_y_1,_x_2,_y_2)",
			set_ends: "def(decimal new_x1, decimal new_y1, decimal new_x2, decimal new_y2) -> commands [set(_x_1,new_x1), set(_y_1,new_y1), set(_x_2,new_x2), set(_y_2,new_y2), fire_event(me,'create')]",
		},
		
		on_create: "[
				set(mid_x, int((_x_2+_x_1)/2)),
				set(y, int((_y_2+_y_1)/2 - (length/2))),
				set(draw_area, [0, 0, img_w/2, length/2]),
				set(rotate,(angle(_x_1,_y_1,_x_2,_y_2)-90) )
			]",
			
		animation: {
			id: "default",
			image: "characters/frogatto-tongueB.png",
			rect: [0,0,7,7],
			frames: 1,
			no_remove_alpha_borders: true,
		},
	},
	
	
	{
		id: "frogatto_head",
		serializable: false,
		
		properties: {
			is_player_body_part: 1,
			_tongue_angle: {type: "int", default: 0},
		},
		
		on_create: "switch(_tongue_angle,
						-90,	animation('up'),
						-45,	animation('updiag'),
						0,		animation('side'),
						45,		animation('downdiag'),
						90,		animation('down'))",
		
		animation: [
			{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "up",
				rect: [2,1,35,26],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "updiag",
				rect: [2,30,35,55],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "side",
				rect: [2,59,35,84],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "downdiag",
				rect: [2,88,35,113],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 2,
				no_remove_alpha_borders: true,
				id: "down",
				rect: [2,117,35,142],
			},
		],
	},
	
	
	{
		id: "tongue_tip",
		always_active: true,
		serializable: false,
		zsub_order: 6,
		solid_dimensions: ["player","common","boss","thrown"],
		
		properties: {
			is_player_body_part: "1",
			attack_damage: "0",
			team: "'player'",
			yhead_offset: "12",
			ybase_offset: "8",
			x_offset: "0*facing",
			tongue_duration: "16",
			damage_cooldown: "10",
			max_swallow_size: "16",
			min_swallow_size: "10",

			length_per_time: "def(time) _frog.tongue_length*(tongue_duration/2 - abs(tongue_duration/2 - time))",
			set_shaft: "def(time,angle) [	_shaft.set_ends(	_froghead.mid_x + x_offset,
																_froghead.mid_y + ybase_offset,
																_froghead.mid_x + (length_per_time(time)*cos(angle)) * facing + x_offset,
																_froghead.mid_y + ybase_offset + (length_per_time(time)*sin(angle))  )]",
			adjust_position: "def(time,angle)	[set(midpoint_x, _froghead.midpoint_x + (length_per_time(time)*cos(angle)) * facing  + x_offset + if(facing = 1, 2,0)), 
												set(midpoint_y, _froghead.midpoint_y + ybase_offset + (length_per_time(time)*sin(angle)) + if(facing = -1 and angle = 0, -1, 0) ),
												set(rotate, angle * facing)]",
			process_tongue: "def() [set_shaft(_timer, _tongue_angle),adjust_position(_timer,_tongue_angle),if(_timer >= tongue_duration,die()),fire_event('drag_victim'),if(_timer = tongue_duration/2, animation('flash')),add(_timer,1)]",
			
			#-------------------------- vars --------------------------#
			_timer: {type: "int", default: 1},
			_tongue_angle: {type: "int", default: 0},
			_swallowed: {type: "custom_obj|null", default: null},

			_frog: {type: "obj frogatto_playable", persistent: false},
			_froghead: {type: "obj frogatto_playable.frogatto_head", persistent: false, init: "object('frogatto_playable.frogatto_head', x, mid_y - 12, {facing: facing})" },  #TODO:  this can't be valid here, because it's not from the initialization_map by the time we get here 
			_shaft: {type: "obj frogatto_playable.tongue_shaft", persistent: false, init: "object('frogatto_playable.tongue_shaft',x,y, {facing: 1})" },
		},
		
		
		on_spawned: "set(parent, spawner)",
		on_create:  "[	set(_froghead.facing, facing),
						add_object(_froghead),
						add_object(_shaft),
						set(_froghead._tongue_angle,_tongue_angle),
						set(_froghead.parent,parent),
						set(_froghead.mid_x,parent.mid_x),
						set(_froghead.mid_y,parent.mid_y- 12),
						animation('initial')] asserting parent is obj frogatto_playable",
		
		
		
		on_draw: "process_tongue()",
		
		on_die: "[
			if(swallowed_object, [
				set(_frog.swallowed_object, swallowed_object),
				add(_frog.variations, ['fat']),
				fire_event(_frog,'end_attack_anim'),
			]),
			set(_shaft.hitpoints, 0), 
			//set(_shaft, null),
			set(_froghead.hitpoints, 0), 
			//set(_froghead, null), 
			set(_frog._tongue_tip, null), 
			if((not swallowed_object) and _frog.underwater, set(_frog.has_feet, false)),
		]",

		// If we snag something early, fast-forward us to where the tongue is at the same position, but retracting.
		on_stopearly: "[
			set(vars.timer, newtime), 
			set(_frog.time_in_animation,newtime),
		] where newtime = vars.timer + 2*abs(max((tongue_duration/2 - vars.timer), 0))",
		
		on_drag_victim: "[
			if(swallowed_object and (level.cycle - vars.cycle_grabbed > 1), [
				set(swallowed_object.midpoint_x, last_x),
				set(swallowed_object.midpoint_y, last_y),
			]),
			set(last_x, midpoint_x), set(last_y, midpoint_y),
		]",
						
		on_grab_objects: "if((not swallowed_object) and collide_with.hitpoints, [
			fire_event(collide_with, 'been_grabbed'),
			remove_object(collide_with),
			set(attached_objects, [collide_with]), set(vars.cycle_grabbed, level.cycle),
			set(collide_with.vars.removed_from_play, 1),
			sound('Gulp.wav'),
			set(swallowed_object, collide_with), fire_event(collide_with, 'swallowed'),
			add(level.player.gravity_shift, collide_with.vars.swallow_gravity),
		])",
		
		on_collide_object_grab: "
			if((collide_with_area = 'body' or collide_with_area = 'thrown') and (not swallowed_object) and collide_with != level.player, [
				fire_event('stopearly'),
				animation('flashsnag'),
				if(tag_ and if(level.player.enemies_tasted, (not tag_ in keys(level.player.enemies_tasted)), true), [
					add(level.player.enemies_tasted, {(tag_): true}),
					//adding 1 since the list won't have been updated yet, plus adding to casual the count of enemies exclusive to the 'challenging' difficulty level, which is only the wartfly, right now.
					if(size(level.player.enemies_tasted) + if(level.player.difficulty >= level.player.difficulty_challenging, 1, 2) >= 37, achievement('frogourmet'))
				]) where tag_ = collide_with.frogourmet_tag,
				if(is_swallowable,
					fire_event('grab_objects', {collide_with: collide_with}), //fire an event to grab the object. We do it in a separate event in case we try to swallow multiple objects at once.
					if(collide_with.get_hit_by, collide_with.get_hit_by(me)) //object is not swallowable, so do damage to it instead
				),
			]) where is_swallowable = collide_with.tags.swallowable and collide_with.physical_size <= max_swallow_size",
		
		on_end_initial_anim: "animation('normal')",
		on_end_flash_anim: "animation('normal')",
		on_end_clung_anim: "animation('clung')",
		on_end_flashsnag_anim: "animation('clung')",
		
		animation: [
			{
				id: "initial",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 4,
				rect: [307,351,339,383],

				//grab_area=solid:all
				grab_area: [8,8,25,20,"solid"],
			},{
				id: "normal",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 100,
				rect: [379,351,411,383],

				//grab_area=solid:all
				grab_area: [8,8,25,20,"solid"],
			},{
				id: "flashsnag",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 2,
				rect: [415,351,447,383],
			},{
				id: "flash",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 2,
				rect: [343,351,375,383],
			},{
				id: "clung",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 100,
				rect: [451,351,483,383],
			},
		],
	},


	#-------------------------- HEAD FOR ENERGYSHOT --------------------------#
	{
		id: "frogatto_head_energyshot",
		serializable: false,
		zsub_order: 12,
		
		properties: {
			is_player_body_part: 1,
		},
		
		on_spawned: "set(parent, spawner)",
		
		on_create: "[
			schedule(9,die()),
			switch(vars.head_angle,
				-90, animation('up'), 
				-45, animation('updiag'), 
				  0, animation('side'), 
				 45, animation('downdiag'), 
				 90, animation('down')
			),
		]",
		
		animation: [
			{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "up",
				rect: [178,415,218,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "updiag",
				rect: [222,415,262,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "side",
				rect: [266,415,306,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "downdiag",
				rect: [310,415,350,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "down",
				rect: [354,415,394,458],
			},
		],
	},
	
	
	#-------------------------- SHOTS --------------------------#
	{
		id: "bubble_shot",
		prototype: ["shot"],
		
		properties: {
			team: "'player'",
			dies_when_hit: false,
			attack_damage: 20,
			damage_cooldown: 10,
		},
		
		on_spawned: "set(vars.parent_obj, spawner)",
		on_exit_water: "set(velocity_y, 0)",
		on_end_normal_anim: "animation('pop')",
		on_end_pop_anim: "die()",
		
		//Shim for exit_water not firing if we don't have a solid_area.
		on_process: "if(mid_y < parent_obj.tmp.bubbles_die_here, fire_event('exit_water'))",
		
		on_enter_pop_anim: "[
			set(velocity_x,0),
			set(velocity_y,0),
			sound('bubble-pop'+1d5+'.wav'),
			
		]",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 3,
				duration: 8,
				rect: [62,2,71,11],
				attack_area: "all",
			},{
				image: "effects/particles2.png",
				pad: 3,
				id: "pop",
				frames: 2,
				duration: 4,
				rect: [101,2,110,11],
			},
		],
	},

	
	{
		id: "acid_shot",
		dies_on_inactive: true,
		prototype: ["shot"],
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: true,
		on_collide_level: "die()",
		
		on_die: "[proto_event('shot','die'), sound('droplet-burst1.wav'), sound('acid-shot-fizz.wav'), spawn('frogatto_playable.acid_shot_spawner',mid_x+1d20-10, mid_y -1d30, facing)]", 
		properties: {
			team: "'player'",
			dies_when_hit: true,
			attack_damage: 15,
			damage_cooldown: 20,
			damage_type: "'acid'",
		},
		
		on_spawned: "[
			set(accel_y, 40),
			set(vars.parent_obj, spawner),
			set(lights, circle_light(me, 150)),
			sound('acid-belch'+1d3+'.wav'),
		]",
		on_end_normal_anim: "animation('normal')",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 3,
				duration: 2,
				reverse: true,

				rect: [108,53,125,70],
				attack_area: "all",
			}
		],
	},
	{
		id: "acid_shot_spawner",
		prototype: ["standard_values"],
		object_level_collisions: false,
		
		properties: {
			max_spread: 128,
			floor_height: "def(int x, int y) -> int|null if(floor_h, floor_h[1], null) where floor_h = _find_floor_standable(x,y,level.player)",
			
			spread_scale: "(_spread/24.0)",
			floor_for_visuals: "floor_height(x_for_visuals,mid_y)",
			x_for_visuals: "mid_x+round((1d40-20) * spread_scale)",
			
			x_for_damager: "def(index) round(index*60 - round(0.8*20)*spread_scale)",
			floor_for_damager: "def(index) floor_height(mid_x+x_for_damager(index),mid_y)",
			
			_spread: { type: "int", default: 0 },
		},

		on_create: "schedule(150,die())",
		on_process:	"[[ if(floor_for_visuals,[if(cycle%1=0, spawn('frogatto_playable.acid_secondary_shot',x_for_visuals, floor_for_visuals + 10-1d20, facing)), 
						if(cycle%2=1, spawn('frogatto_playable.acid_secondary_bubble',x_for_visuals, floor_for_visuals -5 -1d20, facing))]), 
						if(cycle%10=0, map(range(round(spread_scale*0.8)), if(floor_for_damager(index), spawn('frogatto_playable.acid_shot_damager',mid_x+x_for_damager(index), floor_for_damager(index) -1d20, facing)) ))	
						],
					
						if(_spread < max_spread, add(_spread, 4))]",
		animation: [
			{
				image: "effects/particles2.png",
				id: "normal",
				frames: 1,
				duration: -1,
				rect: [127,19,128,20],
			}
		],
	},
	{
		id: "acid_shot_damager",
		dies_on_inactive: true,
		prototype: ["shot"],
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_when_hit: false,
			attack_damage: 15,
			damage_cooldown: 5,
			damage_type: "'acid'",
		},
		on_create: "schedule(20,die())",
		animation: [
			{
				image: "effects/particles2.png",
				id: "normal",
				frames: 1,
				duration: -1,
				rect: [127,19,128,20],
				attack_area: [-15,-15,15,15,"solid"],
			}
		],
	},
	{
		id: "acid_secondary_shot",
		dies_on_inactive: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		on_create: "[set(velocity_x, 1d20-10),set(velocity_y, -20-1d70)]",
		on_end_normal_anim: "die()",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 10,
				frames_per_row: 5,
				duration: 5,

				rect: [127,19,133,25],
			}
		],
	},
	{
		id: "acid_secondary_bubble",
		dies_on_inactive: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		on_create: "[set(velocity_x, 1d20-10),set(velocity_y, -40-1d80)]",
		on_end_normal_anim: "die()",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 8,
				duration: 7,

				rect: [127,39,137,49],
			}
		],
	},
	{
		id: "fire_shot",
		prototype: ["shot"],
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_when_hit: false,
			attack_damage: 50,
			damage_cooldown: 10,
			damage_type: "'fire'",
		},
		
		on_spawned: "[
			set(vars.parent_obj, spawner),
			set(lights, circle_light(me, 150)),
			schedule(6,animation('pop')),
		]",
		
		on_end_normal_anim: "animation('normal')",
		on_end_pop_anim: "die()",
		
		on_enter_pop_anim: "[
			set(velocity_x,0),
			set(velocity_y,-200-1d100),
			facing(if(1d2=2,1,-1)),
			set(zsub_order,-10),
		]",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 4,
				duration: 2,

				rect: [2,113,15,130],
				attack_area: "all",
			},{
				image: "effects/particles2.png",
				pad: 3,
				id: "pop",
				frames: 3,
				duration: 2,

				rect: [2,134,15,151],
			},
		],
	},

	{
		id: "super_fireball",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: 500,
		
		properties: {
			attack_damage: "round(standard_thrown_damage*(2/3.0))",
			team: "'player'",
			damage_type: "'fire'",
		},
		
		on_die: "[sound('fire-explode.wav'),spawn('explosion_huge_harmful', mid_x, mid_y, facing, [set(child.vars._attack_damage, me.attack_damage),set(child.vars._team, 'player')])]",
		
		on_create: "[
			set(time_in_animation, 1d6),
			sound('energyshot.ogg'),
			schedule(50,die()),
		]",
	
		on_process: "[
			if(cycle%2 = 1, spawn('explosion_spark', mid_x, mid_y, facing)),
			//set(velocity_x,velocity_x*0.97),
			//set(velocity_y,velocity_y*0.97),
			set(lights, circle_light(me, wave(cycle*100+1d20)/100)),
		]",

		
		on_end_anim: "animation('normal')",
		
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			rect: [107,74,138,105],
			pad: 3,
			frames: 8,
			frames_per_row: 4,
			duration: 2,
		},
	},
	
	{
		id: "energyshot",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		
		properties: {
			attack_damage: 20,
			team: "'player'",
			damage_type: "'energy'",
			
			_exploded: { type: "bool", default: false },
		},
		
		on_create: "[
			set(time_in_animation, 1d6),
			sound('energyshot.ogg'),
			schedule(50,die()),
			spawn('frogatto_playable.energyshot_bloom',midpoint_x,midpoint_y,0),
			add_particles('particles'),
		]",
	
		on_process: "[
			set(velocity_x,velocity_x*0.97),
			set(velocity_y,velocity_y*0.97),
			set(lights, circle_light(me, wave(cycle*100+1d20)/100)),
		]",

		// When we die we want to keep the particles coming. So, we turn into a particle_system_holder object and set our hitpoints to the number of cycles we want to keep the particles running for. We schedule turning into the particle system holder next frame, because we want to remain as we are this frame so any remaining collisions can be properly resolved.
		on_die: "[
			set(hitpoints, 30),
			if((not _exploded), [
				set(_exploded, true), 
				spawn('frogatto_playable.energyshot_bloom',midpoint_x,midpoint_y,0),
				sound('energyshot-impact'+1d5+'.wav'), 
				set(hitpoints, 30), set(particles.spawn_rate, 0), 
				schedule(0, [
					set(type, 'particle_system_holder'), 
					fire_event('create'),
				])
			])
		]",
		
		on_end_anim: "animation('normal')",
		
		animation: {
			body_area: "all",
			attack_area: [0,0,10,10],
			id: "normal",
			image: "effects/particles2.png",
			x: 3,
			y: 15,
			w: 10,
			h: 10,
			pad: 3,
			frames: 4,
			duration: 2,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 3,
			max_y: 5,
			spawn_rate: 1000,
			time_to_live: 20,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 84,
				y: 19,
				w: 7,
				h: 7,
				pad: 3,
				frames: 4,
				scale: 2,
				duration: 5,
			},
		},
	},
	
	
	{
		id: "energyshot_bloom",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: -10,

		//When our animation ends we want to disappear and transfer to being a particle_system_holder which will keep the particle system going.
		on_end_anim: "[
			set(hitpoints, 30), 
			set(type, 'particle_system_holder'), 
			fire_event('create'),
		]",

		//we want to spawn a bunch of particles at the start, and then stop, so
		//we schedule an event to stop spawning immediately after we are created.
		on_create: "[
			add_particles('particles'), 
			schedule(1, fire_event('stop_spawning_particles')),
		]",
		
		on_stop_spawning_particles: "set(particles.spawn_rate, 0)",
		
		animation: {
			id: "sparkle",
			image: "effects/powerup-fx.png",
			x: 122,
			y: 2,
			w: 21,
			h: 23,
			pad: 3,
			frames: 8,
			frames_per_row: 4,
			duration: 2,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			spawn_rate: 10000,
			time_to_live: 20,
			min_x: 10,
			max_x: 20,
			min_y: 10,
			max_y: 20,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 1000,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 84,
				y: 19,
				w: 7,
				h: 7,
				pad: 3,
				frames: 4,
				scale: 2,
				duration: 5,
			},
		},
	},
	
	{
		id: "super_energyshot",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: 500,
		
		properties: {
			attack_damage: "round(standard_thrown_damage*(4/3.0))",
			team: "'player'",
			dies_when_hit: false,
			damage_cooldown: 20,
			damage_type: "'energy'",
			goes_through_enemy_shots: true,
		},
		
		
		on_create: "[
			set(animation, 'init'),
			sound('energyshot.ogg'),
			schedule(80,animation('dissipate')),
			add_particles('particles'),
		]",
	
		on_process: "[
			set(velocity_x,velocity_x*1.01),
			set(velocity_y,velocity_y*1.01),
			set(lights, circle_light(me, wave(cycle*100+1d20)/100)),
		]",

		
		on_end_anim: "if(animation = 'dissipate', die(), animation('normal'))",
		on_collide_level: "",
		
		animation: [
		{
			body_area: "all",
			id: "init",
			image: "effects/particles2.png",
			x:111, y:319, w:36, h:32,
			attack_area: [0,0,32,32,"solid"],
			pad: 3,
			frames: 8,
			frames_per_row: 2,
			duration: 2,
			feet_x: 18,
			feet_y: 16,
		},
		{
			body_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x:154, y:144, w:100, h:32,
			attack_area: [0,0,100,32,"solid"],
			pad: 3,
			frames: 5,
			frames_per_row: 1,
			duration: 2,
			feet_x: 76 ,
			feet_y: 16,
		},
		{
			body_area: "all",
			id: "dissipate",
			image: "effects/particles2.png",
			x:247, y:1, w:36, h:32,
			attack_area: [0,0,36,32,"solid"],
			pad: 3,
			frames: 12,
			frames_per_row: 4,
			duration: 4,
			feet_x: 18 ,
			feet_y: 16,
		},
		],
		particle_system: {
			id: "particles",
			type: "simple",
			min_x: 68,
			max_x: 100,
			min_y: 0,
			max_y: 36,
			spawn_rate: 1000,
			time_to_live: 20,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 84,
				y: 19,
				w: 7,
				h: 7,
				pad: 3,
				frames: 4,
				scale: 2,
				duration: 5,
			},
		},
	},
	
	{
		id: "super_homingshot",
		dies_on_inactive: true,
		
		properties: {
			orb_count: "6",
			current_angle: "cycle*2",
			ang_offset: "def(n) n*(360.0/orb_count)",
			radius: "min(cycle/0.5,80)",
			
			_orbs: { type: "[custom_obj]|null", default: null },
		},
		
		on_create: "[set(parent,level.player),
			[ spawn('frogatto_playable.super_homingshot_orb',mid_x,mid_y,facing, [add(me._orbs, [child])]) | v <- range(orb_count)],
			sound('energyshot.ogg'),
			schedule(2000,fire_event(me,'remove')),
		]",
		
		on_process: " [
		
						map(me._orbs,
						[set(value.mid_x, me.mid_x + radius*cos(current_angle + ang_offset(index))),
						set(value.mid_y, me.mid_y + radius*sin(current_angle + ang_offset(index)))])]",
	
		on_remove: "[ [fire_event(v,'die') | v <- me._orbs],
		die()
		]",

		
		on_end_anim: "animation('normal')",
		on_collide_level: "",
		
		animation: {
			id: "normal",
			image: "effects/particles2.png",
			x:111, y:319, w:1, h:1,
			pad: 3,
			frames: 8,
			frames_per_row: 2,
			duration: 2,
			feet_x: 18,
			feet_y: 16,
		},

	},

	{
		id: "super_homingshot_orb",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			goes_through_enemy_shots: true,
			attack_damage: 50,
			damage_type: "'energy'",
			team: "'player'",
			
			_exploded: { type: "bool", default: false },
		},
		
		on_create: "[
			set(time_in_animation, 1d6),
			spawn('frogatto_playable.homingshot_bloom',midpoint_x,midpoint_y,0), 
			add_particles('particles'),
		]",
		
		// When we die we want to keep the particles coming. So, we turn into a particle_system_holder object and set our hitpoints to the number of cycles we want to keep the particles running for. We schedule turning into the particle system holder next frame, because we want to remain as we are this frame so any remaining collisions can be properly resolved.
		
		on_die:"remove_object(me)",

					
	
		on_end_anim: "[animation('normal')]",
		
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x: 1,
			y: 208,
			w: 15,
			h: 15,
			pad: 3,
			frames: 4,
			duration: 1,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 9,
			max_y: 13,
			spawn_rate: 300,
			time_to_live: 24,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 1,
				y: 227,
				w: 7,
				h: 7,
				pad: 3,
				frames: 8,
				frames_per_row:4,
				scale: 2,
				duration: 3,
			},
		},
	},
	
	{
		id: "homingshot_bloom",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: -10,
		
		on_end_anim: "die()",

		animation: {
			id: "sparkle",
			image: "effects/homing-shot-init.png",
			rect: [1,1,31,31],
			frames:9,
			frames_per_row:3,
			duration: 2,
			pad: 3,
		},
	},


	{
		id: "homingshot_impact",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: -10,

		//when our animation ends we want to disappear and transfer to being a particle_system_holder which will keep the particle system going.
		on_end_anim: "[
			set(hitpoints, 30), 
			set(type, 'particle_system_holder'), 
			fire_event('create'),
		]",

		//we want to spawn a bunch of particles at the start, and then stop, so we schedule an event to stop spawning immediately after we are created.
		on_create: "[
			add_particles('particles'), 
			schedule(1, fire_event('stop_spawning_particles')),
		]",
		
		on_stop_spawning_particles: "set(particles.spawn_rate, 0)",
		
		animation: {
			id: "sparkle",
			image: "effects/homing-shot-impact.png",
			rect: [1,1,31,41],
			frames:11,
			duration: 3,
			pad: 3,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 9,
			max_y: 13,
			spawn_rate: 1000,
			time_to_live: 24,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 1,
				y: 227,
				w: 7,
				h: 7,
				pad: 3,
				frames: 8,
				frames_per_row:4,
				scale: 2,
				duration: 3,
			},
		},
	},
	
	{
		id: "homingshot",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			goes_through_enemy_shots: true,
			attack_damage: 50,
			damage_type: "'energy'",
			team: "'player'",
			speed: 700,
			accel_speed: 0.2,
			decay: 0.99,
			multiplier_x: "cos(angle_to(me,_target_lock))",
			multiplier_y: "sin(angle_to(me,_target_lock))",
			my_angle: "angle_to(me,_target_lock)",
			nearest_enemy: "choose(filter(level.active_chars,  value.team and value.team = 'evil' and (not value.is_a_shot = true)), -lib.math.length(value, self)) or level.player",
			
			_exploded: { type: "bool", default: false },
			_target_lock: { type: "custom_obj|null", default: null },
		},
		
		on_create: "[
			set(time_in_animation, 1d6),
			sound('homing.wav'),
			schedule(250,die()),
			set(_target_lock, nearest_enemy),
			spawn('frogatto_playable.homingshot_bloom',midpoint_x,midpoint_y,0), 
			add_particles('particles'),
		]",
		
		on_process: "[
			if(_target_lock, [
				set(velocity_x, median(-speed, velocity_x*decay + multiplier_x*speed*accel_speed, speed)),
				set(velocity_y,median(-speed,velocity_y*decay+multiplier_y*speed*accel_speed,speed)),
			],[
				set(velocity_x, 600*sign(velocity_x)),
				set(velocity_y, 600*sign(velocity_y)),
				set(_target_lock, nearest_enemy),
			]),
			set(lights, circle_light(me, wave(cycle*100+1d20)/100)),
		]",

		// When we die we want to keep the particles coming. So, we turn into a particle_system_holder object and set our hitpoints to the number of cycles we want to keep the particles running for. We schedule turning into the particle system holder next frame, because we want to remain as we are this frame so any remaining collisions can be properly resolved.
		on_die: "[
			set(hitpoints, 30), 
			if(not _exploded, [
				set(_exploded, true), 
				spawn('frogatto_playable.homingshot_impact', midpoint_x, midpoint_y, 0, set(child.rotate,my_angle)),
				sound('homingimpact.wav'), 
				set(hitpoints, 30), 
				set(particles.spawn_rate, 0), 
				schedule(0, [
					set(type, 'particle_system_holder'), 
					fire_event('create'),
				])
			])
		]",
					
		timer_frequency: 21,
		on_timer: "if((not _target_lock in level.active_chars) or target_lock = level.player, set(_target_lock, nearest_enemy))",
		
		on_end_anim: "[animation('normal')]",
		
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x: 1,
			y: 208,
			w: 15,
			h: 15,
			pad: 3,
			frames: 4,
			duration: 1,
		},
		
		particle_system: {
			id: "particles",
			type: "simple",
			min_y: 9,
			max_y: 13,
			spawn_rate: 1000,
			time_to_live: 24,
			velocity_magnitude: 1000,
			velocity_magnitude_random: 100,
			velocity_rotate_random: 360,
			animation: {
				id: "sparkle",
				image: "effects/particles2.png",
				x: 1,
				y: 227,
				w: 7,
				h: 7,
				pad: 3,
				frames: 8,
				frames_per_row:4,
				scale: 2,
				duration: 3,
			},
		},
	},
],

}
