{
id: "frogatto_playable",
prototype: ["player_controlled_platformer_character"],
hitpoints: 4,
mass: 5,
friction: 2000,
traction: 1000, //more traction = more speed
traction_in_water: 2000,
affected_by_currents: true,
solid_area: [9,8,23,30],
feet_width: 5,
zorder: "@include data/zorder.cfg:player",

editor_info: {
	help: "This sets where Frogatto starts on a given level, if the game starts on that level or if the player is teleported to that level without a specific object as a destination. Instances placed in-level will be ignored if there is already a playable character the player is playing.",
	category: "player",
},

//these spritesheets get switched for fat frogatto, so we can't compile them.
no_compile_image: "characters/frogatto-spritesheet1.png,characters/frogatto-spritesheet3.png,characters/frogatto-spritesheet4.png,characters/frogatto-spritesheet5.png",
load_variations: "fat",


properties: {						
#-------------------------- constructor/destructor logic --------------------------#
	common_frogatto_specific_constructor_commands: "	[
		set_up_gui,
		;
		gui_boss_progress_display.reset(),
		set(boss_list, []),

		/* some mostly cosmetic/gameplay-related stuff */
		animation('stand'),
		set(rotate, 0),
		set(invincible, 50),
		set(brightness, 255),
		set(velocity_x, 0),
		set(velocity_y, 0),
		move_to_standing(),
		set(time_last_hit, level.cycle - 200),
		spawn_shadow('small'),
		remap_my_attaches_to_me ;
		
		/*
			We're trying to fix an issue here where the position_predictor is basically referring to a 'stale/zombie' version of the player character, after loading from a save.  If you just launch a level, then the predictor will work just fine, but if you respawn from a checkpoint, it'll refer to the prior version of the player, which gives incorrect coordinates.   This because the on_create behavior for the player triggers the `init` statements inside of variables, but the `on_load` et al fail to actually run any of those variables, wrongly assuming that if they've already been built, that whatever's in them will happily stay correct across launches.
		*/
		set(
			position_predictor,
			construct('predictive_player_motion',{this_obj: me, the_player: me}),
		),


		readd_attaches(me),
		if(not item_quantities, initialize_items),

		//development cheats
		schedule(1, ; [
			if(MODULE_OPTIONS.supes, supes),
			if(MODULE_OPTIONS.hax, hax),
			if(MODULE_OPTIONS.lucre, lucre),
		]),

		reestablish_swallowed_object,
	]",

	specific_player_obj_constructor: "commands :: [
		common_frogatto_specific_constructor_commands,


		set(started_using_ability_at_cycle, fold(map(mana_cooldown_time, {(InventoryItemType :: key): -value}), a+b)),


		if(not _preexisting_object, [  //note to self: this doesn't get serialized, so you can't do this in the player object.
		]),

		
		reestablish_swallowed_object,
		

		validate_death_tracking_storage,
	]",

	reestablish_swallowed_object: "commands :: [
		/*
			Make it so that if we had a swallowed object we create a fresh version of the object in our stomach.
		
			There's a rare bug that can happen sometimes where, before saving, where the player's swallowed object ends up being a valid object, but having a hitpoint value of zero.  If that's the case here, we deal with it by just making the swallowed object null.
		*/
		if(swallowed_object,
			if(swallowed_object.hitpoints = 0,
				[
					empty_stomach({kill_contents: false}),
					animation('stand'),
				],
				[
					set(swallowed_object, throwable_obj),
					fire_event(throwable_obj, 'been_grabbed'),
					fire_event(throwable_obj, 'swallowed')
				] where throwable_obj = (obj throwable <- replacement_object_with_preserved_attributes( swallowed_object, swallowed_object.type, swallowed_object.hitpoints, swallowed_object.max_hitpoints ))
			)
		),
	]",


	
	specific_player_obj_destructor: "commands ::	[
														tear_down_gui, /* Remove the gui so it does not panic when we, ourself, are removed. */
														zombie_object_cleanup,
													]",
	
	
	specific_player_obj_enter_level: "commands ::	[
															/* Tracking, used for some events and displaying a metric of progress for saved games. */
														if(not level.id in levels_visited, add(levels_visited, [level.id])),

														common_frogatto_specific_constructor_commands,
														schedule(2, do_key_check),
													]",
	
	specific_player_obj_load_checkpoint: "commands :: 	[
															validate_death_tracking_storage,
															player_death_penalties,
															common_frogatto_specific_constructor_commands
														]",
	
	specific_player_obj_load: "commands ::	[
													common_frogatto_specific_constructor_commands,
													/*
														`checkpoint` save the game so that if we die, we respawn right here.
														We specifically only want this in `on_load` because we don't want to save the game when you enter any level; **just** when you load the game from a save.
													*/
												validate_death_tracking_storage,
												checkpoint_game(),	
											]",
	
	player_death_penalties: "commands ::	[
												set(hitpoints, (max_hitpoints*4-difficulty)/4),
												set(score, (score*9)/10),
											]",

	zombie_object_cleanup: "commands :: [remove_object(_tongue_tip), set(_tongue_tip, null)]",







	death_effects: "def(string type) -> commands [
						set(globals.player_has_died_since_last_unique_checkpoint, true),
						spawn('die_cloud', midpoint_x, midpoint_y, facing),
					]",
			
#-------------------------- attack/damage handlers --------------------------#
	flinch_threshold: 0, //Used to trigger when we do that little 'jump' when we get hurt. Since we always want to do it, we've got the variable set to 0. It defaults to 3, otherwise.
	character_specific_damage_response: "def(DamageType damage_type, int amount) -> commands if(amount > 0, if(is_currently_fat, shoot_spit_attack, animation('hurt')) )",

	play_object_specific_pain_vocalization: "def(DamageType damage_type, damage_amount) -> commands lib.sound.play_sound(me, 'TakeDamage')",


	handle_unusual_collisions: "def(custom_obj collide_with, string collide_with_area, [builtin user_collision_callable]|null all_collisions=null, int|null collision_index=null) -> commands
			if(collide_with_area = 'interact', set(can_interact, true))",

#-------------------------- general handlers --------------------------#
		#-- Some totally generic stuff --#

	is_player_body_part: "true",
	taxonomy: "TaxonomyType :: enum neutral",

	
	/*
		tracking key presses:  we can accomplish keyup, keydown, and key-held by doing the following:
	 	
	 	By setting the cycle on which a key is pressed, we limit ourselves to a set of keys that need to be re-checked on later frames to see if they're still held down.  We don't need to register key-tracking up-front, as having an access of ctrl_keyboard in on_process will make this implicit (though any gap of more than one cycle in on_process tracking will break continuity of key-holds).
	 
	 	On the first frame, we set the current cycle a key has been pressed at.  We leave this alone if the key continues being pressed (which allows us to know how long it's been pressed), or if a key is released, we null this out.
	 */

	_key_state: { type: "{string -> { state: bool, time_set: int }}", default: {} },

	_track_keys: "def() ->commands [
		[set(_key_state[k], { state: false, time_set: cycle }) | k <- keys(_key_state), _key_state[k].state, k not in ctrl_keys],
		[set(_key_state[k], { state: true, time_set: cycle }) | k <- ctrl_keys, (k not in _key_state) or _key_state[k].state = false],
	]",
	
	/* TODO:  not quite the right fix to ctrl_keyboard + control_lock_registry;  it should actually let you lock them to an on position, rather than just ignoring the non-builtin keys. */
	ctrl_keyboard: "def(string key_name) ->int|null 
		if(size(me.control_lock_registry) = 0, 
			if(entry and entry.state,
				cycle - entry.time_set
			) where entry = _key_state[key_name],
		)
	",
	ctrl_keyboard_released: "def(string key_name) ->int|null if(entry and entry.state = false, cycle - entry.time_set, entry = null, cycle) where entry = _key_state[key_name]",
	

	spawn_on_ref: "def(string name, decimal x, decimal y, int facing) -> commands [
		set(obj.parent, self.standing_on),
		add_object(obj),
		] where obj = object(name, x, y, facing)",
   
 
 
 

		#-- Random Animation Logic --#
	_cycles_since_last_touching_ground: { type: "int", default: 0 },
	postjump_grace_period: "10",

	can_jump: "def() -> bool
	  	bool(is_standing and (animation not in ['interact', 'fall', 'jump', 'start_jump']) or 
			//after frogatto starts falling off a ledge, give the player a little grace in allowing them to still initiate a jump.
	     animation = 'fall' and _cycles_since_last_touching_ground < postjump_grace_period)",
	
	bounce_on: "def(obj standard_values object_being_stood_on) -> commands [
		set(velocity_y,
			-max(object_being_stood_on.spring_amount,
				((velocity_y * object_being_stood_on.springiness)/100 * (100 - abs(bounce_angle)))/100
			)
		),
		add(velocity_x, 
			((velocity_y * object_being_stood_on.springiness)/100*bounce_angle)/100
		),
		fire_event(object_being_stood_on, 'bounced_on'),
		set(_last_bounced, cycle),
		set(_bounced_on_chain, new_bounced_on_chain),
		if(_bounced_on_chain > 8, achievement('jackalope')),
		] where bounce_angle = (object_being_stood_on.bounce_roundness * (mid_x - object_being_stood_on.mid_x))/(max(1, object_being_stood_on.w)),
				new_bounced_on_chain = if(object_being_stood_on is obj hittable and object_being_stood_on.team != 'evil', 0, _bounced_on_chain + 1)",


	do_upon_landing: "def([function() -> commands] todo) -> commands add(_todo_upon_landing, todo)",
	fullfill_todo_upon_landing: "if(_todo_upon_landing != null, [map(_todo_upon_landing,value()),set(_todo_upon_landing, null)])",
	
	_todo_upon_landing: {type: "[function() -> commands]|null", default: null}, 
	
	
	
	
	
	
		#-- Achievement/Story stuff --#
	register_annoyed_npc: "def(string name) -> commands debug('Recorded ' + name + ' as annoyed.')",
	




		#-- Cinematic Stuff --#
	do_post_victory_transport: "def(string target_level, string target_obj) -> commands execute(me,[
									set(me.hitpoints, me.max_hitpoints),
									standard_victory_music,
									title(~Victory!~,200),
									do_cinematic_float(
									[
									def() schedule(1, sinusoidal_transition({period:90, _init_theta:0.0, _length_theta:1.0, addend:2, coefficient:1, obj:level, aspect:'zoom'})),
									def() schedule(89, remove_control_lock('cinematic_float')),
									def() schedule(90, if(target_level and target_obj, teleport(target_level, target_obj, 'iris'))),
									def() schedule(92, screen_flash([0,0,0,255], [0,0,0,0], 100)),
									def() schedule(92+100, screen_flash([0,0,0,255], [0,0,0,-3], 85)),
									]
									)
								]) asserting target_obj != '' and target_level != ''",
								
	do_post_victory_without_transport: "def([function() -> commands] post_landing_todos) -> commands execute(me,[
					set(me.hitpoints, me.max_hitpoints),
					standard_victory_music,
					title(~Victory!~,200),
					do_cinematic_float(
					[def() schedule(119, remove_control_lock('cinematic_float')),
					def() schedule(60, sinusoidal_transition({period:100, _init_theta:1.0, _length_theta:1.0, addend:1, coefficient:1, obj:level, aspect:'zoom'})),
					def() schedule(160, set(level.zoom, 1.0))] + post_landing_todos
					)
				])",
				
	do_cinematic_float: "def(null|[function() -> commands] additional_landing_todos) -> commands [
							set(level.player.rotate, 0),
							set(current_ability, enum item_tongue),
							; if(is_currently_fat, shoot_spit_attack),
							
							schedule( if(is_currently_fat, 50, 1), ; [
								add_control_lock([], 'cinematic_float'),
								set(level.player.velocity_x,0),
								set(level.player.accel_x,0),
								animation('floating_spin'),
								do_upon_landing( [def() animation('emote_victory')] ),
								if(additional_landing_todos != null, map(additional_landing_todos, do_upon_landing( [value] ))),
								sinusoidal_transition({period:period/4, _init_theta:0.0, _length_theta:1.0, addend:1, coefficient:1, obj:level, aspect:'zoom'}),
								sinusoidal_transition({period:period, _init_theta:1.0, _length_theta:1.0, addend:0, coefficient:-200, obj:level.player, aspect:'velocity_y'}),
								schedule(1*(period/4),animation('floating_spin_fast')),
								schedule(2*(period/4),animation('floating_spin_faster')),
								schedule(period - period/8,animation('floating_spin')),
							])
						] where period = 400",



	
	
#-------------------------- progression cheat codes --------------------------#
	/*
		In the spirit of early cheat codes, these codes are meant to make testing later levels more balanced against how powerful the player would normally be on such a level; they immediately empower the player as though the player has played that far into the game, and has gotten all of the appropriate upgrades for that point in the game.  This way we don't fall into making the levels easy enough to pass on a mere 2 hearts.  We also try to set major event flags, so that if i.e. you enter a cheat code for a certain boss fight (like beating the gazer boss), it also flags the associated NPC conversations so you're on a quick path to test that.
		
		Note that the way to enter such a code is to type ctrl+d to bring up the debug prompt, type (e.g.) "hax", press return to execute the code, and then press escape to turn off the debug prompt.
		
		We have a whole family of these for various points in the game.  Note that subsequent commands usually "re-run" earlier commands, so we don't have to copy-paste tons of event flags.
	*/


	hax_nene: "[  /* just finished nene's basement quest */
		;set_item_amount(enum item_fire_breath_talisman, 1),
		;add(levels_visited, ['frogatto-grotto.cfg', 'to-nenes-house.cfg']),
		;store_event('talked_to_nene', 1),
		;store_event('nenes_treasure_chest_unlocked', 1),
		;store_event('nenes_basement_ants_killed', 3),
	]",

	hax_mtm: "[  /* being past Mortimer's house */
		;hax_nene,

        ;add(levels_visited, ['secluded-hut.cfg']),
		;set_item_amount(enum item_magic_map, 1),
		;set_item_amount(enum item_heart_container, 3),
		
		store_event('stonepipe_bridge_fight_won',1),
		store_event('berds_post_airplane_boss_speech',1),
	]",
    
	hax_elder: "[  /* just beat the elder's house fight */
		;hax_mtm

		;add(levels_visited, ['crevice-village.cfg']),
        
		;set_item_amount(enum item_magic_map, 1),
		;set_item_amount(enum item_heart_container, 4), //unlike `hax_tempo`, we're assuming you haven't hunted around and bought extra hearts.
		;add_item(enum item_fire_breath_talisman, 1),
		
		store_event('town_elder_fight_won',1),
		store_event('town_elder_post_fight_speech',1),
	]",
	
	hax_tempo: "[  /* being at tempo village, but not having talked to anyone yet */
		;hax_elder
        ;add(levels_visited, ['foreboding-forest.cfg', 'rustic-route.cfg']),
		;set_item_amount(enum item_magic_map, 1),
		;set_item_amount(enum item_heart_container, 5), //we assume you've gotten the hearts from the airplane boss, from ralph, and also probably found or bought one extra one.
		;add_item(enum item_fire_breath_talisman, 1),
	]",

	
	hax_gazer: "[ /* having beaten the gazer boss, talked to prospera beforehand, but NOT talked to prospera afterwards. */
		;hax_tempo

        ;add(levels_visited, ['musty-mine.cfg']),
		;set_item_amount(enum item_magic_map, 1),
		;set_item_amount(enum item_heart_container, 5),
		;add_item(enum item_fire_breath_talisman, 1),
		;add_item(enum item_energy_shot_talisman, 1),

		store_event('introduced_to_imoti', 1),
		store_event('frogatto_has_seen_tempo_village_force_field', 1),
		store_event('frogatto_knows_about_prospera_passphrase', 1),
		store_event('frogatto_has_met_prospera',1),
		store_event('prosperas_elevator_active',1),
		store_event('finished_initial_exterior_prospera_conversation',1),
		store_event('finished_initial_prospera_conversation',1),
		store_event('defeated_gazer_boss',1),
	]",


	hax_prospera: "[ /* having both beaten the gazer boss, and been shown prospera's workshop. */
		;hax_gazer
	
		;set_item_amount(enum item_magic_map, 1),
//		;set_item_amount(enum item_creature_field_guide, 1),
		;set_item_amount(enum item_heart_container, 5),
		;add_item(enum item_fire_breath_talisman, 1),
		;add_item(enum item_energy_shot_talisman, 1),


		store_event('finished_post_gazer_boss_conversation',1),
		store_event('prosperas-workshop-unlocked',1),
		store_event('introduced_prosperas_workshop', 1),
	]",


	
	hax_moth: "[ /* having beaten the moth boss. */
		;hax_gazer

        ;add(levels_visited, ['ravenish-ravine.cfg', 'shady-shortcut.cfg']), //we assume you passed by/found Shady Shortcut
        
		;set_item_amount(enum item_magic_map, 1),
//		;set_item_amount(enum item_creature_field_guide, 1),
		;set_item_amount(enum item_heart_container, 6),
		;add_item(enum item_fire_breath_talisman, 1),
		;add_item(enum item_energy_shot_talisman, 1),
		;add_item(enum item_homing_shot_talisman, 1),

		store_event('moth_boss_fight_won',1),
		store_event('moth_boss_postfight_dialogue',1),
	]",

	hax_mushroom: "[ /* having beaten the mushroom boss. */
		;hax_gazer

        ;add(levels_visited, ['the-empty-place.cfg', 'shady-shortcut.cfg']), //we assume you passed by/found Shady Shortcut
        
		;set_item_amount(enum item_magic_map, 1),
//		;set_item_amount(enum item_creature_field_guide, 1),
		;set_item_amount(enum item_heart_container, 6),
		;add_item(enum item_fire_breath_talisman, 1),
		;add_item(enum item_energy_shot_talisman, 1),
		;add_item(enum item_acid_breath_talisman, 1),
		
		store_event('mushroom_boss_fight_won',1),
		store_event('missing_berd_post_mushroom_boss_speech',1),
	]",





#-------------------------- generic cheat codes --------------------------#
	/*
		Unlike the above stuff, these are just generic cheat codes.  Arguably `hax` is maybe ultra-lategame progression for frogatto, but these are just sort of divorced from the whole idea.
	*/


	
		//activate a weird loophole where you don't run out of upward momentum whilst jumping;  you jump up, and as long as you keep holding the button, it's just up up and up.
	choppa: "set(_jump_cheat,true)",
	choppa_disable: "set(_jump_cheat,false)",

		//kill every enemy in the level.
	smite: "map(filter(level.chars, value is obj hittable), if(value.team = 'evil', value.force_death()))",

	supes: "[  //superman mode
		hax,
		choppa,
		set(invincible,-1),
	]",
	
	thor1: "[  //take the particularly 'cheat mode' powers away so you can fight normally.  Useful if you wanted to fly to cheese through some obstacles, but the thing you want to test requires you to actually be vulnerable.
		set(_jump_cheat,false),
		set(invincible,0),
	]",
	
	lucre: "[  //all the money
		acquire_gold(20000),
		map(all_trophy_items, add_item(value.id, 1)),
		map(all_trophy_items, store_event( enum_to_string(value.id) + '_acquired', 1)),
	]",

	hax: "[  //give me all the powerups.
		set(mana, 5000), 
		;set_item_amount(enum item_heart_container, 6),

		;set_item_amount(enum item_tongue_extension, 2),
		;set_item_amount(enum item_greater_mana_talisman, 1),
		;set_item_amount(enum item_lesser_mana_talisman, 1),
//		;set_item_amount(enum item_creature_field_guide, 1),
		;set_item_amount(enum item_magic_map, 1),
		;add_item(enum item_acquirable_attractor, 1),


		;add_item(enum item_fire_breath_talisman, 1),
		;add_item(enum item_energy_shot_talisman, 1),
		;add_item(enum item_acid_shot_talisman, 1),
		;add_item(enum item_ice_corona_talisman, 1),
		;add_item(enum item_acid_breath_talisman, 1),
		;add_item(enum item_fire_shot_talisman, 1),

		;add_item(enum item_super_fire_pendant, 1),
		;add_item(enum item_super_energy_pendant, 1),
		;add_item(enum item_super_arcane_pendant, 1),
		;add_item(enum item_super_acid_pendant, 1),
		//  ;add_item(enum item_super_ice_pendant, 1),  omitted; freezing sometimes breaks stuff

		add_item(enum item_health_potion, 2),
	]",

#-------------------------- omnibus cheat codes --------------------------#
	/*
		Last but not least, we've got a final few cheat codes to test 'future content'.  These just add *everything*; they scan the item lists and add every conceivable item or ability we've got, even if it's broken.
		
		These probably aren't fun to use for 'cheating'.  A lot of these will just be outright broken, and might just crash the game.
	*/

	leet: "[
		hax
		;
		map(secondary_item_list_full, ;set_item_amount(value,1)),
		map(ability_list_full, ;set_item_amount(value,1)),
		map(super_ability_list_full, ;set_item_amount(value,1)),	
	]",

	shaggy: "[  //real.  ultimate.  power.
		leet,
		choppa,
		set(invincible,-1),
	]",





	//show sound logging.

	logsounds: "
	if(lib.sound.log_sounds, [
		remove_object(cur_log),
		set(lib.sound.log_sounds, false),

	] where cur_log = find(level.chars, value is obj sound_log), [
		set(lib.sound.log_sounds, true),
		spawn('sound_log', {
			x: 0, y: 0,
		})
	])
	",



#-------------------------- inventory handlers --------------------------#
	initialize_items: "commands ::	[
										set_item_amount(enum item_tongue, 1),
										if( max_hitpoints != 2 * number_of_item(enum item_heart_container),
											set_item_amount(enum item_heart_container, max(2, number_of_item(enum item_heart_container)))
										),
									]",

	item_behaviour_trigger: "def(InventoryItemType item_type) -> commands 
		switch(	item_type,
				enum item_wall_sticker_block,  item_fire_wall_sticker_block,
				enum item_skipback_sigil, item_trigger_skipback_sigil,
				enum item_health_potion, item_trigger_health_potion
		)
	",



	item_fire_wall_sticker_block: "commands ::
		[
			me.fill_stomach_with_new_ammo('ability_wall_sticker_block'),
			lib.sound.play_sound(me, 'stomach-fill'),
			spawn('effects_attache_batch',x,y,{
				time_to_die: 00,
				parent:me,
				effects_preset: enum arcane,
				timeout: 30
			}),
		]
	",

	item_trigger_skipback_sigil: "commands ::
		if(skipback_anchor,
			[
				set(level.player.mid_xy, skipback_anchor.mid_xy),
				remove_object(skipback_anchor),
			],
			[
				spawn('ability_skipback_sigil_anchor', mid_x, mid_y, 1)
			]
		) where skipback_anchor = find(level.chars, value is obj ability_skipback_sigil_anchor)
	",
	
	item_trigger_health_potion: "commands ::
		[
			lib.sound.play_sound(me, 'potion-chug', {volume: 3.0}),
			set(me.hitpoints, me.max_hitpoints),
			add_item(enum item_health_potion, -1),
			
			spawn('silhouette_heart',level.player.mid_x,level.player.mid_y,1),
			map(range(10), spawn('heart_sparkle_large', level.player.mid_x, level.player.y2, 0)),
		]
	",

	


#-------------------------- general animation handlers --------------------------#
	uninterruptible_animations: "['turn', 'crouch', 'enter_crouch','interact'] + emote_animations + cinematic_animations + attack_animations",
	
	emote_animations: "['emote_victory', 'emote_angry', 'emote_nod', 'emote_talk', 'emote_raisedfinger', 'emote_impatient', 'emote_confused', 'emote_oh', 'emote_geez']",
	cinematic_animations: "['item_get_begin', 'item_get_hold', 'item_get_end']",
	interruptible_cinematic_animations: "['floating_spin', 'floating_spin_fast', 'floating_spin_faster']",
	attack_animations: "['jump_attack', 'energyshot', 'attack', 'walk_attack', 'firebreath_begin','firebreath_cycle','firebreath_end', 'spit',
						'underwater_breath_attack_up', 'underwater_breath_attack_up_diag', 'underwater_breath_attack_side', 'underwater_breath_attack_down_diag', 'underwater_breath_attack_down']",
	jump_animations: "['start_jump','jump','fall']",


	maintain_locomotion: "commands :: if(not underwater, set(accel_x, coeff * magnitude))
								where coeff = if(ctrl_left or ctrl_right, if(animation = 'turn', 0.3,1), 0), where magnitude = if(is_running, run_accel, walk_accel)",


#-------------------------- attack/ability handlers --------------------------#
	/*
		NOTE: regarding channelled attacks, especially those which consume a low amount of mana per frame.
		
		Problem:  if your only requirement to initiate the attack is the mana/frame cost, then you will "sputter" when your mana is low.  For example, if it takes 20 mana to fire a round, and it takes 10 frames to recharge that much (say, recharging 2 mana/frame), you'll go from firing a constant steam of one projectile/frame, to firing only one projectile every 10 frames 
		
		Visually, this actually looks kinda cool on the fire attack, but it's problematic, because the high cooldown (on how often you can deal damage) means that this sputtering version is as effective as the real thing even if you have no mana!
	
		There are a few options to prevent this, we've gone with both 1 and 2 for now:
		1] when mana is exhausted, incur a "mana shock" timeout where all mana-based abilities are unuseable for a few moments.
		2] keep burning mana at the same rate, regardless of whether the powerup is being used, for the full cooldown duration of the ability.
		3] incur a startup cost to initiate the ability at all; if something costs 2 mana/frame, maybe charge 40 mana to start the ability up at all.
		4] rather than a startup cost, require the player to have at least > X mana to use the ability.  This differs from 2] in not actually consuming that startup cost, just requiring you to have it.
	*/
	attack: "def() -> commands 
		if(is_currently_fat, extend_tongue, 
			if(underwater,
				switch(current_underwater_ability,
					enum item_underwater_bubble_attack,			shoot_bubble,
					enum item_underwater_ink_attack,			shoot_oil_jet,
					enum item_underwater_fire_attack,			shoot_fire_blob,
					enum item_underwater_energy_shock_attack,	shoot_underwater_shock_attack,
				),
				switch(current_ability,
					enum item_tongue,							extend_tongue,
					enum item_fire_breath_talisman,				mana_shock_guard(shoot_fire),
					enum item_fire_shot_talisman,				mana_shock_guard(shoot_fire_shot),
					enum item_energy_shot_talisman,				mana_shock_guard(shoot_energy_shot),
					enum item_acid_shot_talisman,				mana_shock_guard(shoot_acid_shot),
					enum item_homing_shot_talisman,				mana_shock_guard(shoot_homing_shot),
					enum item_acid_breath_talisman,				mana_shock_guard(shoot_acid),
					enum item_ice_corona_talisman,				mana_shock_guard(shoot_ice_corona)
				)
			) 
		)",
		
	spawn_tongue: "def(decimal angle) -> commands
			[if(animation in ['stand', 'leave_crouch', 'walk', 'run', 'enter_lookup', 'lookup','skid', 'land'], animation('attack')),
			if(animation in ['jump', 'fall', 'start_jump'], animation('jump_attack')),
			spawn('frogatto_playable.tongue_tip', mid_x, mid_y -12, {facing: facing, _tongue_angle:angle, _frog: me}, [set(_tongue_tip, child)])]",
	
	extend_tongue: "commands ::
			if(ctrl_tongue_counter > 1 or (_tongue_tip != null), null,
				if(is_currently_fat,
					if(not (animation in ['interact']), shoot_spit_attack ),
					[
						if(animation in ['stand', 'leave_crouch', 'walk', 'run', 'stand_to_walk', 'turn_whilst_running', 'enter_lookup', 'lookup','skid', 'land', 'jump', 'start_jump', 'fall'],
							if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, spawn_tongue(-45),
								if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, spawn_tongue(45),
									if(ctrl_up, spawn_tongue(-90), if(ctrl_down, spawn_tongue(90), spawn_tongue(0))))))
					]
				)
			)",

	is_super_attack_completely_viable_besides_mana_and_cooldowns: "bool ::
		is_super_attack_completely_viable_besides_mana_and_cooldowns_for_ability(current_ability)
	",

	is_super_attack_completely_viable_besides_mana_and_cooldowns_for_ability: "def(InventoryItemType ability) -> bool
		stomach_contents_would_allow_super_attack
		and
		has_super_pendant_for_ability(ability)
	",

	has_super_pendant_for_ability: "def(InventoryItemType regular_ability) -> bool
		if(super_version != null,
			has_item(super_version),
			false
		)
		where super_version = super_ability_that_corresponds_to_this_regular_ability( regular_ability )
	",

	super_ability_that_corresponds_to_this_regular_ability: "def(InventoryItemType regular_ability) -> InventoryItemType | null
		switch(me.item_info(regular_ability).item_element_type,
			enum fire,		enum item_super_fire_pendant,
			enum ice,		null,
			enum energy,	enum item_super_energy_pendant,
			enum acid,		enum item_super_acid_pendant,
			enum arcane,	enum item_super_arcane_pendant,
			null
		)
	",

	current_super_ability: "super_ability_that_corresponds_to_this_regular_ability( current_ability )",
	
#-------------------------- mana --------------------------#
	mana_base_regen_coefficient: "10*(0.5 + if(has_item(enum item_lesser_mana_talisman), 0.3333, 0.0) + if(has_item(enum item_greater_mana_talisman), 0.6667, 0.0))",
	
	//This is a pretty carefully-tuned non-linear function that makes low levels of mana give much faster regen, so that you're not stuck helpless on levels without base combat available.  The purpose then of mana isn't primarily about "running out", but about keeping high-consumption techniques harder to use.  Basically this makes the ability to use techniques scale with the amount of mana you have, which matters because the actual usefulness value in the game changes accordingly (being able to do a pea-shooter attack is priceless when you have almost no mana)
	mana_regen_per_frame: "mana_base_regen_coefficient*max(0.1,((max_mana-(mana/3))/decimal(max_mana))^8)",
	
	mana_costs: "{InventoryItemType -> int} :: {
								enum item_fire_breath_talisman				: 35,
								enum item_fire_shot_talisman				: 1000,
								enum item_energy_shot_talisman				: 200,
								enum item_acid_shot_talisman				: 700,
								enum item_homing_shot_talisman				: 1000,
								enum item_acid_breath_talisman				: 650,
								enum item_ice_corona_talisman				: 800, 

								enum item_underwater_bubble_attack			: 0,
								enum item_underwater_ink_attack				: 250,
								enum item_underwater_fire_attack			: 40,
								enum item_underwater_energy_shock_attack	: 500,
								
								enum item_super_fire_pendant				: 2500,
								enum item_super_energy_pendant				: 1500,
								enum item_super_arcane_pendant				: 3000,
								enum item_super_acid_pendant				: 2000,
								enum item_super_ice_pendant					: 2000
						}",
	
	//mana_cooldown_time: how long mana keeps burning and the interval between which the ability can't deal damage
	mana_cooldown_time: "{InventoryItemType -> int} :: {
								enum item_fire_breath_talisman				: 10,
								enum item_fire_shot_talisman				: 0,
								enum item_energy_shot_talisman				: 0,
								enum item_acid_shot_talisman				: 0,
								enum item_homing_shot_talisman				: 0,
								enum item_acid_breath_talisman				: 0,
								enum item_ice_corona_talisman				: 0, 

								enum item_underwater_bubble_attack			: 0,
								enum item_underwater_ink_attack				: 0,
								enum item_underwater_fire_attack			: 0,
								enum item_underwater_energy_shock_attack	: 0,
									
								enum item_super_fire_pendant				: 0,
								enum item_super_energy_pendant				: 0,
								enum item_super_arcane_pendant				: 0,
								enum item_super_acid_pendant				: 0,
								enum item_super_ice_pendant					: 0
						}", 
	
	//ability_charge_time: how long an ability needs to "charge up" before you can fire it again 
	ability_charge_time: "{InventoryItemType -> int} :: {
								enum item_fire_breath_talisman				: 0,
								enum item_fire_shot_talisman				: 35,
								enum item_energy_shot_talisman				: 15,
								enum item_acid_shot_talisman				: 10,
								enum item_homing_shot_talisman				: 30,
								enum item_acid_breath_talisman				: 30,
								enum item_ice_corona_talisman				: 60, 

								enum item_underwater_bubble_attack			: 60,
								enum item_underwater_ink_attack				: 60,
								enum item_underwater_fire_attack			: 20,
								enum item_underwater_energy_shock_attack	: 60,
									
								enum item_super_fire_pendant				: 0,
								enum item_super_energy_pendant				: 0,
								enum item_super_arcane_pendant				: 0,
								enum item_super_acid_pendant				: 0,
								enum item_super_ice_pendant					: 0
						}",
	
	//check all the standard criterion for whether the ability can be used.
	ability_is_charged_up: "def(InventoryItemType ability_name) -> bool 
		(not mana_shock_active)
		and mana >= mana_costs[ability_name]
		and min(
			ability_charge_time[ability_name],
			cycle-started_using_ability_at_cycle[ability_name]
			) >= ability_charge_time[ability_name]",
	
	//check if we need to burn mana after having just used this ability
	ability_is_cooling_down: "def(InventoryItemType ability_name) -> bool 
		min(
			mana_cooldown_time[ability_name],
			cycle - started_using_ability_at_cycle[ability_name]
			) < mana_cooldown_time[ability_name]",
			
	//Mana state matrix used by ability_display
	should_make_hud_graphic_look_enabled_for_this_item: "def(InventoryItemType ability_name) -> bool
		if(stomach_contents_would_allow_super_attack,
			if(has_super_pendant_for_ability(ability_name),
				if(super_version != null, //this is redundant but required for type coercion
					ability_is_charged_up( super_version ),
					false
				) where super_version = super_ability_that_corresponds_to_this_regular_ability( ability_name ),
				false
			),
			ability_is_charged_up( ability_name )
		)",

		
	stomach_contents_would_allow_super_attack: "bool <- bool(swallowed_object and not swallowed_object is obj padlock_key)",
	
	//used for regular, active consumption - note that we DON'T subtract mana if we're cooling down, otherwise we'd double-dip
	use_mana_for_ability: "def(InventoryItemType ability_name) -> commands [
		if(not ability_is_cooling_down(ability_name),
			add(mana, -mana_costs[ability_name])),
		set(me.started_using_ability_at_cycle[ability_name], cycle)
		]",
	
	//used in the process loop to burn cooldown mana for any recently used powers
	use_mana_cooldowns: "def() -> commands map(ability_list_full, if(ability_is_cooling_down(value), add(me.mana, -mana_costs[value]) ))",
	
	
#-------------------------- attacks --------------------------#
		#-- General Stuff --#

	quantized_shot_angle: " //to nearest diagonal or cardinal, based on controls held down
		if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, -45,
				if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, 45,
					if(ctrl_up, -90, if(ctrl_down, 90, 0))))",

		//these are used for both the energy-shot, and the homing-shot; anything that sprouts from frogatto's extended finger
	fingerpoint_attack_spawn_head: "def() -> commands spawn('${self.type}.frogatto_head_fingerpoint_attack',midpoint_x,midpoint_y-8,{facing: facing, _head_angle: quantized_shot_angle})",
	
	fingerpoint_attack_anim: "switch(null, //If nothing is to be switched upon, then the function switches based on the first true key.
		me.animation in ['stand', 'leave_crouch', 'walk', 'enter_lookup', 'lookup','skid', 'land'], if(abs(slope_standing_on) < 20, 'fingerpoint_attack', if(slope_standing_on*facing > 0, 'fingerpoint_attack_down_slope', 'fingerpoint_attack_up_slope')),
		me.animation in ['jump', 'fall'], 'fingerpoint_attack_jump',
		'fingerpoint_attack')",
	
	fingerpoint_attack_anim_list: "['fingerpoint_attack', 'fingerpoint_attack_up', 'fingerpoint_attack_down', 'fingerpoint_attack_jump', 'fingerpoint_attack_crouch', 'fingerpoint_attack_swim_side', 'fingerpoint_attack_swim_down', 'fingerpoint_attack_swim_up']",




		#####-- Underwater Attacks --#####
	do_underwater_attack_cosmetics: "commands :: [
		set(facing, desired_swim_facing) where desired_swim_facing = if(swim_rotation_cosmetic > 180,-1,1),
		set(animation, 'underwater_breath_attack' + nearest_swim_animation_suffix),
		//set(time_in_animation, time_in_animation),
		set(rotate, swim_rotation_offset)
	]",

	use_underwater_attack: "def(InventoryItemType ability_name, function(decimal)->commands shot_commands) -> commands [
		[
			do_underwater_attack_cosmetics,
			update_swim_rotation_cosmetic(__dirx, __diry)
		]
		where __dirx = if( ctrl_left, if(ctrl_up or ctrl_down, -500, -800),
		                  ctrl_right, if(ctrl_up or ctrl_down,  500,  800),
		                  0)
		where __diry = if(  ctrl_up, if(ctrl_left or ctrl_right, -500, -800),
		                  ctrl_down, if(ctrl_left or ctrl_right,  500,  800),
		                  0),
		if(ability_is_charged_up(ability_name),
			[
				//TODO: a custom animation would be added here.
				shot_commands(swim_rotation_cosmetic - 90),
				use_mana_for_ability(ability_name)
			]
		)
	]",
		
		
	shoot_bubble: "commands :: use_underwater_attack(
			enum item_underwater_bubble_attack,
			def(decimal angle) -> commands
				[
					lib.sound.play_sound(me, 'bubble-blow'),
					spawn('frogatto_playable.bubble_shot',
						mid_x + 20 * cos(angle),
						mid_y + 20 * sin(angle),
					{
						facing: facing,
						_parent_obj: me,
						velocity_x: 400*cos(angle) + 1d100-50 + me.velocity_x,
						velocity_y: 400*sin(angle) + 1d100-50 + me.velocity_y,
					}),
				]
		)",

	shoot_oil_jet: "commands :: use_underwater_attack(
			enum item_underwater_ink_attack,
			def(decimal angle) -> commands
				[
					lib.sound.play_sound(me, 'baster-slurp'),
					spawn('frogatto_playable.ink_blob_spawner',
						mid_x - 20 * cos(angle),
						mid_y - 20 * sin(angle),
					{
						facing: facing,
						_parent_obj: me,
						velocity_x: (50 * cos(angle)) + 1d100-50 + me.velocity_x*0.2,
						velocity_y: (50 * sin(angle)) + 1d100-50 + me.velocity_y*0.2,
					}),
					add(me.velocity_x, 3400 * cos(angle)),
					add(me.velocity_y, 3400 * sin(angle)),
					
					map(range(20), schedule(index * 2, 
						; spawn('frogatto_playable.ink_fragment',
							mid_x - 20 * cos(angle),
							mid_y - 20 * sin(angle),
							{
								facing: facing,
								velocity_x: -(350 * cos(angle)) + 1d300-150 + me.velocity_x*0.2,
								velocity_y: -(350 * sin(angle)) + 1d300-150 + me.velocity_y*0.2,
							}),
						)
					),
				]
		)",
	shoot_fire_blob: "commands :: use_underwater_attack(
			enum item_underwater_fire_attack,
			def(decimal angle) -> commands
				map(target_angles, 
					[
						lib.sound.play_sound(me, 'bubble-blow'),
						spawn('frogatto_playable.underwater_fire_blob_shot',
							mid_x + 20 * cos(value),
							mid_y + 20 * sin(value),
						{
							facing: facing,
							_parent_obj: me,
							velocity_x: 400*cos(value) + 1d100-50 + me.velocity_x,
							velocity_y: 400*sin(value) + 1d100-50 + me.velocity_y,
						})
					]
				)
				
				where target_angles = [angle - (10 + 1d5), angle, angle + (10 + 1d5)]
		)",

	shoot_underwater_shock_attack: "commands :: use_underwater_attack(
			enum item_underwater_energy_shock_attack,
			def(decimal angle) -> commands
				[
					map(
						filter(
							filter(level.active_chars, value is obj movable_enemy),
							lib.math.length( value, level.player) < 500
						),
						value.convert_to_thrown_variant
					),
			
					map(points_lists,
						spawn_bolts(value)
					)
	
						where spawn_bolts = def([{x: decimal, y: decimal}] bolts) -> commands
							map( range(size(bolts)-1),
									schedule(index * 2,
										spawn('rope_angled_controller',
											current_point.x,
											current_point.y,
										{
											x_1: current_point.x,
											y_1: current_point.y,
											x_2: next_point.x,
											y_2: next_point.y,
											animation: 'lightning'
										},[
											schedule(index*4 + 10, remove_object(child))
										])
									)
							
									where current_point = ({x: decimal, y: decimal} <- bolts[index])
									where next_point = ({x: decimal, y: decimal} <- bolts[index+1])
							)
					
	
						where points_lists =
						map(range( ring_length ),
							bolt_iter(value, index)
						)
							where bolt_iter = def(int ring_value, int ring_index) -> [{x: decimal, y: decimal}] (
		
								map(range( bolt_length ),
										lib.math.random_radial_pos({
															min_angle: ring_index * 360/ring_length,
															max_angle: (ring_index + 1) * 360/ring_length,
															angle_delta_scale: 1.0,
															origin: {x: mid_x, y: mid_y},
															min_length: (index - 1) * 90,
															max_length: index * 90
														})
						
					
								)    
							)
					where ring_length = 3
					where bolt_length = 3 + 1d2
				]
			)",





		#####-- Fingerpoint Attacks --#####
	use_ability_with_fingerpoint_anim: "def(InventoryItemType ability_name, function(decimal)->commands shot_commands) -> commands
		if(ability_is_charged_up(ability_name) and (not animation in fingerpoint_attack_anim_list),
			[
				schedule(1,animation(fingerpoint_attack_anim)),
				shot_commands(quantized_shot_angle),
				fingerpoint_attack_spawn_head(),
				use_mana_for_ability(ability_name)
			]
		)",

	shoot_fire_shot: "commands :: use_ability_with_fingerpoint_anim(
									enum item_fire_shot_talisman,
									def(decimal angle) -> commands
										spawn('${self.type}.fire_shot_arc', mid_x + 45*facing*cos(angle), mid_y + 40*sin(angle), {
											facing: facing,
											velocity_x: velocity_x/4 + 1000 * cos(angle) * facing,
											velocity_y: velocity_y/4 + 1000 * sin(angle) - 200
										})
								)",



	shoot_energy_shot: "commands :: use_ability_with_fingerpoint_anim(
										enum item_energy_shot_talisman,
										def(decimal angle) -> commands
											spawn('${self.type}.energyshot', mid_x + 45*facing*cos(angle), mid_y + 40*sin(angle), {
												facing: facing,
												velocity_x: (velocity_x/4 + core_speed * cos(angle) * facing),
												velocity_y: (velocity_y/4 + core_speed * sin(angle)),
												incept_angle: angle - 180,
											})
									) where core_speed = 2000",



	shoot_acid_shot: "commands :: use_ability_with_fingerpoint_anim(
										enum item_acid_shot_talisman,
										def(decimal angle) -> commands
											spawn('${self.type}.acidshot', mid_x + 45*facing*cos(angle), mid_y + 40*sin(angle), {
												facing: facing,
												velocity_x: ( core_speed * cos(angle) * facing),
												velocity_y: ( core_speed * sin(angle)),
												rotate: if(facing = 1, angle, -angle),
											})
									) where core_speed = 300",



	shoot_homing_shot: "commands :: use_ability_with_fingerpoint_anim(
										enum item_homing_shot_talisman,
										def(decimal angle) -> commands
											spawn('${self.type}.homingshot', mid_x + 45*facing*cos(angle), mid_y + 40*sin(angle), {
												facing: facing,
												velocity_x: velocity_x/4 + 2000 * cos(angle) * facing,
												velocity_y: velocity_y/4 + 2000 * sin(angle)
											})
									)",




		#####-- Breath Attacks --#####
	use_ability_with_breath_anim: "def(InventoryItemType ability_name, string anim_prefix, commands shot_commands) -> commands	[
			if(		(not (is_breath_ability_active(ability_name, anim_prefix))) and
					(not animation in ['enter_crouch', 'crouch']) and
					ability_is_charged_up(ability_name),
				set(animation, anim_prefix + '_begin')
			),
			breath_attack_internal
		]
		
		where breath_attack_internal = if( ability_is_charged_up(ability_name) and animation in [anim_prefix + '_begin', anim_prefix + '_cycle', anim_prefix + '_end'], 
			[
				shot_commands,
				use_mana_for_ability(ability_name),
				if(cycle >= (last_played_fire_sfx + 12) or last_played_fire_sfx = null, [
					lib.sound.play_sound(me,'firebreath'),
					set(last_played_fire_sfx,cycle)
				])
			])
	",		

	is_breath_ability_active: "def(InventoryItemType ability_name, string anim_prefix) -> bool 
									ctrl_tongue_counter > 1 and
									(not animation in ['enter_crouch', 'crouch']) and
									ability_is_charged_up(ability_name) and
									(animation in [anim_prefix + '_begin', anim_prefix + '_cycle', anim_prefix + '_end'])
								",

	
	shoot_ice_corona: "commands :: use_ability_with_breath_anim(
										enum item_ice_corona_talisman,
										'acidbreath',
										spawn('frogatto_playable.ice_corona_shot',
											mid_x + 1d10  *facing,
											mid_y+4,
										{
											facing: facing,
											velocity_x: 0,
											velocity_y: 0
										}),
									)",
										
	shoot_acid: "commands :: use_ability_with_breath_anim(
										enum item_acid_breath_talisman,
										'acidbreath',
										spawn('frogatto_playable.acid_shot',
											mid_x + 1d10 * facing,
											mid_y+4,
										{
											facing: facing,
											_parent_obj: me, 
											velocity_x: (500+1d150)*facing,
											velocity_y: 1d400-250
										}),
									)",

	shoot_fire: "commands :: use_ability_with_breath_anim(
										enum item_fire_breath_talisman,
										'firebreath',
										spawn('${self.type}.fire_shot',
											mid_x + 1d10 * facing,
											mid_y + 0 + 1d18-9,
										{
											facing: 1, 
											rotate: shot_angle,
											velocity_x: shot_speed * ang.x,
											velocity_y: shot_speed * ang.y,
										}),
									)	where ang = unit_triangle_xy_components_for_angle(shot_angle)
										where shot_angle = 1d30 - 15 + if(facing = 1, 0, 180)
										where shot_speed = 1500 + 1d250
							",





		#-- Spat Attacks --#
	is_currently_fat: "bool :: 'fat' in variations",
	become_fat: "add(variations, ['fat'])",

	super_fireball_fire_projectile: "commands :: spawn('${self.type}.super_fireball', mid_x + 45*facing, mid_y, facing, [set(child.velocity_x, velocity_x/4 + 800 * cos(angle) * facing), set(child.velocity_y, velocity_y/4 + 800 * sin(angle))]) where angle = 0",

	super_fire_explosion_trigger: "commands :: [
										spawn('frogatto_playable.super_fire_attack', mid_x, mid_y, 1),
										screen_flash([255,255,255,255], [0,0,0,-3], 85),
									]",

	super_energyshot_fire_projectile: "commands :: spawn('${self.type}.super_energyshot', mid_x + 5*facing, mid_y, facing, [set(child.velocity_x, 300 * cos(angle) * facing), set(child.velocity_y, 300 * sin(angle))]) where angle = 0",

	super_homingshot_fire_projectile: "commands :: spawn('${self.type}.super_homingshot', mid_x, mid_y, facing)",

	super_acidshot_fire_projectile: "commands :: spawn('${self.type}.super_acidshot', mid_x, mid_y, facing)",

	shoot_spit_attack: "commands :: if(not animation = 'spit', [animation('spit'), schedule(8, spit_attack_spew_projectile)])",
	
	empty_stomach: "def({kill_contents: bool} p) -> commands 
				[
					set(variations, []),
					if(underwater, set(has_feet, false)),
					
					if(p.kill_contents, [
						set(swallowed_object.mid_xy, level.player.mid_xy),
						swallowed_object.force_death(enum none)
					]),
					set(swallowed_object, null),
				] asserting swallowed_object is obj throwable | {message:q(swallowed_object is allowed to be null most of the time, but we definitely want a runtime error if we're ever trying to empty the player's stomach, and we've somehow managed to get in a state where there's actually nothing in there.)}",

	fill_stomach_with_new_ammo: "def(string obj_name) ->commands [
		fill_stomach(new_obj, enum with_swallow_anim)
		where new_obj = obj throwable<- object(obj_name, 0, 0, 1)
	]",
	
	fill_stomach: "def(obj throwable swallowed_obj, enum {with_swallow_anim, without_swallow_anim} should_animate) -> commands [
		set(swallowed_object, swallowed_obj),
		become_fat,
		if(should_animate = enum with_swallow_anim,
			fire_event(me,'end_attack_anim'),
		)
	]",
	
	spit_attack_spew_projectile: "commands :: 
			if(swallowed_object,
				[if(not is_super_attack_completely_viable_besides_mana_and_cooldowns,
					standard_spit_attack,
					switch( current_super_ability,
						enum item_super_fire_pendant, if(ability_is_charged_up(enum item_super_fire_pendant),
										[super_fire_explosion_trigger, use_mana_for_ability(enum item_super_fire_pendant), set(swallowed_object, null), do_sound, empty_stomach({kill_contents: true})],
										standard_spit_attack),
						enum item_super_energy_pendant, if(ability_is_charged_up(enum item_super_energy_pendant),
										[super_energyshot_fire_projectile, use_mana_for_ability(enum item_super_energy_pendant), set(swallowed_object, null), do_sound, empty_stomach({kill_contents: true})],
										standard_spit_attack),
						enum item_super_arcane_pendant, if(ability_is_charged_up(enum item_super_arcane_pendant),
										[super_homingshot_fire_projectile, use_mana_for_ability(enum item_super_arcane_pendant), set(swallowed_object, null), do_sound, empty_stomach({kill_contents: true})],
										standard_spit_attack),
						enum item_super_acid_pendant, if(ability_is_charged_up(enum item_super_acid_pendant),
										[super_acidshot_fire_projectile, use_mana_for_ability(enum item_super_acid_pendant), set(swallowed_object, null), do_sound, empty_stomach({kill_contents: true})],
										standard_spit_attack),
						enum item_tongue, standard_spit_attack))
			
						where standard_spit_attack = [
							lib.sound.play_sound(me, 'frogatto-spit'),
				
							set(green, 255), set(blue, 255),
							add(gravity_shift, -swallowed_object.carry_gravity),
							
							/*
								set the momentum of the spat projectile 
							*/
							set(swallowed_object.velocity_x,
								if(swallowed_object.ignores_player_momentum,
									facing * spit_power * 14,
									velocity_x + facing * swallowed_object.thrown_vel_x( ctrl_down, ctrl_up, spit_power )
								),
							),
							set(swallowed_object.velocity_y,
								if(swallowed_object.ignores_player_momentum,
									0,
									velocity_y - swallowed_object.thrown_vel_y( ctrl_down, ctrl_up, spit_power )
								)
							),
							readd_attaches(swallowed_object),
						
							set(swallowed_object, null),
			
							/*
								set the enemy to be in the thrown dimension, meaning it will only collide with the level. If it collides with another object, it should pass through that object in terms of solidity (any collision should actually be handled by body/attack areas, and most likely we expect it to die).
							*/
							set(swallowed_object.solid_dimensions_in, ['thrown']),
							swallowed_object.set_to_animation('thrown'),
			
							set(swallowed_object.midpoint_x, midpoint_x),
							if(swallowed_object.ignores_player_momentum,
								set(swallowed_object.midpoint_y, midpoint_y),
								set(swallowed_object.midpoint_y, midpoint_y - if(is_standing, 2, 22*sign(-velocity_y))),
							),
							resolve_solid(swallowed_object, -facing, 0, 150),
							resolve_solid(swallowed_object, facing, 0, 150),
							
							/*
								do a really quick-and-dirty test to see if there's something solid in front of us; we 'fast forward' the position of the spat object to be in front of frogatto if we're running really fast, so that it doesn't spawn behind us, but if we're barreling into a gate, we actually run a risk of launching a spat object through it (or really any other sufficiently slim barrier)
							*/
							if(not 
								(
									point_solid(level, me, if(facing > 0, solid_rect.x2+15, solid_rect.x-15), mid_y) or
									point_solid(level, me, if(facing > 0, solid_rect.x2+30, solid_rect.x-30), mid_y) or
									point_solid(level, me, if(facing > 0, solid_rect.x2+45, solid_rect.x-45), mid_y) or
									point_solid(level, me, if(facing > 0, solid_rect.x2+60, solid_rect.x-60), mid_y) or
									point_solid(level, me, if(facing > 0, solid_rect.x2+75, solid_rect.x-75), mid_y) or
									point_solid(level, me, if(facing > 0, solid_rect.x2+90, solid_rect.x-90), mid_y) 
								),
								add(swallowed_object.mid_x, velocity_x/10)
							),
							
			
							add_object(swallowed_object),

							fire_event(swallowed_object, 'spat'),
							empty_stomach({kill_contents: false}),
							

							map(filter(level.active_chars, value is obj standing_npc), if(can_see(me,value), commands<- eval(value.consider_object, {me: value, obj: swallowed_object, level: level}))),
						],
				  set(current_ability, enum item_tongue)]) where do_sound = lib.sound.play_sound(me, 'uber-belch'
			)",


#-------------------------- item management --------------------------#
	do_key_check: "commands :: if(swallowed_object is obj padlock_key, if( size(swallowed_object.valid_levels) > 0, if(not level.id in swallowed_object.valid_levels, 
						[transient_speech_dialog(250, level.player, [~I better put this key back where it came from.~]),
							empty_stomach({kill_contents: true})]
					)))",

#-------------------------- movement commands --------------------------#
		
	should_be_standing: "bool <- self.animation in ['stand', 'run', 'walk', 'land', 'lookup', 'crouch', 'enter_crouch', 'leave_crouch', 'turn','turn_whilst_running', 'roll','skid']",
	
	set_facing: "def(int direction) -> commands
		if(self.facing != direction and (not (self.animation in ['interact', 'slide','turn','turn_whilst_running'])), [
			facing(direction),
			if(self.is_standing, animation('turn')),
			set(_last_turned, cycle)
		])",
	_last_turned: { type: "int", default: -10 },

		
	on_end_turn_whilst_running_anim: "[animation('run'), set(time_in_animation, 2*6)]",
	
	resume_standing_or_walking: "if(ctrl_left or ctrl_right, [if(ctrl_left, start_moving(-1)), if(ctrl_right, start_moving(1))], start_standing)",
		
	start_standing: "commands :: 
		if((abs(self.velocity_x)) > 750 and (not self.animation in ['walk']), [animation('skid'),set(accel_x,500)],
			if(not self.animation in ['stand'], animation('stand'))
		)",
	
	//sets rotation based on frogatto's relative velocity.  This tries to make frogatto tilt forward/backward if he's jumping with a lot of velocity behind him.  Has a factor which tries to dampen it markedly if the x_velocity is low, so if frogatto's jumping straight up and down, he doesn't wobble back and forth wildly.
	set_aerial_rotation: "def(decimal coefficient) -> commands set(rotate,coefficient*magnitude*angle/4.0) where angle = atan(decimal(velocity_y)/(velocity_x)) where magnitude = min(1.0,decimal(abs(velocity_x)*1.5)/sqrt(velocity_x^2 + velocity_y^2))",
	
	should_roll: "bool :: (cycle - last_landed_hard < 24)",
	should_continue_roll: "def(int dir) -> bool (animation = 'roll') and ((cycle - last_landed_hard < 12) or ((dir = 1 and ctrl_right) or (dir = -1 and ctrl_left)))",	

	should_be_in_a_swim_animation: "bool :: (not is_currently_fat) and underwater and (not _tongue_tip)",	

	start_moving:	//only for tracking movement keypresses, NOT for any actual gameplay logic
									"def(int dir) -> commands [if(not should_be_in_a_swim_animation, set_facing(dir)), 
										if((last_pressed(dir) and last_pressed(dir) > cycle - 15 or is_running = true) and (currently_speaking_to = null), [
											process_movement_internal(-1, 'run'),
											set(is_running, true),
										]),
										
										if(dir = 1, [set(ctrl_right_counter, cycle),set(ctrl_left_counter, 0)]),
										if(dir = -1, [set(ctrl_left_counter, cycle),set(ctrl_right_counter, 0)])
	
									] where last_pressed = def(dir) switch(dir,
																		1, ctrl_right_counter,
																		-1, ctrl_left_counter,
																		0)",
	
	process_movement: "def(int direction) -> commands [if(should_roll, process_movement_internal(direction, 'roll'),
											if(is_running, process_movement_internal(direction, 'run'), process_movement_internal(direction, 'walk')))]",

	process_movement_internal: //gameplay logic and animation logic for movement
	"def(int dir, string anim) -> commands
		if( should_be_in_a_swim_animation,
			//frogatto's underwater, so make him swim
			[
				if(TOUCH_SCREEN, [
					swim(ctrl_x, ctrl_y),
					if((not ctrl_x) and (not ctrl_y), tread_water),
					if(ctrl_x < 0 and facing > 0 or ctrl_x > 0 and facing < 0, set(facing, -facing)),
				],[
					swim(
						(int(ctrl_right) - int(ctrl_left))*if(ctrl_down or ctrl_up, swim_accel_diag, swim_accel), 
						(int(ctrl_down) - int(ctrl_up))*if(ctrl_left or ctrl_right, swim_accel_diag, swim_accel) ),
					if((not (ctrl_left or ctrl_right or ctrl_up or ctrl_down)) and animation in ['swim_side','swim_up','swim_down'],
						tread_water),
				])
			],

			//frogatto's on land, so choose between whatever land motion is appropriate
			if(self.is_standing and dir != 0, [
				switch(anim,  //things that should happen every frame
					'walk', 	[set(accel_x, walk_accel), try_to_switch_out_of_turn_anims_to_this_anim('walk')],
					'run', [set(accel_x, run_accel), [if(animation = 'walk', set(animation, 'run')), try_to_switch_out_of_turn_anims_to_this_anim('run')]],
					'roll', set(accel_x, roll_accel) ) 
						where try_to_switch_out_of_turn_anims_to_this_anim = def(string new_anim) -> commands if(animation = 'turn_whilst_running' and time_in_animation >= 14, [set(animation, new_anim),set(time_in_animation,12)]),
					
				if(animation in uninterruptible_animations, set(accel_x, 0)),
				if((not should_roll) and (animation = 'roll'), animation(anim)),
	
				//things that should only happen when the move begins
				if((not self.animation in ['stand_to_walk','walk', 'run', 'roll', 'start_jump', 'jump', 'fall', 'turn_whilst_running'] + uninterruptible_animations ), [
					switch(anim,
						'walk', animation('stand_to_walk'),
						'run', if(cycle - _last_turned < 20, animation('turn_whilst_running'), animation(anim)),
						animation(anim)),
                    if(anim = 'roll', if((cycle - last_landed_hard < 2), lib.sound.play_sound(me, 'frogatto-fall-roll', { volume: 0.5 }))),
					if(anim = 'run', lib.sound.play_sound(me, 'runSoft')),
				])
			],
			
			//Frogatto is in the air, so make him glide.
			if( (not (self.is_standing or self.animation in ['slide', 'swim_up', 'swim_down', 'swim_side'])) and dir != 0,
				add(self.velocity_x, jump_glide*dir))
		))",
	
	stop_moving: "commands :: if(not should_continue_roll(facing), [set(is_running, false), if((not (ctrl_left or ctrl_right)) and animation in ['stand_to_walk','walk', 'run', 'roll', 'turn_whilst_running'], start_standing)])",
	
	//Function to attempt to make Frogatto crouch; does checking to make
	//sure he's in a state that allows entering a crouch.
	crouch: "def() -> commands
		if((not self.animation in uninterruptible_animations ) and self.is_standing, 
			animation('enter_crouch'))",
		
	//function to decide if frogatto can slide down a wall
	can_slide: "bool <- bool(
		(not is_currently_fat)
		and point_solid(level, me, if(facing > 0, solid_rect.x2+1, solid_rect.x-1), (solid_rect.y + solid_rect.y2*2)/3)
		and (velocity_y < 300 and velocity_y > -1000 or ctrl_jump and pressed_jump_in_air) )",
		

		
#-------------------------- swimming --------------------------#
	continue_swim: "animation(animation)",
	  		
	swim: "def(decimal dirx, decimal diry) -> commands
		if(dirx or diry, [
			do_swim_cosmetics,
			update_swim_rotation_cosmetic(dirx, diry),
			add(self.velocity_x, (swim_accel*dirx)/1000.0),
			add(self.velocity_y, (swim_accel*diry)/1000.0),
		]) where swim_accel = 140 * accel_fraction
		
				/*
					To deal with a weird mechanical issue, we've implemented the following:
					Without this, the moment you try to adjust your facing you'll also be forced to move at least a tile or two in the given direction, and this was really frustrating because you'd frequently try to turn to shoot at something right in front of you (such as a stationary or stunned enemy), but this would get you hit by them. It was very frustrating.
					
					Without having to gut/rewrite the system, we wanted to give the player a way to make major adjustments to their facing without having to move.  What we've come up with is piping the player's attempts to accelerate through an easing function - the closer you are to the intended direction, the faster you'll move, but - nonlinearly so.
				*/
			where accel_fraction =	abs(
										lib.math.ease_in_cubic(
											(
												180 -
												abs(full_angular_distance_to_target_angle(swim_controls_angle(dirx,diry)))
											)/180.0
										)
									)",

	tread_water: "commands :: [
		if(not is_currently_fat, [
			set(has_feet, false),
			if(TOUCH_SCREEN, set(underwater_controls, underwater)),
			do_tread_water_cosmetics,
			update_swim_rotation_cosmetic(0, 0)
		])
	]",

	nearest_swimming_angle: "def(decimal angle) -> int choose( map(range(0,9), value*45), 360 - abs(value-angle))",


	
	swim_motion_angle: "decimal :: edge_case( invert( min( atan2( velocity_x,velocity_y) + 180, 360.00 ) ) )
								where invert = def(decimal val) -(val - 360)
								where edge_case = def(decimal val) if(facing = -1 and val < 0.02, 360, val) ",
	
	/*
		this is used primarily for setting the 'rest angle' the player will try to point at when some keys are pressed.
	*/
	swim_controls_angle: "def(decimal dirx, decimal diry) -> decimal edge_case(switch([sign(dirx),sign(diry)],
									[ 0, -1],	0,
									[ 1, -1],	45,
									[ 1,  0],	90,
									[ 1,  1],	135,
									[ 0,  1],	180,
									[-1,  1],	225,
									[-1,  0],	270,
									[-1, -1],	315,
												90
								)) where edge_case = def(decimal val) if(facing = -1 and val < 0.02, 360, val)",
	
	nearest_swim_animation_suffix: "string :: switch(nearest_swimming_angle(swim_rotation_cosmetic),
									0,		'_up',
									45,		'_up_diag',
									90,		'_side',
									135,	'_down_diag',
									180,	'_down',
									225,	'_down_diag',
									270,	'_side',
									315,	'_up_diag',
									360,	'_up'
								)",
	
	swim_animation_prefix: "'swim'",
	tread_water_animation_prefix: "'tread_water'",
//	swim_debug: "debug(swim_rotation_cosmetic, swim_motion_angle, full_angular_distance_to_target_angle*0.05, fractional_swim_turn_speed)",
	fractional_swim_turn_speed: "20.0 * lib.math.constrain(0.3, current_swim_speed / max_swim_speed, 1.0)
								where max_swim_speed = 300.0
								where current_swim_speed = lib.math.length(velocity_x, velocity_y)
	",
	
	swim_rotation_offset: "decimal ::  (1) * (swim_rotation_cosmetic) - nearest_swimming_angle(swim_rotation_cosmetic)
			where faux_facing = if((swim_motion_angle > 180 and facing = -1) or (swim_motion_angle < 180 and facing = 1), 1, -1)",
		
	do_swim_cosmetics: "commands :: [
			//swim_debug,
			set(facing, desired_swim_facing) where desired_swim_facing = if(swim_rotation_cosmetic > 180,-1,1),
			set(animation, swim_animation_prefix + nearest_swim_animation_suffix),
			set(time_in_animation, time_in_animation),
			set(rotate, swim_rotation_offset)
	]",
	
	do_tread_water_cosmetics: "commands :: [
			//swim_debug,
			set(facing, desired_swim_facing) where desired_swim_facing = if(swim_rotation_cosmetic > 180,-1,1),
			set(animation, tread_water_animation_prefix + nearest_swim_animation_suffix),
			set(time_in_animation, time_in_animation),
			set(rotate, swim_rotation_offset)
	]",

	swim_rotation_cosmetic: { type: "decimal", default: 0.0 },
	
	update_swim_rotation_cosmetic: "def(decimal dirx, decimal diry) -> commands
										if(ctrl_up or ctrl_down or ctrl_right or ctrl_left, _update_swim_rotation_cosmetic(dirx,diry))",
	_update_swim_rotation_cosmetic: "def(decimal dirx, decimal diry) -> commands if( abs( turn_speed ) > 0.25,
													set(swim_rotation_cosmetic, lib.math.decimal_mod( swim_rotation_cosmetic + turn_speed, 360)),
													set(swim_rotation_cosmetic, swim_controls_angle(dirx,diry))
							)	where turn_speed = lib.math.constrain(-fractional_swim_turn_speed, turn_amount * 0.10, fractional_swim_turn_speed)
								where turn_amount = (full_angular_distance_to_target_angle(swim_controls_angle(dirx,diry)))
							",

	full_angular_distance_to_target_angle: "def(decimal target) -> decimal lib.math.decimal_mod((target-start) + 180.0, 360) - 180.0
												where start = swim_rotation_cosmetic",
	
#-------------------------- gui / hud --------------------------#
	/*
		27 is often seen as a 'magic number' in these calcs.  It's half the height/width of the 'gear icon', which is the default icon for an object without an assigned image.
	*/
	gui_heart_display: {
		type: "obj heart_display", 
		init: "object('heart_display', {mid_x: 18 + 108, mid_y: 24})",
		persistent: false,
	},
	gui_ability_display: {
		type: "obj ability_display", 
		init: "object('ability_display', 0, 0, {x:-0,y:-0})",
		persistent: false,
	},
	gui_secondary_ability_display: {
		type: "obj ability_secondary_display", 
		init: "object('ability_secondary_display', 0, 0, {x:0, y:98})",
		persistent: false,
	},
	gui_death_indicator_display: {
		type: "obj death_indicator_display", 
		init: "object('death_indicator_display', 0, 0, {x:screen_w - 20*2,y:0}) where screen_w = level.window_size[0]",
		persistent: false,
	},
	gui_mana_display: {
		type: "obj mana_display", 
		init: "object('mana_display', 27+26, 27 + 96 + if(should_display_secondary_abilities, 98, 0), {})", //<- this won't work anytime after the initial frame.
		persistent: false,
	},
	gui_boss_progress_display: {
		type: "obj boss_progress_display", 
		init: "object('boss_progress_display', 0, level.window_size[1] - 27 /*gear icon center*/ - 10 /*margin*/, {})",
		persistent: false,
	},
	gui_gold_display: {
		type: "obj hud_gold_display", 
		init: "object('hud_gold_display', 0, 0, {x:screen_w - 66*2,y:50}) where screen_w = level.window_size[0]",
		persistent: false,
	},
	
		// deprecated components {
	gui_coins_display: {
		type: "obj number_display", 
		init: "object('number_display', 27+48+8, 27+10+2, {field: 'coins', prefix: ~$~})", //8, center the text a bit, not in the original ui. Rest is magic centering numbers.
		persistent: false,
	},
	gui_score_display: {
		type: "obj number_display", 
		init: "object('number_display', 27+48+8, 27+10+2, {field: 'score', prefix: ~score: ~})",
		persistent: false,
	},
	gui_highest_score_display: {
		type: "obj number_display", 
		init: "object('number_display', 27+48+80, 27+10+2, {field: 'high_score', prefix: ~best: ~})",
		persistent: false,
	},
		// } deprecated components
	
	set_up_gui: "commands :: [
		tear_down_gui, //The set-up event is fired twice in some cases. In that case; simply resetup the gui.
		;
		map(components.default + if(TOUCH_SCREEN, components[control_scheme], []),
			'gui_element', [
				remove_object(gui_element), //We don't want duplicate gui objects. Since it's very hard to only fire setup once, we'll just remove any objects that find their way into the level twice. Note - this won't work if the event is called twice in the same event handler, but it will work fine if called in different event handlers.
				add_object(gui_element),
			]
		) where components = {
			default:
				default_hud_components
				+
				if(should_display_secondary_abilities, [gui_secondary_ability_display], [])
				+
				if(not not find(level.active_chars, value.type in ['level_controller_neverending', 'level_controller_neverending_vertical']), //Test if we're on a score-based arcade level.
					[gui_score_display, gui_highest_score_display], //Arcade displays score/best score,
					[/*gui_coins_display*/]), //but normal play used to replace this with the old coin indicator, which took up the same real estate on the screen.  We kept the coin indicator on the coin arcade level.
			ipad_2d: [/*mobile controls here*/],
			iphone_2d: [],
		},
		;
		set(gui_mana_display.mid_xy, [
			27 + 26,
			27 + 96 + if(should_display_secondary_abilities, 98, 0)
		]),
	]",
	
	should_display_secondary_abilities: "bool :: size(secondary_item_list) > 0",

	default_hud_components: "[
		gui_gold_display,
		gui_heart_display,
		gui_ability_display,
		gui_mana_display,
		gui_boss_progress_display,
		gui_death_indicator_display
	]",

		
	tear_down_gui: "commands ::
		[
			map(default_hud_components + [gui_secondary_ability_display],
				remove_object(value)
			)
		]
	", 

	fade_out_hud: "[
		[
			animate(c, { alpha_proxy: 0, scale: 1.0/(level.zoom * 2) }, { duration: 10, easing: lib.math.ease_in_out_cubic }) 
			| c <- level.chars, (c is obj hud_component and (not c.type in hud_types_omitted_from_scaling))
		],
		[
			animate(c, { alpha_proxy: 0 }, { duration: 5, easing: lib.math.ease_in_out_cubic }) 
			| c <- level.chars, (c is obj hud_component and (c.type in hud_types_omitted_from_scaling))
		],
		
	]",

	instantly_hide_or_show_hud: "if(should_display_hud_now, 
		instantly_show_hud,
		instantly_hide_hud
	)",
	
	should_display_hud_now: "(level.zoom_current = 1) and (not level.in_dialog) and (not level.id in [
		'titlescreen.cfg',
		'titlescreen-new-game-selector.cfg',
		'inventory-screen.cfg',
		'main-map.cfg',
		'titlescreen-arcade.cfg',
		'titlescreen-load-game-selector.cfg',
		'tea-with-milgram.cfg',
	])",
	
	instantly_hide_hud: "[
		[
			[set(c.alpha_proxy, 0), set(c.scale, 0)]
			| c <- level.chars, (c is obj hud_component and (not c.type in hud_types_omitted_from_scaling))
		],
		[
			[set(c.alpha_proxy, 0)]
			| c <- level.chars, (c is obj hud_component and (c.type in hud_types_omitted_from_scaling))
		],
	]",
	
	
	fade_in_hud:  "commands :: [
		[
			animate(c, { alpha_proxy: 255, scale: 1 }, { duration: 20, easing: lib.math.ease_in_out_cubic }) 
			| c <- level.chars, (c is obj hud_component and (not c.type in hud_types_omitted_from_scaling))
		],
		[
			animate(c, { alpha_proxy: 255 }, { duration: 20, easing: lib.math.ease_in_out_cubic }) 
			| c <- level.chars, (c is obj hud_component and (c.type in hud_types_omitted_from_scaling))
		],
	]",
	
	instantly_show_hud:  "commands :: [
		[
			[set(c.alpha_proxy, 255), set(c.scale, 1)]
			| c <- level.chars, (c is obj hud_component and (not c.type in hud_types_omitted_from_scaling))
		],
		[
			[set(c.alpha_proxy, 255)]
			| c <- level.chars, (c is obj hud_component and (c.type in hud_types_omitted_from_scaling))
		],
	]",


	hud_types_omitted_from_scaling: "[string] :: [
		'mana_display.bar_container_overlay',
		'mana_display.bar_container',
		'mana_display.bar_center',
		'mana_display.bar_center',
		'mana_display.bar_center',
		'gui_boss_progress_display',
	]",

#-------------------------- death-tracking --------------------------#

	/*
		This value is also stored in the `globals` storage; we're in an awkward place with this because we want something neither `globals` nor `registry` provide; we want something where the value *will* persist (which `globals` doesn't), but something where the value is unique to this playthrough (which `registry` isn't).  So basically we take a value that's stored in `globals` (which means it's non-persistent-to-disk, but will persist after death), and copy it into this object's storage to make it persist to disk, persist after the player's death, but only do so for this unique playthrough.
		
		There are two situations where these values would fall out of synch:
		1] is when the game is loaded from a save.  At that point, these values *in frogatto himself* would be correctly populated, but the `globals` value would not be populated.
		2] the other is when frogatto respawns from such a death; the globals would be correctly populated, but frogatto himself would not have these values anymore.

		Our goal with these functions is to forcibly put these values in synch.
	*/

	initialize_death_tracking_storage: "commands :: [
		/*
			This should only ever be run at the titlescreen.  This is meant to guard against one weird corner case:  the player dies during a playthrough (setting the player_has_died_since_last_unique_checkpoint to true), and starts a new playthrough.  The existing code would treat that as a triggering of loading the level from a save, causing it to populate the local storage with what's in the globals.  Instead, we want to nuke what's in the globals.
		*/
		set(globals.last_unique_checkpoint_label, null),
		set(globals.last_unique_checkpoint_level_name, null),
		set(globals.player_has_died_since_last_unique_checkpoint, null),
		
		set(me.last_unique_checkpoint_label, null),
		set(me.last_unique_checkpoint_level_name, null),
		set(me.player_has_died_since_last_unique_checkpoint, null)
	]",

	validate_death_tracking_storage: "commands :: [
		/*
			If both the global *and* local values are null (i.e. we're checking this for the absolute first time, at the titlescreen), then it's still safe to run this.  They will simply remain null.  They will get the correct behavior the first time the player dies, and the first time the player hits a checkpoint.
		*/
		validate_local_death_tracking_storage,
		; validate_global_death_tracking_storage,
	]",

		/*
			When you load the game from a save, you'll have a situation where:  the value in our local variable is correct, but the value in `globals` is null.
			Remember - `globals` doesn't get persisted to disk, which is the only reason we put it in our local variables.
			This function gets run when the game's loaded from a save, to re-establish that global value.
		*/
	validate_global_death_tracking_storage: "commands :: [
		if(globals.player_has_died_since_last_unique_checkpoint = null,
			set(globals.player_has_died_since_last_unique_checkpoint, me.player_has_died_since_last_unique_checkpoint)
		),
		if(globals.last_unique_checkpoint_label = null,
			set(globals.last_unique_checkpoint_label, me.last_unique_checkpoint_label)
		),
		if(globals.last_unique_checkpoint_level_name = null,
			set(globals.last_unique_checkpoint_level_name, me.last_unique_checkpoint_level_name)
		)
	]",

		/*
			When you die in-game, you'll have a situation where:  the value in `globals` is correct, but the local variable is null.
			This function gets run when the player respawns, to re-establish that local value.
		*/
	validate_local_death_tracking_storage: "commands :: [
		if(globals.player_has_died_since_last_unique_checkpoint != null,
			set(me.player_has_died_since_last_unique_checkpoint, (bool <- globals.player_has_died_since_last_unique_checkpoint))
		),
		if(globals.last_unique_checkpoint_label != null,
			set(me.last_unique_checkpoint_label, (string <- globals.last_unique_checkpoint_label))
		),
		if(globals.last_unique_checkpoint_level_name != null,
			set(me.last_unique_checkpoint_level_name, (string <- globals.last_unique_checkpoint_level_name))
		)
	]",

	sanitized_player_has_died_since_last_unique_checkpoint: "bool :: if(me.player_has_died_since_last_unique_checkpoint != null,
																me.player_has_died_since_last_unique_checkpoint,
																false
															)",

#-------------------------- constants --------------------------#
		
	light_radius:		"60",
	jump_power:			"1200",
	jump_boost:			"90",
	jump_glide: 		"if(not is_currently_fat, 30, 20)",
	
	walk_accel:			"1280",
	roll_accel:			"1760",
	run_accel:			"2240",
	swim_accel:			"800",
	swim_accel_diag: 	"565.6",  //this is swim_accel/sqrt(2), by the pythagorean relation
	
	tongue_length: "int <- 8 + number_of_item(enum item_tongue_extension)*4",
	tongue_duration: "int <- 24",
	spit_power: "65",
	posthit_invicibility_period: "if(higher_difficulty, 50, 80)",
	
	jump_out_of_water_boost: "1120",
	jump_out_of_water_boost_horizontal: "160",
	
	
#-------------------------- vars --------------------------#
		#-- player state --#
	
	swallowed_object: { type: "obj throwable|null", default: null},
	
	
		#-- items and achievements --#
	enemies_seen: { type: "{string -> bool}", default: {} }, //A running tally of what kinds of enemies we've seen. Used for the inventory screen.
	enemies_tasted: { type: "{string -> bool}", default: {} }, //A running tally of what kinds of enemies we have tasted. Used for the Frogourmet achivement and the inventory screen's 'taste' field.

	name: "'Frogatto'",  //intended for use in dialogues; if we need to do string substitution at some point when we have multiple characters
	
	_jump_cheat: { type: "bool", default: false },

	position_predictor: { type: "class predictive_player_motion", init: "construct('predictive_player_motion',{this_obj: me, the_player: me})", persistent: false },
	
	currently_speaking_to: { type: "obj standing_npc|null", default: null },
	started_conversation_at: { type: "int", default: -100 },

	

#-------------------------- temporary vars --------------------------#
	_bounced_on_chain: { type: "int", default: 0, persistent: false },
	_last_bounced: { type: "int", default: 0, persistent: false },
	last_landed_hard: { type: "int", default: -30, persistent: false },
	is_running: { type: "bool", default: false, persistent: false },
	_tongue_tip: { type: "custom_obj|null", default: null, persistent: false },

	//indicates whether the last press of jump was while in the air.
	pressed_jump_in_air: { type: "bool", default: false, persistent: false },
	pressed_jump_on_cycle: { type: "int", default: 0, persistent: false },

	started_using_ability_at_cycle: { type: "{ InventoryItemType -> int }", init: "{ enum item_tongue: 0 }", persistent: false },
	ctrl_left_counter: { type: "int", default: 0, persistent: false },
	ctrl_right_counter: { type: "int", default: 0, persistent: false },
	ctrl_attack_counter: { type: "int", default: 0, persistent: false },
	ctrl_tongue_counter: { type: "int", default: 0, persistent: false },
	last_played_fire_sfx: { type: "int", default: 0, persistent: false },
	idleness_counter: { type: "int", default: 0, persistent: false },
	idleness_level: { type: "int", default: 0, persistent: false },

	in_solidity_fail: { type: "int|null", default: null, persistent: false },
	
	bubbles_die_here: { type: "int", default: 0, persistent: false },


	player_has_died_since_last_unique_checkpoint: { type: "bool|null", default: null },
	last_unique_checkpoint_label: { type: "string|null", default: null },
	last_unique_checkpoint_level_name: { type: "string|null", default: null },


#-------------------------- stuff that should be removed --------------------------#
	coin_race_levels: { type: "[string]", default: [] },
},

  





	   



#-------------------------- animation control logic --------------------------#
on_enter_start_jump_anim: "play_material_sound(enum jump)",

on_enter_slide_anim: "[
	set(rotate, 0),
	if(TOUCH_SCREEN, set(underwater_controls, false)),
	set(pressed_jump_in_air, true),
	set(velocity_y, 0),
]",

on_end_slide_anim: "animation('slide')",
	  
on_leave_interact_anim: "if(interacting_with, fire_event((object <- interacting_with), 'cancel_interaction'))",

on_leave_jump_attack_anim: "[
	fire_event('leave_attack_anim'),
	set(attached_objects, []),
]",

on_leave_slide_anim: "[
	if(ctrl_left, facing(-1)),
	if(ctrl_right, facing(1)),
]",

on_enter_walk_anim: "[
	set(_bounced_on_chain,0),
]",

on_enter_run_anim: "[
	set(_bounced_on_chain,0),
]",





	#-------------------------- input handling --------------------------#
on_ctrl_jump: "[
	proto_event('player_controlled_platformer_character', 'ctrl_jump'),
	set(pressed_jump_on_cycle, cycle),
	if(animation = 'slide', [
		set(pressed_jump_in_air, false),
		facing(-facing), 
		animation('start_jump'), 
		set(velocity_x, -facing*800), 
		set(velocity_y, -1000),
	], set(pressed_jump_in_air, (not can_jump()))),
]",

on_ctrl_left: "start_moving(-1)",

on_ctrl_right: "start_moving(1)",

on_end_ctrl_left: "stop_moving",

on_end_ctrl_right: "stop_moving",

on_ctrl_down: "[if(animation = 'slide', animation('fall')), handle_down_key_interacting]",


on_ctrl_attack: "use_active_secondary_item",
		
on_end_ctrl_up: "if((animation in ['enter_lookup', 'lookup']), start_standing)",

on_begin_transition_level: "[
	//This is called when we are exiting the level and it controls what 'transition'
	//is used between levels. Here we can set the number of frames the transition
	//should take and set the shader (found in shaders.cfg) to use to draw
	//the transition.
	//TODO: decide if we want to add more types of transitions. Should we move this to a prototype?
	set(level.num_transition_frames, 20),
	add(level.frame_buffer_shaders, [{
		label: 'transition',
		begin_zorder: -1000000,
		end_zorder: 100,
		shader_info: 'iris_transition',
	}]),
] where transition_type = string <- arg.transition",

	#-------------------------- core processing event loops --------------------------#
on_process: "[
	//debug(ctrl_keyboard('a')),
	//based on whether frogatto is underwater we set underwater filters on/off. Right now we apply
	//to the default layer with an effect named 'underwater'.
	//
	//TODO: Move this somewhere more appropriate, review if 'default' is the right layer to do it on.
	if((not underwater) and filters, lib.sound.set_layer_filters(me, 'default', 'underwater', []),
	   underwater and not filters,
	   lib.sound.set_layer_filters(me, 'default', 'underwater', [
	   	   //set a low pass filter over underwater sounds.
	       audio.low_pass_filter({ q: 0.7, fc: 1000.0, peak_gain: 1.0 }),
	   ])
	) where filters = filter(lib.sound.get_layer_filters('default'), value.userdata = 'underwater'),

//	debug(level.in_dialog, if(currently_speaking_to, currently_speaking_to.type, null)),
	if(level.cycle > started_conversation_at and not level.in_dialog, set(currently_speaking_to, null)),
	trigger_garbage_collection(1, false),
	
	//debug(str(control_lock_registry) + ' control_lock='+ str(control_lock)),
	position_predictor.pump_player_history,
	proto_event('player_controlled_platformer_character', 'process'),
	if(cycle % 2 = 0, [
		if(int(ctrl_right) - int(ctrl_left) != 0 and int(ctrl_right) - int(ctrl_left) != facing, set_facing(-facing)),
		if(ctrl_up and animation in ['stand'], animation('enter_lookup')),
		proto_event('player_controlled_platformer_character', 'timer'),
	]),

		//If we're standing on a springy object, force a collide_feet event to make us bounce off it.
	if(velocity_y = 0 and standing_on and standing_on is obj standard_values, if(standing_on.springiness > 0,
			 fire_event('collide_feet', {collide_with: standing_on}))),
	
	if(is_standing, set(rotate, slope_standing_on/4), if(not animation in jump_animations, set(rotate,0))),
	
	if((not is_standing) and not (is_currently_fat and underwater),
		add(_cycles_since_last_touching_ground, 1),
		if(cycle - _last_bounced < postjump_grace_period, set(_cycles_since_last_touching_ground, postjump_grace_period), set(_cycles_since_last_touching_ground, 0)), 
	),
	
	if((not is_standing) and should_be_standing,
		animation('fall'),
	),

	if(ctrl_jump and (not ctrl_down) and (not pressed_jump_in_air) and (cycle - pressed_jump_on_cycle < 12 or _jump_cheat),
		add(velocity_y, -jump_boost)),

	[if(ctrl_left, process_movement(-1)), if(ctrl_right, process_movement(1))],
	if(should_continue_roll(facing), process_movement(facing), if(animation = 'roll' and (not (ctrl_left or ctrl_right)), stop_moving)),
	if(ctrl_down and (not (ctrl_left or ctrl_right)), crouch()),
	if((ctrl_down or ctrl_up) and (not (ctrl_left or ctrl_right)), process_movement(0)),

	if(underwater and 
		//complex blob of logic here; basically we want to tread water in both the case where no controls are pressed, but also in the case where the horizontal/vertical controls *are* pressed, but they're 'cancelling each other out'
	
		((
			control_signs.x = 0 and control_signs.y = 0
		) where control_signs = {
			x: int(ctrl_right) - int(ctrl_left),
			y: int(ctrl_up) - int(ctrl_down)
		}), 
		tread_water
	),

	if(animation in attack_animations + ['turn'], maintain_locomotion),
	
	if(ctrl_tongue, add(ctrl_tongue_counter,1), set(ctrl_tongue_counter, 0)),
	if(ctrl_attack, add(ctrl_attack_counter,1), set(ctrl_attack_counter, 0)),

	if(not mana_shock_active, add(mana, mana_regen_per_frame)),
	use_mana_cooldowns(),
	
	if(should_display_hud_now, [
		if(ctrl_keyboard(get_key_for_input(enum button_toggle_attack_left)) = 1,
			toggle_ability(enum left)
		),
		if(ctrl_keyboard(get_key_for_input(enum button_toggle_attack_right)) = 1,
			toggle_ability(enum right)	
		),
		if(ctrl_keyboard(get_key_for_input(enum button_toggle_item_left)) = 1,
			toggle_secondary_item(enum left)	
		),
		if(ctrl_keyboard(get_key_for_input(enum button_toggle_item_right)) = 1,
			toggle_secondary_item(enum right)	
		),
	]),
	
	_track_keys(),
	if(ctrl_keyboard(get_key_for_input(enum button_open_inventory)) = 1 
			and not find(level.active_chars, value is obj inventory_screen_controller_2), //only needed if the inventory screen doesn't pause the game
		spawn('inventory_screen_controller_2', 0, 0, 1) ),
	
	if(ctrl_tongue, attack()),
	
	if(not cycle % 29, //Update enemies seen.
		map(filter(level.active_chars, value is obj hittable and lib.math.length(me, value) < 400), 
			add(enemies_seen, {(value.frogourmet_tag): true}))),
]",

on_draw: "[
	if((should_display_hud != should_display_hud_now) or (level.cycle < 20),
		/*
			Note a dependency here — to keep this from getting weird, the transitions need to be instant if we're at the launch of a level.  The fade-in animation for these is longer than the fade-out, so if a fade-in and a fade-out get triggered back-to-back, the fade-in's final effects will take precedence, which means the gui won't actually hide (since the final state applied will be the final frame of the longer-animation).  TODO:  This was noted to happen a few times on cutscenes at the start of a level, but if we continue to have problems with this, then we should probably 'pad' the fade-out animation with a secondary animation that just sets a constant value of 0, for 15 cycles after the actual one plays.
		*/
	
		if(should_display_hud_now, 
			if(level.cycle < 19, instantly_show_hud, fade_in_hud),
			if(level.cycle < 19, instantly_hide_hud, fade_out_hud)
		)
	),
	set(should_display_hud, should_display_hud_now),
	if(should_display_hud != should_display_hud_now, set(last_changed_should_display_hud, level.cycle)),
]",

on_process_start_jump: "[set_aerial_rotation(-2)]",
	
on_process_jump: "[if(velocity_y > 0, animation('fall')),set_aerial_rotation(-1)]",
	
on_process_fall: "[
	if(TOUCH_SCREEN,
		if(underwater_controls, [
			add(velocity_x, (jump_glide*ctrl_x)/1000),
			add(velocity_y, (jump_glide*ctrl_y)/1000), 
		])
	),
	set_aerial_rotation(-1),
	proto_event('player_controlled_platformer_character', 'process_fall')]",

on_leave_fall_anim: "set(rotate,0)",
	
on_process_lookup: "[
	add(lookup_time, 1),
	if(lookup_time = 50, set(vertical_look, -200)),
]",

on_process_crouch: "[
	add(lookdown_time, 1), 
	if(lookdown_time = 50, set(vertical_look, 200)),
]",

on_leave_lookup_anim: "[
	set(lookup_time, 0), 
	set(vertical_look, 0),
]",

on_leave_crouch_anim: "[
	set(lookdown_time, 0), 
	set(vertical_look, 0),
]",


on_process_slide: "if(not can_slide, animation('fall'))",


on_enter_water: "[
	lib.sound.play_sound(me, 'water-enter'),
	set(bubbles_die_here, me.midpoint_y),
	
	if(TOUCH_SCREEN, set(underwater_controls, true)),
	if(not (is_currently_fat or _tongue_tip), tread_water),
	
	//splash if we are entering the water with reasonable velocity
	if(water_bounds != null and velocity_y > 200, [
		spawn('water_splash', midpoint_x, water_bounds[1]+10, if(1d2=2,facing,-facing)),
		spawn('water_particles', midpoint_x, water_bounds[1]+10, facing),
	]),
]",

on_exit_water: "[
	set(has_feet, true),
	animation('fall'),
	lib.sound.play_sound(me, 'water-exit'),
	
	if(velocity_y < -200, [
		spawn('water_splash', midpoint_x, previous_water_bounds[1]+10, choose([facing,-facing])),
		spawn('water_particles', midpoint_x, previous_water_bounds[1]+10, facing),
	]),
	
	if(velocity_y < 0, add(velocity_y, -jump_out_of_water_boost)),
	set(velocity_x, (velocity_x*jump_out_of_water_boost_horizontal)/100),
]",


on_collide_feet: "[
	if(TOUCH_SCREEN and (not underwater), set(underwater_controls, false)),

	schedule(8,fullfill_todo_upon_landing),

	if(animation = 'freefall', [animation('faceplant'),set(velocity_x,0)],
		if(arg.collide_with is obj standard_values and (obj standard_values <- arg.collide_with).springiness > 0, [
			bounce_on(obj standard_values <- arg.collide_with),
		],[	
			set(velocity_x, velocity_x/2),
			if(has_feet and animation not in uninterruptible_animations,
				[if(velocity_y > 1300, [animation('land'),lib.sound.play_sound(me, 'bumphead-light', { volume: 0.5 } )], start_standing),
				if(velocity_y>900, play_material_sound(enum jump), play_material_sound(enum footfall)),
			
				if((hypot(velocity_x,velocity_y) > 1500) and (abs(velocity_x) > 700), set(last_landed_hard, cycle))
				],
			),
		]),
	)
]",

on_collide_head: "[
	//debug('head' + if(collide_with is custom_obj, collide_with.type, '')),
	if(collide_with is obj movable_enemy,
		me.two_party_elastic_collision(collide_with)
	),
	if(collide_with is obj throwable,
		me.two_party_elastic_collision(collide_with)
	),
	if(animation in ['start_jump', 'jump'], animation('bumphead')), 
	if(velocity_y < 0, set(velocity_y, 0)),
	set(pressed_jump_in_air, true),
] where collide_with = arg.collide_with",

on_collide_side: "[
	set(velocity_x, 0),
	if(animation in ['start_jump', 'jump', 'fall']
			and can_slide
			and (abs(velocity_x) > 200 or ctrl_jump and pressed_jump_in_air), [
		animation('slide'),
		set(velocity_y, 0),
		lib.sound.play_sound(me, 'wall-catch'),
	]),
]",
	   

//if we couldn't return an object to play when spitting it, revert to having it inside us.
on_add_object_fail: "if(arg.object and swallowed_object = null, [
	add(gravity_shift, -arg.object.carry_gravity) asserting arg.object is obj throwable,
	fill_stomach(arg.object, enum without_swallow_anim) asserting arg.object is obj throwable,
])",

//If we change our solid dimensions -- i.e. try to come back from being hurt, and we can't because we're on top of another solid object, then we take more damage.
on_change_solid_dimensions_fail: "[
	proto_event('player_controlled_platformer_character', 'change_solid_dimensions_fail'),
	if(not is_invincible_posthit, if(is_currently_fat, shoot_spit_attack, animation('hurt')) ),
]",

on_enter_turn_whilst_running_anim: "if((not underwater), [
	map(range(4), schedule(value*3, bind_command( def() spawn_on_ref('dust_cloud_skid', midpoint_x -7*facing, y2-6, facing)))),
])",

on_enter_skid_anim: "if(abs(velocity_x) > 300 and (not underwater), [
	map(range(4), schedule(value*3, bind_command( def() spawn_on_ref('dust_cloud_skid', midpoint_x -7*facing, y2-6, facing)))),
	play_material_sound(enum slide),
])",

on_enter_land_anim: "if(not underwater, [
	spawn_on_ref('dust_cloud_skid', midpoint_x + 20*facing, y2 - 8,  facing), 
	spawn_on_ref('dust_cloud_skid', midpoint_x - 20*facing, y2 - 8, -facing),
])",

on_process_run: "if(abs(velocity_x) > 300 and cycle%5=0 and (not underwater),
	spawn_on_ref('dust_cloud_run', midpoint_x - 30*facing, y2-10, -facing))",



on_idling: "if(idleness_level < 2, [
	animation('stand'),
	add(idleness_level, 1),
],[
	animation(
		switch(1d9,
			1, 'idle_shrug',
			2, 'idle_shrug',
			3, 'idle_shrug',
			4, 'idle_croak',
			5, 'idle_croak',
			6, 'idle_croak',
			7, 'idle_croak',
			8, 'idle_eyeball',
			9, 'idle_eyeball',
			   'idle_shrug'
		)
	),
	set(idleness_level, 0),
])",

on_process_attack: "if(facing = 1 and ctrl_right or facing = -1 and ctrl_left, [
	set(animation, 'walk_attack'),
	set(time_in_animation, time_in_animation), //This carries the time in animation over to walk_attack. First we set the animation, which sets time_in_animation to 0, then we run the set() command, which sets time in animation to whatever the old time_in_animation was, when we evaluated the command. It is, contrary to appearances, not just a tautological operation.
	set(accel_x, walk_accel),
])",
on_process_walk_attack: "if(facing = 1 and (not ctrl_right) or facing = -1 and (not ctrl_left), [
	set(animation, 'attack'), 
	set(time_in_animation, time_in_animation), //See comment in on_process_attack.
])",










#                                                                                  #
#-------------------------- animation end/chaining logic --------------------------#
#                                                                                  #

	#-------------------------- land/aerial movement animations --------------------------#
on_end_enter_crouch_anim: "animation('crouch')",
on_end_crouch_anim: "if(ctrl_down, animation('crouch'), animation('leave_crouch'))",
on_end_leave_crouch_anim: "start_standing",



on_end_turn_anim: "start_standing",
on_end_start_jump_anim: "animation('jump')",
on_end_jump_anim: "animation('jump')",
on_end_fall_anim: "animation('fall')",
on_end_bumphead_anim: "animation('fall')",
on_end_land_anim: "start_standing",
on_end_roll_anim: "animation('roll')",
on_end_stand_to_walk_anim: "animation('walk')",
on_end_walk_anim: "animation('walk')",
on_end_freefall_anim: "animation('freefall')",
on_end_faceplant_anim: "animation('prostrate')",

on_end_run_anim: "animation('run')",

//note:  using level.zoom to detect if in a cutscene or dialogue, in which case we don't do idle anims.
//TODO:  this fails to account for the epilogue.  Figure out some way to do this without setting a special tracker variable, since those are bug-prone.
on_end_stand_anim: "if((not is_currently_fat) and idleness_counter > 8 and level.zoom = 1 and (not level.in_dialog), 
	[fire_event('idling'), set(idleness_counter, 0)],
	[animation('stand'), add(idleness_counter, 1)],
)",
	
on_leave_stand_anim: "[set(idleness_counter, 0), set(idleness_level, 0)]",
on_end_skid_anim: "start_standing",
					
on_end_idle_eyeball_anim: "start_standing",
on_end_idle_croak_anim: "start_standing",
on_end_idle_shrug_anim: "start_standing",
on_whoosh_up: "lib.sound.play_sound(me, 'emote-whoosh-medium')", //used for standing up after awakening
on_whoosh_down: "lib.sound.play_sound(me, 'emote-whoosh-light3')",
on_feet_stand: "play_material_sound(enum jump)", //used when feet hit floor after standing up quickly.
on_footfall: "play_material_sound(enum footfall)",
on_swim_stroke: "lib.sound.play_sound(me, 'water-swim')",

on_scratch: "lib.sound.play_sound(me, 'head-scratch')", //used for the 'confused' emote



	#-------------------------- attack animations --------------------------#
on_end_spit_anim: "if(underwater, tread_water, start_standing)",

on_end_walk_attack_anim: "animation('walk')",

on_end_fingerpoint_attack_anim:            "start_standing",
on_end_fingerpoint_attack_jump_anim:       "start_standing",
on_end_fingerpoint_attack_up_slope_anim:   "start_standing",
on_end_fingerpoint_attack_down_slope_anim: "start_standing",

on_end_floating_spin_anim: "animation('floating_spin')",
on_end_floating_spin_fast_anim: "animation('floating_spin_fast')",
on_end_floating_spin_faster_anim: "animation('floating_spin_faster')",

on_end_attack_anim: "[
	if((is_currently_fat), animation('swallow')),
	start_standing,
]",
on_leave_attack_anim: "[
	if(_tongue_tip, fire_event('remove_tongue')), 
	set(attached_objects, []),
]",

on_end_swallow_anim: "start_standing",
on_end_enter_lookup_anim: "animation('lookup')",
on_end_lookup_anim: "animation('lookup')",
on_end_jump_attack_anim: "animation('fall')",
on_end_firebreath_begin_anim: "animation('firebreath_cycle')",
on_end_firebreath_cycle_anim: "if(is_breath_ability_active(enum item_fire_breath_talisman, 'firebreath'), animation('firebreath_cycle'), animation('firebreath_end'))",
on_end_firebreath_end_anim: "start_standing",
on_end_acidbreath_begin_anim: "animation('acidbreath_cycle')",
on_end_acidbreath_cycle_anim: "animation('acidbreath_end')",
on_end_acidbreath_end_anim: "start_standing",

	#-------------------------- swim animations --------------------------#
on_end_swim_up:			"continue_swim",
on_end_swim_up_diag:	"continue_swim",
on_end_swim_side:		"continue_swim",
on_end_swim_down_diag:	"continue_swim",
on_end_swim_down:		"continue_swim",

on_end_tread_water_up:			"tread_water",
on_end_tread_water_up_diag:		"tread_water",
on_end_tread_water_side:		"tread_water",
on_end_tread_water_down_diag:	"tread_water",
on_end_tread_water_down:		"tread_water",

on_end_underwater_breath_attack_up:			"tread_water",
on_end_underwater_breath_attack_up_diag:	"tread_water",
on_end_underwater_breath_attack_side:		"tread_water",
on_end_underwater_breath_attack_down_diag:	"tread_water",
on_end_underwater_breath_attack_down:		"tread_water",


	#-------------------------- item animations --------------------------#
on_end_item_get_begin_anim: "animation('item_get_hold')",
on_end_item_get_hold_anim: "animation('item_get_hold')",
on_end_item_get_end_anim: "animation('stand')",
on_end_hurt_anim: "animation(if((not is_currently_fat) and underwater, 'tread_water_side', 'stand'))",

	#-------------------------- emote animations --------------------------#
on_end_emote_geez_anim: "animation('stand')",
on_end_emote_oh_anim: "animation('stand')",
on_end_emote_impatient_anim: "animation('stand')",
on_end_emote_raisedfinger_anim: "animation('stand')",
on_end_emote_confused_anim: "animation('stand')",
on_end_emote_talk_anim: "animation('stand')",
on_end_emote_nod_anim: "animation('stand')",
on_end_emote_angry_anim: "animation('stand')",
on_end_emote_victory_anim: "animation('emote_victory2')",
on_end_emote_victory2_anim: "animation('stand')",
on_end_descend_rope_anim: "animation('descend_rope')",

on_end_cutscene_sleep_anim: "animation('cutscene_sleep')",
on_end_cutscene_wake_abruptly_anim: "[animation('cutscene_wake_abruptly2'), add(x, 12*facing)]",
on_end_cutscene_wake_abruptly2_anim: "[animation('cutscene_wake_abruptly_foot_wiggle')]",
on_end_cutscene_wake_abruptly_foot_wiggle_anim: "[animation('cutscene_wake_abruptly_foot_wiggle')]",
on_end_cutscene_wake_vault_upright_anim: "[animation('cutscene_wake_vault_upright2'), add(x, -2*facing)]",
on_end_cutscene_wake_vault_upright2_anim: "[animation('cutscene_wake_vault_upright3'), add(x, 4*facing)]",
on_end_cutscene_wake_vault_upright3_anim: "[start_standing]",
on_end_emote_yawn_anim: "start_standing",






default_anim: "string :: 'stand'",

animation: [
	{
		"@base": true,
		accel_x: 0,
		accel_y: 65,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		no_remove_alpha_borders: true,
	},
#-------------------------- standing animations --------------------------#
	{
		image: "characters/frogatto-spritesheet1.png",
		id: "stand",
		duplicates: 6,
		rect: [2,89,33,121],
		frames: 11,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "stand", //blink variant
		rect: [2,125,33,157],
		frames: 11,
		duration: 5,
	},
#-------------------------- movement animations --------------------------#
	{
		image: "characters/frogatto-spritesheet1.png",
		id: "stand_to_walk",
		rect: [439,91,470,123],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "walk",
		solid_area: [17,19,31,41],
		rect: [1,352,48,399],
		frames: 12,
		frames_per_row: 4,
		duration: 4,
		events: "10:34:footfall",
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "run",
		solid_area: [17,19,31,41],
		rect: [219,352,266,399],
		frames: 12,
		frames_per_row: 4,
		duration: 3,
		events: "6:24:footfall",
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "skid",
		x: 478, y: 91, w: 32, h: 33,
		frames: 5,
		frames_per_row: 1,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "turn",
		x: 317, y: 2, w: 32, h: 33,
		frames: 2,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "turn_whilst_running",
		solid_area: [17,19,31,41],
		rect: [1,386,48,433],
		frames: 7,
		duration: 4,
	},
#-------------------------- jumping and aerial animations --------------------------#
	{
		image: "characters/frogatto-spritesheet7.png",
		id: "start_jump",
		solid_area: [9,13,23,35],
		x: 1,
		y: 103,
		w: 32,
		h: 48,
		frames: 5,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "jump",
		solid_area: [9,13,23,35],
		x: 1, y: 1, w: 32, h: 48,
		frames: 5,
		reverse: true,
		duration: 3,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "fall",
		solid_area: [9,13,23,35],
		x: 1, y: 52, w: 32, h: 48,
		duration: 3,
		frames: 12,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "land",
		solid_area: [9,17,23,39],
		x: 142, y: 38, w: 32, h: 48,
		duration: 5,
		frames: 2,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "roll",
		x: 1, y: 154, w: 32, h: 33,
		duration: 4,
		frames: 8,
	},{
		image: "characters/frogatto-spritesheet1.png",
		accel_y: 0,
		id: "slide", //wallcling
		x: 317, y: 40, w: 32, h: 34,
		duration: 10,
		frames: 4,
		solid_area: [14,8,28,30],
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "bumphead",
		sound: "bumphead.wav",
		solid_area: [9,12,23,34],
		rect: [422,2,453,36],
		duration: 6,
		frames: 1,
	},	
#-------------------------- misc/utility animations --------------------------#
	{
		image: "characters/frogatto-spritesheet1.png",
		id: "lookup",
		rect: [37,233,68,265],
		frames: 1,
		duration: 4,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "enter_lookup",
		rect: [2,233,33,265],
		frames: 1,
		duration: 4,
		reverse: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "crouch",
		solid_area: [9,17,23,30],
		rect: [107,197,138,229],
		frames: 1,
		duration: 1,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "enter_crouch",
		solid_area: [9,17,23,30],
		rect: [2,197,33,229],
		frames: 3,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "leave_crouch",
		rect: [2,197,33,229],
		frames: 3,
		duration: 4,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "hurt",
		rect: [272,351,303,383],
		frames: 1,
		duration: 22,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "interact",
		collide_x: 10,
		collide_y: 6,
		collide_w: 15,
		collide_h: 16,
		feet_x: 16,
		feet_y: 32,
		x: 72, y: 161, w: 32, h: 33,
		frames: 4,
		duration: 5,
		reverse: true,
		events: "15:interacting",
	},
#-------------------------- spit/tongue attack animations --------------------------#
	{
		image: "characters/fat-frogatto-spritesheet1.png",
		id: "swallow",
		x: 2, y: 269, w: 49, h: 38,
		duration: 7,
		frames: 6,
		solid_area: [6,13,20,35],
	},{
		image: "characters/fat-frogatto-spritesheet1.png",
		id: "spit",
		x: 314, y: 269, w: 34, h: 35,
		duration: 4,
		frames: 3,
		solid_area: [6,8,20,30],
	},{
		image: "characters/frogatto-spritesheet5.png",
		id: "attack",
		sound: "tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav",
		rect: [2,151,33,188],
		solid_area: [9,12,23,34],
		frames: 8,
		duration: 3,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet5.png",
		id: "walk_attack",
		rect: [2,233,33,270],
		solid_area: [9,12,23,34],
		frames: 4,
		duration: 6,
		reverse: false,
	},{
		image: "characters/frogatto-spritesheet5.png",
		id: "jump_attack",
		sound: "tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav",
		rect: [2,192,50,229],
		solid_area: [16,10,30,32],
		frames: 8,
		duration: 3,
		reverse: false,
	},
#-------------------------- special ability animations --------------------------#
	{
		image: "characters/frogatto-spritesheet1.png",
		id: "firebreath_begin",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "firebreath_cycle",
		rect: [360,476,393,510],
		frames: 2,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "firebreath_end",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "acidbreath_begin",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "acidbreath_cycle",
		rect: [360,476,393,510],
		frames: 2,
		duration: 2,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "acidbreath_end",
		rect: [286,476,319,510],
		frames: 3,
		duration: 2,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet2.png",
		id: "fingerpoint_attack_jump",
		rect: [1,415,41,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [12,14,26,36],
	},{
		image: "characters/frogatto-spritesheet2.png",
		id: "fingerpoint_attack_down_slope",
		rect: [45,415,85,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,15,28,37],
	},{
		image: "characters/frogatto-spritesheet2.png",
		id: "fingerpoint_attack_up_slope",
		rect: [89,415,129,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,15,28,37],
	},{
		image: "characters/frogatto-spritesheet2.png",
		id: "fingerpoint_attack",
		rect: [133,415,173,458],
		frames: 2,
		frames_per_row: 1,
		duration: 5,
		solid_area: [14,14,28,36],
	},
	
		
#-------------------------- swimming animations --------------------------#
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "swim_up",
		x: 1, y: 1, w: 51, h: 51,
		duration: 6,
		frames: 8,
		solid_area: [19,19,30,35],
		accel_y: 0,
		events: "25:swim_stroke",
	},
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "swim_up_diag",
		x: 1, y: 57, w: 51, h: 51,
		duration: 6,
		frames: 8,
		solid_area: [19,19,30,35],
		accel_y: 0,
		events: "25:swim_stroke",
	},	
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "swim_side",
		x: 1, y: 113, w: 51, h: 51,
		duration: 6,
		frames: 8,
		solid_area: [19,19,30,35],
		accel_y: 0,
		events: "25:swim_stroke",
	},	
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "swim_down_diag",
		x: 1, y: 169, w: 51, h: 51,
		duration: 6,
		frames: 8,
		solid_area: [19,19,30,35],
		accel_y: 0,
		events: "25:swim_stroke",
	},	
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "swim_down",
		x: 1, y: 225, w: 51, h: 51,
		duration: 6,
		frames: 8,
		solid_area: [19,19,30,35],
		accel_y: 0,
		events: "25:swim_stroke",
	},
#-------------------------- treading-water animations --------------------------#
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "tread_water_up",
		x: 1, y: 295, w: 51, h: 51,
		duration: 6,
		frames: 3,
		reverse: true,
		frames_per_row: 1,
		solid_area: [19,19,30,35],
		accel_y: 0,
	},
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "tread_water_up_diag",
		x: 56, y: 295, w: 51, h: 51,
		duration: 6,
		frames: 3,
		reverse: true,
		frames_per_row: 1,
		solid_area: [19,19,30,35],
		accel_y: 0,
	},	
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "tread_water_side",
		x: 111, y: 295, w: 51, h: 51,
		duration: 6,
		frames: 3,
		reverse: true,
		frames_per_row: 1,
		solid_area: [19,19,30,35],
		accel_y: 0,
	},	
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "tread_water_down_diag",
		x: 166, y: 295, w: 51, h: 51,
		duration: 6,
		frames: 3,
		reverse: true,
		frames_per_row: 1,
		solid_area: [19,19,30,35],
		accel_y: 0,
	},	
	{
		image: "characters/frogatto-spritesheet8.png",
		id: "tread_water_down",
		x: 221, y: 295, w: 51, h: 51,
		duration: 6,
		frames: 3,
		reverse: true,
		frames_per_row: 1,
		solid_area: [19,19,30,35],
		accel_y: 0,
	},
#-------------------------- swim attack animations --------------------------#
	{
		image: "characters/frogatto-spritesheet11.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "underwater_breath_attack_up",
		x: 1, y: 1, w: 51, h: 51,
		solid_area: [19,19,30,35],
		frames: 1,
		duration: 5,
	},
	{
		image: "characters/frogatto-spritesheet11.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "underwater_breath_attack_up_diag",
		x: 56, y: 1, w: 51, h: 51,
		solid_area: [19,19,30,35],
		frames: 1,
		duration: 5,
	},
	{
		image: "characters/frogatto-spritesheet11.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "underwater_breath_attack_side",
		x: 111, y: 1, w: 51, h: 51,
		solid_area: [19,19,30,35],
		frames: 1,
		duration: 5,
	},
	{
		image: "characters/frogatto-spritesheet11.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "underwater_breath_attack_down_diag",
		x: 166, y: 1, w: 51, h: 51,
		solid_area: [19,19,30,35],
		frames: 1,
		duration: 5,
	},
	{
		image: "characters/frogatto-spritesheet11.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "underwater_breath_attack_down",
		x: 221, y: 1, w: 51, h: 51,
		solid_area: [19,19,30,35],
		frames: 1,
		duration: 5,
	},
#-------------------------- cinematic/item/victory animations --------------------------#
	{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_begin",
		rect: [1,335,32,367],
		frames: 4,
		duration: 12,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_hold",
		rect: [106,335,137,367],
		frames: 1,
		duration: 36,
	},{
		image: "characters/frogatto-spritesheet3.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		body_area: "none",
		feet_width: 5,
		id: "item_get_end",
		rect: [1,335,32,367],
		frames: 4,
		duration: 12,
		play_backwards: true,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_geez",
		rect: [1,1,36,38],
		solid_area: [11,13,25,35],
		frames: 8,
		reverse: true,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet4.png",
		id: "emote_oh",
		rect: [1,1,36,38],
		solid_area: [11,13,25,35],
		frames: 15,
		frames_per_row: 5,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_confused",
		rect: [1,52,36,89],
		solid_area: [11,13,25,35],
		events:"30:scratch",
		frames: 14,
		frames_per_row: 7,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_impatient",
		rect: [323,1,358,38],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 4,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_raisedfinger",
		rect: [1,144,36,181],
		solid_area: [11,13,25,35],
		frames: 14,
		frames_per_row: 7,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_talk",
		rect: [1,236,36,273],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 8,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet3.png",
		id: "emote_nod",
		rect: [323,175,358,212],
		solid_area: [11,13,25,35],
		frames: 16,
		frames_per_row: 4,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet4.png",
		id: "emote_angry",
		rect: [1,127,36,164],
		solid_area: [11,13,25,35],
		frames: 20,
		frames_per_row: 5,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet4.png",
		id: "emote_yawn",
		rect: [1,293,48,341],
		solid_area: [17,16,31,38],
		frames: 20,
		frames_per_row: 5,
		duration: 7,
		pad: 3,
	},{
		image: "characters/frogatto-spritesheet-idle.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "idle_eyeball",
		rect: [1,1,32,33],
		frames: 43,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet-idle.png",
		accel_x: 0,
		accel_y: 0,
		pad: 7,
		body_area: "all",
		feet_width: 5,
		id: "idle_croak",
		rect: [3,37,34,69],
		frames: 25,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet-idle.png",
		accel_x: 0,
		accel_y: 0,
		pad: 3,
		body_area: "all",
		feet_width: 5,
		id: "idle_shrug",
		rect: [1,73,32,105],
		frames: 9,
		reverse: true,
		duration: 10,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "floating_spin",
		rect: [3,436,34,477],
		frames: 8,
		duration: 7,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "floating_spin_fast",
		rect: [3,436,34,477],
		frames: 8,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet1.png",
		id: "floating_spin_faster",
		rect: [3,436,34,477],
		frames: 8,
		duration: 3,
	},{
		image: "characters/frogatto-spritesheet6.png",
		id: "emote_victory",
		rect: [1,1,33,33],
		solid_area: [10,6,24,28],
		frames: 18,
		frames_per_row: 9,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet6.png",
		id: "emote_victory2",
		rect: [73,73,105,105],
		solid_area: [10,6,24,28],
		frames: 7,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet9.png",
		id: "cutscene_sleep",
		rect: [1,1,43,43],
		solid_area: [14,10,28,32],
		frames: 6,
		duration: 8,
	},{
		image: "characters/frogatto-spritesheet9.png",
		id: "cutscene_wake_abruptly",
		rect: [1,47,58,104],
		solid_area: [21,18,35,40],
		frames: 7,
		frames_per_row: 7,
		duration: 5,
		events: "15:30:footfall",
	},{
		image: "characters/frogatto-spritesheet9.png",
		id: "cutscene_wake_abruptly2",
		rect: [1,108,58,165],
		solid_area: [21,18,35,40],
		frames: 10,
		frames_per_row: 5,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet9.png",
		id: "cutscene_wake_abruptly_foot_wiggle",
		rect: [1,231,48,278],
		solid_area: [15,13,29,35],
		frames: 18,
		pad:2,
		frames_per_row: 6,
		duration: 6,
	},{
		image: "characters/frogatto-spritesheet10.png",
		id: "cutscene_wake_vault_upright",
		rect: [1,1,58,58],
		solid_area: [21,18,35,40],
		frames: 5,
		pad:3,
		frames_per_row: 5,
		duration: 5,
		events: "20:whoosh_up",
	},{
		image: "characters/frogatto-spritesheet10.png",
		id: "cutscene_wake_vault_upright2",
		rect: [1,62,58,119],
		solid_area: [21,18,35,40],
		frames: 10,
		pad:3,
		frames_per_row: 5,
		duration: 2,
		events: "8:whoosh_down, 16: feet_stand",
	},{
		image: "characters/frogatto-spritesheet10.png",
		id: "cutscene_wake_vault_upright3",
		rect: [1,184,58,241],
		solid_area: [21,18,35,40],
		frames: 5,
		pad:3,
		frames_per_row: 5,
		duration: 5,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "freefall",
		rect: [469,1,510,48],
		solid_area: [14,16,28,38],
		reverse: true,
		frames: 3,
		frames_per_row: 1,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "faceplant",
		rect: [1,277,42,324],
		solid_area: [14,16,28,38],
		frames: 9,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "prostrate",
		rect: [361,277,402,324],
		solid_area: [14,16,28,38],
		frames: 1,
		duration: 4,
	},{
		image: "characters/frogatto-spritesheet7.png",
		id: "descend_rope",
		rect: [443,369,474,401],
		frames: 8,
		frames_per_row: 2,
		duration: 6,
		accel_y: 0,
		play_backwards: true,
		velocity_y: 200,
	}],


variations: {
	fat: "[
		map(filter(doc.animation, value.image in images_to_convert), 'anim',
		set(anim.image, regex_replace(anim.image, 'frogatto', 'fat-frogatto'))) where
		images_to_convert = ['characters/frogatto-spritesheet1.png',
							 'characters/frogatto-spritesheet3.png',
							 'characters/frogatto-spritesheet4.png',
							 'characters/frogatto-spritesheet7.png'],
		map(filter(doc.animation, value.id = 'walk'), 'anim', set(doc.anim.accel_x, 1300)),
		map(filter(doc.animation, value.id = 'run'), 'anim', set(doc.anim.accel_x, 1900)),
	]",
},



object_type: [
	#-------------------------- TONGUE/HEAD --------------------------#
	{
		id: "tongue_shaft",
		prototype: ["wobbly_rope"],
		always_active: true,
		serializable: false,
		zsub_order: 5,
		solid_dimensions: [],
		
		properties: {
			is_player_body_part: true,

		},
		
			
		animation: {
			id: "default",
			image: "characters/frogatto-tongueC.png",
			x: 0,
			y: 0,
			w: 7,
			h: 7,
			frames: 1,
			no_remove_alpha_borders: true,
		},
	},
	
	
	{
		id: "frogatto_head",
		serializable: false,
		
		properties: {
			is_player_body_part: true,
			_tongue_angle: {type: "int", default: 0},
		},
		
		on_create: "switch(_tongue_angle,
						-90,	animation('up'),
						-45,	animation('updiag'),
						0,		animation('side'),
						45,		animation('downdiag'),
						90,		animation('down'))",
		
		animation: [
			{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 3,
				no_remove_alpha_borders: true,
				id: "up",
				rect: [2,1,35,26],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 3,
				no_remove_alpha_borders: true,
				id: "updiag",
				rect: [2,30,35,55],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 3,
				no_remove_alpha_borders: true,
				id: "side",
				rect: [2,59,35,84],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 3,
				no_remove_alpha_borders: true,
				id: "downdiag",
				rect: [2,88,35,113],
			},{
				image: "characters/frogatto-spritesheet5.png",
				pad: 3,
				frames: 8,
				duration: 3,
				no_remove_alpha_borders: true,
				id: "down",
				rect: [2,117,35,142],
			},
		],
	},
	
	
	{
		id: "tongue_tip",
		prototype: ["hittable"],
		always_active: true,
		serializable: false,
		zsub_order: 6,
		solid_dimensions: ["player","common","boss","thrown"],
		collide_dimensions: ["player","enemy","~key","item"],
		is_strict: true,

		
		properties: {
			is_player_body_part: true,
			has_mini_hp_bar: "bool :: false",

			attack_damage: "0",
			team: "'player'",
			yhead_offset: "12",
			ybase_offset: "8",
			x_offset: "0*facing",
			tongue_duration: "_frog.tongue_duration",
			damage_cooldown: "10",
			max_swallow_size: "16",
			min_swallow_size: "10",

			length_per_time: "def(int time) -> int _frog.tongue_length*(tongue_duration/2 - abs(tongue_duration/2 - time))",

			set_shaft: "def(int time, decimal angle, decimal duration) -> commands [
				set(_shaft.bounds,
					{
						x: anchor_pos.x + x_offset,
						y: anchor_pos.y + ybase_offset,
						x2: anchor_pos.x + (length_per_time(time)*cos(angle)) * facing + x_offset,
						y2: anchor_pos.y + ybase_offset + (length_per_time(time)*sin(angle))
					}
				),
				set(_shaft.progression_fraction, convert_duration_to_depth(decimal(time),duration) ),
				//debug( calculate_pingpong_time_val(time,duration) ),
				//set(_shaft.progression_fraction, convert_duration_to_depth(time,duration)),
			]",
			
			convert_duration_to_depth: "def(decimal current_time, decimal full_duration) -> decimal
				/*
					This is intended to make a progression of 0.0 -> 1.0 at the midpoint -> 0.0 again.   So if the duration was 20 units long, it'd be at 100% halfways in, and at 0% at the ends.
				*/
				(calculate_pingpong_time_val(current_time,full_duration) / full_duration)
				
				where half_duration = full_duration/2.0
			",
			 
			calculate_pingpong_time_val: "def(decimal absolute_time, decimal full_duration) -> decimal
				/*
					This is borrowed from some animation frame calculation code.
			
					We want input values like:
					0	1	2	3	4	5	6	7	8	9	10
					to become
					0	1	2	3	4	5	4	3	2	1	0

					The first thing we do is remainder our current values into a number from 0 -> 10.
					This is done in `rem_current_frame`.	
				


					The next thing we do is a funky bit of math that successfully turns:
					0	1	2	3	4	5	6	7	8	9	10
					into
					0	1	2	3	4	0	4	3	2	1	0
				*/
	
				lib.math.decimal_mod(full_duration - abs(full_duration-rem_current_frame), full_duration)
				+
				/*
					which is great, except we want a 6 in the middle, which is where the following awkward chunk of math comes in:
				*/
				if(
					lib.math.decimal_mod(rem_current_frame, full_duration) = 0,
						full_duration * lib.math.decimal_mod(rem_current_frame/full_duration, 2),
						0
				)
				where rem_current_frame = lib.math.decimal_mod(absolute_time, (full_duration * 2))
			",



			adjust_position: "def(int time, decimal angle) -> commands	[
				set(midpoint_xy, [
					int(anchor_pos.x + (length_per_time(time)*cos(angle)) * facing  + x_offset + if(facing = 1, 2,0)),
					int(anchor_pos.y + ybase_offset + (length_per_time(time)*sin(angle)) + if(facing = -1 and angle = 0, -1, 0) )
				]),
				set(rotate, angle * facing)
			]",
			
			process_tongue: "commands :: [
				set_shaft(_timer, _tongue_angle, tongue_duration/2),
				adjust_position(_timer,_tongue_angle),
				if(_timer >= tongue_duration, die()),
				fire_event('drag_victim'),
				if(_timer = tongue_duration/2, animation('flash')),
				add(_timer,1)
				;
				_shaft.process_wobble
			]",
			
			anchor_pos: "{x: level.player.mid_x, y: level.player.mid_y - 12}",
			
			#-------------------------- vars --------------------------#
			_progression: {type: "decimal", default: 0},
			_timer: {type: "int", default: 1},
			_tongue_angle: {type: "decimal", default: 0},
			_last_x: {type: "int", default: 0},
			_last_y: {type: "int", default: 0},
			_swallowed: {type: "obj throwable|null", default: null},
			_cycle_grabbed: {type: "int|null", default: null},

			_frog: {type: "obj frogatto_playable", persistent: false},
			_froghead: {type: "obj frogatto_playable.frogatto_head", persistent: false, init: "object('frogatto_playable.frogatto_head', x, mid_y - 12, {facing: facing})" },  #TODO:  this can't be valid here, because it's not from the initialization_map by the time we get here 
			_shaft: {type: "obj frogatto_playable.tongue_shaft", persistent: false, init: "object('frogatto_playable.tongue_shaft',x,y, {facing: 1})" },
		},
		
		
		on_spawned: "set(parent, arg.spawner)",
		on_create:  "[
			set(_froghead.facing, facing),
			add_object(_froghead),
			add_object(_shaft),
			set(_froghead._tongue_angle, int(_tongue_angle)),
			set(_froghead.parent,parent),
			fire_event(_froghead, 'create'),
			set(_froghead.relative_x,0),
			set(_froghead.relative_y,-12),
			animation('initial'),
			;
			process_tongue
		] asserting parent is obj frogatto_playable",
		
		
		
		on_process: "process_tongue",
		
		on_die: "[
			if(_swallowed and _swallowed.physical_size > 8, [
				_frog.fill_stomach(_swallowed, enum with_swallow_anim),
				remove_attaches_from_level(_swallowed),
			]),
			set(_shaft.hitpoints, 0), 
			//set(_shaft, null),
			set(_froghead.hitpoints, 0), 
			//set(_froghead, null), 
			set(_frog._tongue_tip, null), 
			if((not _swallowed) and _frog.underwater, set(_frog.has_feet, false)),
			
			
		]",

		// If we snag something early, fast-forward us to where the tongue is at the same position, but retracting.
		on_stopearly: "[
			set(_timer, newtime), 
			set(_frog.time_in_animation,newtime),
		] where newtime = _timer + 2*abs(max((tongue_duration/2 - _timer), 0))",
		
		on_drag_victim: "[
			if(_swallowed and _cycle_grabbed and (level.cycle - _cycle_grabbed > 1), [
				set(_swallowed.midpoint_x, _last_x),
				set(_swallowed.midpoint_y, _last_y),
			]),
			set(_last_x, midpoint_x), set(_last_y, midpoint_y),
		]",
						
		on_grab_objects: "if((not _swallowed) and collide_obj.hitpoints, [
			collide_obj.pre_thrown_behavior_trigger
			;
			remove_object(collide_obj),
			if( is_object(collide_obj.thrown_type),
				[
					if(collide_obj is obj padlock_key, set((obj padlock_key <- throwable_obj).valid_levels, collide_obj.valid_levels)),
					
					/*
						TENTATIVE:
						This little fix right here (forcing `_constructed` to true) is a fix for a very odd edge case we ran into.   Normally the workflow for these attaches is:
						• Spawn the original object (such as a glowing ant), with the appropriate attaches (such as a glow).
						• Get grabbed.
						• Spawn a `glowing_ant.thrown` replacement.  ONLY BY CONVENTION, these typically never spawned attaches of their own.  They were just really basic/simple objects that represented the behavior of a thrown projectile - if they came from a glowing ant, they'd still glow, but not because they created their own attach for the glow - they merely had it passed to them from the original.
						• This `glowing_ant.thrown` replacement would be swallowed, stored, and spit back out.  Again; it had created no attaches of its own, but merely inherited them from the original `glowing_ant`.
						• Sooner or later, it would pop back upright, and replace itself with the original `glowing_ant`.  This object would have `_constructed` set to true, so it would not attempt to recreate any of the original attaches.  Conveniently, since they were passed along, the desired ones were still all there, so the object would look good.
						
						One notable thing here is this behavior works correctly for two critical use-cases; attaches we create ourselves (glowing because we're a glow-bug), but also works correctly for other use-cases (being green because we're poisoned).
						
						--The Problem:--
						A few rare objects are `throwable_projectile`s.  They don't have a separate 'dumb utility object' as a thrown type - they ARE the thrown type.
						• Upon being spawned the first time, they'd create their attaches like everything is supposed to.
						• But when a thrown copy is made of them - it's the same type of object, and that type of object happened to be a kind that spawned decorative attaches.   So now we have two copies of them.  Oops.

						As long as we're doing all the cosmetic-attache spawning in the constructor, the following should quell that problem.  This is marked as 'tentative' because like anything sufficiently complicated, we can't see the full cascade of side effects, and it might lead to some new bugs of its own.


						UPDATE:  we've discovered that this breaks `padlock_key`s, and we're hoping that our system of attache-reassignment-to-variable-names will make it so the new, 'would be duplicate' attaches never get added to the level.  If we re-assign that variable from pointing at a new object, to pointing at the old one, before the `add_object()` call, we'll be safe.

					set(throwable_obj._constructed, true)
					;
					*/
					remap_attaches_from_old_to_new( collide_obj, throwable_obj),
					
					set(attached_objects, [throwable_obj]), set(_cycle_grabbed, level.cycle),  // <-- The constructor for throwable_obj is triggered here, because this is considered as adding it to the game.
					
					bind_command(def() throwable_obj.set_to_animation('normal')),
					fire_event(throwable_obj, 'been_grabbed'),
					fire_event(throwable_obj, 'swallowed'),
					set(_swallowed, throwable_obj),
					set(throwable_obj.event_handlers, collide_obj.event_handlers),
					if(collide_obj is obj throwable, set(throwable_obj.juggled, (obj throwable <- collide_obj).juggled)),
					remove_attaches_from_level(collide_obj),
	
				
					if(collide_obj.physical_size > 8,[  //things below this get 'consumed' rather than becoming spittable
						add(level.player.gravity_shift, -throwable_obj.carry_gravity),
					],[
						//TODO: I'd like to make these values inherit-via-delegation, rather than be 'unit tested' here to be equivalent, but cannot atm.  I.e. all thrown objects would have a class-only representation of their source type, and could reference its static properties.  I considered making this mutable and setting it, but that's merely to avoid code duplication, and would be much worse due to violating constness.
						null asserting collide_obj.physical_size = throwable_obj.physical_size,
						collide_obj.get_hit_sourceless(enum neutral, kill_anything),
					]),
				] where throwable_obj = (obj throwable <- replacement_object_with_preserved_attributes( collide_obj, collide_obj.thrown_type, collide_obj.hitpoints, collide_obj.max_hitpoints ))
			),
			lib.sound.play_sound(me, 'Gulp'),
		]) where collide_obj = obj hittable <- arg.collide_with",
		
		
		on_collide_object_grab: "
				(if(collide_with is obj hittable, if(cld_area, if((cld_area = 'body' or cld_area = 'thrown') and (not _swallowed) and collide_with != level.player, [
						fire_event('stopearly'),
						animation('flashsnag'),
						if(fg_tag,
								add(frogatto.enemies_tasted, {(fg_tag): true}),
							   
								//adding 1 since the list won't have been updated yet, plus adding to casual the count of enemies exclusive to the 'challenging' difficulty level, which is only the wartfly, right now.
								if(size(frogatto.enemies_tasted) + if(level.player.difficulty >= difficulties.challenging, 1, 2) >= 37, achievement('frogourmet'))
						) where fg_tag = collide_with.frogourmet_tag where frogatto = (obj frogatto_playable <- level.player),
						if(is_swallowable,
								[collide_with.play_grabbed_cosmetics,
								collide_with.handle_grabbed_cleanup,
							   
								fire_event('grab_objects', {collide_with: collide_with})], //fire an event to grab the object. We do it in a separate event in case we try to swallow multiple objects at once.
						),
				]) where is_swallowable = collide_with.swallowable and collide_with.physical_size <= max_swallow_size)))

				where collide_with = if(arg.collide_with is obj hittable_attache, arg.collide_with._parent_obj, arg.collide_with)
				where cld_area = arg.collide_with_area  //protip: INTENTIONALLY abbreviating differently for visual differentiation
		",
		
		on_end_initial_anim: "animation('normal')",
		on_end_flash_anim: "animation('normal')",
		on_end_clung_anim: "animation('clung')",
		on_end_flashsnag_anim: "animation('clung')",
		
		animation: [
			{
				id: "initial",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 4,
				rect: [307,351,339,383],

				//grab_area=solid:all
				grab_area: [8,8,25,20,"solid"],
			},{
				id: "normal",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 100,
				rect: [379,351,411,383],

				//grab_area=solid:all
				grab_area: [8,8,25,20,"solid"],
			},{
				id: "flashsnag",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 2,
				rect: [415,351,447,383],
			},{
				id: "flash",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 2,
				rect: [343,351,375,383],
			},{
				id: "clung",
				image: "characters/frogatto-spritesheet1.png",
				frames: 1,
				duration: 100,
				rect: [451,351,483,383],
			},
		],
	},


	#-------------------------- HEAD FOR FINGER-POINT ATTACKS (i.e. energyshot and homingshot) --------------------------#
	{
		id: "frogatto_head_fingerpoint_attack",
		serializable: false,
		zsub_order: 12,
		
		properties: {
			is_player_body_part: true,
			_head_angle: { type: "int", default: 0 },
		},
		
		on_spawned: "[set(parent, arg.spawner),set(relative_x,-2),set(relative_y,-7)]",
		
		on_create: "[
			schedule(9,die()),
			switch(_head_angle,
				-90, animation('up'), 
				-45, animation('updiag'), 
				  0, animation('side'), 
				 45, animation('downdiag'), 
				 90, animation('down')
			),
		]",
		
		animation: [
			{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "up",
				rect: [178,415,218,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "updiag",
				rect: [222,415,262,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "side",
				rect: [266,415,306,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "downdiag",
				rect: [310,415,350,458],
			},{
				image: "characters/frogatto-spritesheet2.png",
				pad: 3,
				frames: 2,
				frames_per_row: 1,
				duration: 5,
				no_remove_alpha_borders: true,
				id: "down",
				rect: [354,415,394,458],
			},
		],
	},
	
	
	#-------------------------- SHOTS --------------------------#
	{
		id: "bubble_shot",
		prototype: ["shot"],
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: true,
			attack_damage: "1",
			damage_cooldown: "10",
			is_aquatic: true,
			status_effects_this_attack_inflicts: "[enum bubble_trapped]",
			_last_played_pop_sound: { type: "int", default: 0, persistent: false },
			_parent_obj: { type: "obj frogatto_playable" },


			bubble_particles: {
				type: "obj legacy_particle_attache",
				init: "object('legacy_particle_attache', mid_x, mid_y, {
					_particle_type: 'underwater_bubbles',
					parent: me,
					time_to_die: 200,
					custom_relative_pos_default: {mid_x: 0, mid_y: 0},
					variable_name: 'bubble_particles',
				})",
				persistent: false,
			},

			death_effects: "def(string type) -> commands [
				spawn('frogatto_playable.bubble_shot_pop', mid_x, mid_y, 1),
				if(cycle - _last_played_pop_sound > 5, [set(_last_played_pop_sound, cycle), lib.sound.play_sound(me, 'bubble-pop')]),
				
				if(me.underwater, splash_effect()),
			]",
		},

		on_spawned: "[schedule(120, force_death() ), add_object(bubble_particles)]",
		
		on_exit_water: "set(velocity_y, 0)",
		on_end_normal_anim: "animation('big')",
		on_end_big_anim: "animation('big')",
		
		//Shim for exit_water not firing if we don't have a solid_area.
		on_process: "if(mid_y < _parent_obj.bubbles_die_here, fire_event('exit_water'))",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 3,
				duration: 8,
				rect: [62,2,71,11],
				attack_area: "all",
			},{
				image: "effects/particles2.png",
				pad: 3,
				id: "big",
				frames: 2,
				frames_per_row: 1,
				duration: 6,
				rect: [478,36,498,56],
				attack_area: "all",
			},
		],
	},
	{
		id: "bubble_shot_pop",
		on_end_anim: "remove_object(me)",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 2,
				duration: 4,
				rect: [101,2,110,11],
			},
		],
	},
	{
		id: "ink_blob_spawner",
		properties: {
			_parent_obj: { type: "obj frogatto_playable" },
		},
		hidden_in_game: true,
		on_process: "if(cycle%10 = 0, map(range(1d2),
						[ lib.sound.play_sound(me, 'baster-bubble'),
							spawn('frogatto_playable.ink_blob',
								mid_x,
								mid_y,
								{
									facing: facing,
									_parent_obj: me._parent_obj,
									velocity_x: (magnitude * cos(my_angle)) - me.velocity_x*0.25,
									velocity_y: (magnitude * sin(my_angle)) - me.velocity_y*0.25,
								})	where my_angle = 1d360
								where magnitude = 50+1d100
								]))
						",
					
		on_spawned: "schedule(150,die())",

		
		
	},
	
	{
		id: "ink_blob",
		prototype: ["shot"],
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: false,
			goes_through_enemy_shots: true,
			attack_damage: "20",
			damage_cooldown: "10",
			is_aquatic: true,
			_last_played_pop_sound: { type: "int", default: 0, persistent: false },
			_parent_obj: { type: "obj frogatto_playable" },


			death_effects: "def(string type) -> commands [
				map(range(10), spawn('frogatto_playable.ink_fragment',
					mid_x + 1d30-15,
					mid_y + 1d30-15,
				{
					velocity_x: 1d300-150,
					velocity_y: 1d300-150,
					rotate: 1d360,
				}))
			]",
		},
		
		on_exit_water: "set(velocity_y, 0)",
		on_end_normal_anim: "animation('normal')",
		on_end_pop_anim: "force_death()",
		on_collide_level: "",

		on_spawned: "schedule(60,animation('pop'))",
		
		//Shim for exit_water not firing if we don't have a solid_area.
		on_process: "if(mid_y < _parent_obj.bubbles_die_here, fire_event('exit_water'))",
		
		on_enter_pop_anim: "[
			set(velocity_x,0),
			set(velocity_y,0),
			if(cycle - _last_played_pop_sound > 5, [set(_last_played_pop_sound, cycle), lib.sound.play_sound(me, 'bubble-pop')])
		]",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 8,
				frames_per_row: 4,
				duration: 8,
				rect: [216,357,257,398],
				attack_area: "all",
			},{
				image: "effects/particles2.png",
				pad: 3,
				id: "pop",
				frames: 1,
				duration: 4,
				rect: [216,357,257,398],
			},
		],
	},

	{
		id: "ink_fragment",
		
		on_end_normal_anim: "remove_object(me)",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 5,
				frames_per_row: 1,
				duration: 7,
				rect: [189,319,208,338],
			}
		],
	},

	{
		id: "underwater_fire_blob_shot",
		prototype: ["shot"],
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: true,
			attack_damage: "10",
			damage_cooldown: "0",
			is_aquatic: true,
			_last_played_pop_sound: { type: "int", default: 0, persistent: false },
			_parent_obj: { type: "obj frogatto_playable" },


			burn_particles: {
				type: "obj legacy_particle_attache",
				init: "object('legacy_particle_attache', mid_x, mid_y, {
					_particle_type: 'fire_bubbles',
					parent: me,
					time_to_die: 20,
					custom_relative_pos_default: {mid_x: 0, mid_y: -2},
					variable_name: 'burn_particles',
				})",
				persistent: false,
			},

			death_effects: "def(string type) -> commands [
				spawn('frogatto_playable.bubble_shot_pop', mid_x, mid_y, 1),
				if(cycle - _last_played_pop_sound > 5, [set(_last_played_pop_sound, cycle), lib.sound.play_sound(me, 'bubble-pop')]),
				
				if(me.underwater, splash_effect()),
			]",
		},

		on_spawned: "[schedule(120, force_death() ), add_object(burn_particles)]",
		
		on_exit_water: "set(velocity_y, 0)",
		on_end_normal_anim: "animation('normal')",
		
		//Shim for exit_water not firing if we don't have a solid_area.
		on_process: "if(mid_y < _parent_obj.bubbles_die_here, fire_event('exit_water'))",
		
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 8,
				frames_per_row: 4,
				duration: 6,
				rect: [219,459,229,469],
				attack_area: "all",
			}
		],
	},

	
	{
		id: "acid_shot",
		dies_on_inactive: true,
		prototype: ["shot"],
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: true,
		on_collide_level: "force_death()",
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: true,
			attack_damage: 15,
			damage_cooldown: 20,
			damage_type: "enum acid",

			_parent_obj: { type: "obj frogatto_playable", persistent: false },
			
			death_effects: "def(string type) -> commands [
				lib.sound.play_sound(me, 'droplet-burst'),
				lib.sound.play_sound(me, 'acid-shot-fizz'),
				spawn('frogatto_playable.acid_shot_spawner',mid_x+1d20-10, mid_y -1d30, facing)
			]",


			light_circular: {
				type: "obj light_source_attache",
				init: "object('light_source_attache', mid_x, mid_y, {
					_sprite_type: enum eased_halo,
					time_to_die: 0,
					parent: me,
					custom_relative_pos_default: {mid_x: 0,	mid_y: 0},
					scale: 0.75,
					variable_name: 'light_circular',
				})",
				persistent: false,
			},
		},
		
		on_spawned: "[
			set(accel_y, 40),
			add_object(light_circular),
			lib.sound.play_sound(me, 'acid-belch'),
		]",
		on_end_normal_anim: "animation('normal')",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 3,
				duration: 2,
				reverse: true,

				rect: [108,53,125,70],
				attack_area: "all",
			}
		],
	},
	{
		id: "acid_shot_spawner",
		prototype: ["standard_values"],
		object_level_collisions: false,
		
		properties: {
			max_spread: 128,
			floor_height: "def(int x, int y) -> int|null if(floor_h, floor_h[1], null) where floor_h = _find_floor_standable(x,y,level.player)",
			
			spread_scale: "(_spread/24.0)",
			floor_for_visuals: "floor_height(int(x_for_visuals),mid_y)",
			x_for_visuals: "mid_x+lib.math.round((1d40-20) * spread_scale)",
			
			x_for_damager: "def(int index) -> int lib.math.round(index*60 - lib.math.round(0.8*20)*spread_scale)",
			floor_for_damager: "def(int index) -> int|null floor_height(mid_x+x_for_damager(index),mid_y)",
			
			_spread: { type: "int", default: 0 },
		},

		on_create: "schedule(150,die())",
		on_process:	"[
						[
							if(floor_for_visuals,
								[
									if(cycle%1=0,
										spawn('frogatto_playable.acid_secondary_shot',x_for_visuals, floor_for_visuals + 10-1d20, facing)
									), 
									if(cycle%2=1,
										spawn('frogatto_playable.acid_secondary_bubble',x_for_visuals, floor_for_visuals -5 -1d20, facing)
									)
								]
							), 
							if(cycle%10=0,
								map(range(lib.math.round(spread_scale*0.8)),
									if(floor_for_damager(index),
										spawn('frogatto_playable.acid_shot_damager',mid_x+x_for_damager(index), (int <- floor_for_damager(index)) -1d20, facing)
									)
								)
							)	
						],
						if(_spread < max_spread, add(_spread, 4))
					]",
		animation: [
			{
				image: "effects/particles2.png",
				id: "normal",
				frames: 1,
				duration: -1,
				rect: [127,19,128,20],
			}
		],
	},
	{
		id: "acid_shot_damager",
		dies_on_inactive: true,
		prototype: ["shot"],
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: false,
			attack_damage: 15,
			damage_cooldown: 5,
			damage_type: "enum acid",
		},
		on_create: "schedule(20,force_death())",
		animation: [
			{
				image: "effects/particles2.png",
				id: "normal",
				frames: 1,
				duration: -1,
				rect: [127,19,128,20],
				attack_area: [-15,-15,15,15,"solid"],
			}
		],
	},
	{
		id: "acid_secondary_shot",
		dies_on_inactive: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		on_create: "[set(velocity_x, 1d20-10),set(velocity_y, -20-1d70)]",
		on_end_normal_anim: "die()",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 10,
				frames_per_row: 5,
				duration: 5,

				rect: [127,19,133,25],
			}
		],
	},
	{
		id: "acid_secondary_bubble",
		dies_on_inactive: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		on_create: "[set(velocity_x, 1d20-10),set(velocity_y, -40-1d80)]",
		on_end_normal_anim: "die()",
		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 8,
				duration: 7,

				rect: [127,39,137,49],
			}
		],
	},
	{
		id: "super_acid_shot_damager",
		always_active: true,
		prototype: ["shot"],
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: false,
			attack_damage: 5,
			damage_cooldown: 5,
			damage_type: "enum acid",
			status_effects_this_attack_inflicts: "[enum poison]",
		},
		//on_process: "if(1d16=4,spawn('frogatto_playable.super_acid_shot_bubble', mid_x + 1d30-15, mid_y + 1d30-15, {facing: if(1d2=2,1,-1), rotate: 1d360}))",

		animation: [
			{
				image: "effects/particles2.png",
				id: "normal",
				frames: 1,
				duration: -1,
				rect: [127,19,128,20],
				attack_area: [-15,-15,15,15,"solid"],
			}
		],
	},
	{
		id: "super_acid_shot_bubble",
		dies_on_inactive: true,
		zorder: "@include data/zorder.cfg:in_front_of_everything",
		object_level_collisions: false,
		
		on_create: "[
						set(velocity_x, 1d20-10),
						set(velocity_y, 1d20-10),
						schedule(30,die()),
						animate(me, {
							alpha: 1.0,
						},{
							duration: 30,
						}),
					]",
		
//		on_process: "set(alpha, lib.math.round(0.90*alpha))",

		animation: [
			{
				image: "effects/particles2.png",
				pad: 3,
				id: "normal",
				frames: 3,
				duration: 2,
				reverse: true,

				rect: [108,53,125,70],
				attack_area: "all",
			}
		],
	},
	{
		id: "super_acidshot",
		always_active: true,
		prototype: ["transient_object"],

		properties: {
			circumference_for_circle_of_radius: "def(decimal radius) -> decimal 2.0 * 3.14592 * radius",

			circle_radius: "me.cycle*5",
			width_of_particle: "60",
			time_to_live: "100",

			number_of_particles_per_circle: "decimal :: lib.math.floor(circumference_for_circle_of_radius(circle_radius) / width_of_particle)",
			ang_offset: "def(decimal index) -> decimal 360.0/number_of_particles_per_circle * index",
			position_for_index: "def(int index, int x_base, int y_base) -> {x:decimal, y:decimal} {x: x_base + circle_radius * cos(ang_offset(index)), y: y_base + circle_radius * sin(ang_offset(index))}", 

			position_the_acid_balls: "map(acid_balls, [set(value.x, pos.x), set(value.y,pos.y)] where pos = position_for_index(index, me.mid_x, me.mid_y))",

			acid_balls: {type: "[obj frogatto_playable.super_acid_shot_damager]", default: [] },
			
			grow_acid_ball_set: "if(number_of_particles_per_circle > size(acid_balls), [add(acid_balls, new_acid_balls), map(new_acid_balls, schedule(1,add_object(value)))] where new_acid_balls = map(range(number_of_particles_per_circle - size(acid_balls)), object('frogatto_playable.super_acid_shot_damager', x,y,facing)))",
			
			
		},

		on_create: "[	set(alpha,0),
						schedule(time_to_live, fire_event('clear_objects') ),
						schedule(time_to_live, die()),
						spawn('silhouette_ring_expanding', {
							mid_x: mid_x,
							mid_y: mid_y,
							inner_radius: 0.0,
							outer_radius: 75.0,
							color: [140/255.0, 217/255.0, 107/255.5, 1.0],
						},[
							animate(child, {
								inner_radius: 500.0,
								outer_radius: 500.0,
								color: [140/255.0, 217/255.0, 107/255.5, 0.25],
							},{
								duration: 100,
								on_complete: remove_object(child)
							})
						]),
						
						spawn('particle_attache', {
							_particle_type: 'super_acidshot_ring_poison',
							x: mid_x,
							y: mid_y,
							parent: me,
							time_to_die: 200,
						},[
							set(child.circle_radius_random, { min: 0.0, max: 75.0 });
							animate(child, {
								circle_radius_random: { min: 450.0, max: 450.0 },
								emission_rate: 30000.0,
								alpha: 128,
							},{
								duration: 100,
								on_complete: child.turn_off
							})
						]),

					]",

		on_clear_objects: "map(acid_balls, set(value.hitpoints,0))",

		on_process: "[grow_acid_ball_set, position_the_acid_balls]",

	},
	{
		id: "ice_corona_damager",
		always_active: true,
		prototype: ["shot"],
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: false,
			attack_damage: 5,
			damage_cooldown: 5,
			damage_type: "enum ice",
			status_effects_this_attack_inflicts: "[enum frozen]",
		},

		animation: [
			{
				image: "effects/particles2.png",
				id: "normal",
				frames: 1,
				duration: -1,
				rect: [127,19,128,20],
				attack_area: [-15,-15,15,15,"solid"],
			}
		],
	},
	{
		id: "acidshot",
		//dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: 500,
		
		properties: {
			attack_damage: "lib.math.round(standard_thrown_damage*(1.0/2.0))",
			team: "'player'",
			dies_upon_dealing_damage: false,
			damage_cooldown: 60,
			damage_type: "enum acid",
			goes_through_enemy_shots: true,
		},
		
		
		on_create: "[
			schedule(80, force_death() ),
			lib.sound.play_sound(me, 'acid-lance-sizzle'),
			animation('intro'),

			spawn('particle_attache', {
				_particle_type: 'acid_spray',
				x: mid_x,
				y: mid_y,
				parent: me,
				facing: me.facing,
				time_to_die: 20,
			}),
			spawn('particle_attache',
				mid_x,
				mid_y,
			{
				_particle_type: 'acid_spray',
				custom_relative_pos_default: {mid_x: 30 * facing, mid_y: 0},
				parent: level.player,
				facing: me.facing,
				time_to_die: 30,
				
			},[
				schedule(20, [ ; child.schedule_death_cleanup]),
			]),
		]",

		on_process: "[
			set(velocity_x,lib.math.round(velocity_x*1.04)),
			set(velocity_y,lib.math.round(velocity_y*1.04)),
		]",
	
		
		on_end_anim: "animation('normal')",
		on_collide_level: "",

		animation: [
			{
				"@base": true,
				no_remove_alpha_borders: true,
				image: "effects/particles2.png",
				padding: 0,
				frames_per_row: 1,
			},
			{
				id: "normal",
				frames: 5,
				duration: 2,
				rect: [260,143,398,163],
				attack_area: "all",
			},
			{
				id: "intro",
				frames: 4,
				duration: 2,
				rect: [260,250,398,270],
				attack_area: "all",
			}
		],

	},	
	{
		id: "ice_corona_shot",
		always_active: true,

		properties: {
			circumference_for_circle_of_radius: "def(decimal radius) -> decimal 2.0 * 3.14592 * radius",

			circle_radius: "me.cycle*3",
			width_of_particle: "60",
			time_to_live: "100",
			
			number_of_particles_per_circle: "decimal :: lib.math.floor(circumference_for_circle_of_radius(circle_radius) / width_of_particle)",
			ang_offset: "def(decimal index) -> decimal 360.0/number_of_particles_per_circle * index",
			position_for_index: "def(int index, int x_base, int y_base) -> {x:decimal, y:decimal} {x: x_base + circle_radius * cos(ang_offset(index)), y: y_base + circle_radius * sin(ang_offset(index))}", 

			position_the_ice_balls: "map(ice_balls, [set(value.x, pos.x), set(value.y,pos.y)] where pos = position_for_index(index, me.mid_x, me.mid_y))",

			ice_balls: {type: "[obj frogatto_playable.ice_corona_damager]", default: [] },
			
			grow_ice_ball_set: "if(number_of_particles_per_circle > size(ice_balls), [add(ice_balls, new_ice_balls), map(new_ice_balls, schedule(1,add_object(value)))] where new_ice_balls = map(range(number_of_particles_per_circle - size(ice_balls)), object('frogatto_playable.ice_corona_damager', x,y,facing)))",
			
			do_cleanup: "[map(ice_balls, remove_object(value)), die()]",
		},

		on_create: "[
						set(alpha,0),
						spawn('silhouette_ring_expanding', {
							mid_x: mid_x,
							mid_y: mid_y,
							inner_radius: 0.0,
							outer_radius: 100.0,
							color: [37/255.0, 184/255.0, 236/255.5, 1.0],
						},[
							animate(child, {
								inner_radius: 300.0,
								outer_radius: 300.0,
								color: [37/255.0, 184/255.0, 236/255.5, 0.0],
							},{
								duration: 100,
								on_complete: remove_object(child)
							})
						]),
					]",

		on_process: "if(cycle < time_to_live,
						[grow_ice_ball_set, position_the_ice_balls],
						do_cleanup
					)",

	},
	{
		id: "fire_shot",
		prototype: ["shot"],
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: false,
			attack_damage: 50,
			damage_cooldown: 10,
			damage_type: "enum fire",
			
			_parent_obj: {type: "custom_obj", dynamic_initialization: true},
			death_effects: "def(string type) -> commands spawn('frogatto_playable.fire_shot_puff', mid_x + 10*sign(velocity_x), mid_y, facing)",


			light_circular: {
				type: "obj light_source_attache",
				init: "object('light_source_attache', mid_x, mid_y, {
					_sprite_type: enum eased_halo,
					time_to_die: 0,
					parent: me,
					custom_relative_pos_default: {mid_x: 0,	mid_y: 0},
					scale: 0.75,
					variable_name: 'light_circular',
				})",
				persistent: false,
			},
		},
		
		on_spawned: "[
			set(_parent_obj, arg.spawner),
			add_object(light_circular),
			
			schedule(6, force_death()),
		]",
		
		on_end_normal_anim: "animation('normal')",
		
		animation: [
			{
				"@base": true,
				image: "effects/particles2.png",
				pad: 3,
				no_remove_alpha_borders: true,
			},
			{
				id: "normal",
				frames: 4,
				duration: 2,
				rect: [2,113,15,130],
				body_area: "all",
				attack_area: "all",
			}
		],
	},
	{
		id: "fire_shot_puff",
		prototype: ["transient_object"],
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",

		properties: {
			light_circular: {
				type: "obj light_source_attache",
				init: "object('light_source_attache', mid_x, mid_y, {
					_sprite_type: enum eased_halo,
					time_to_die: 0,
					parent: me,
					custom_relative_pos_default: {mid_x: 0,	mid_y: 0},
					scale: 0.75,
					variable_name: 'light_circular',
				})",
				persistent: false,
			},

		},



		on_create: "[
			add_object(light_circular),
			set(velocity_x,0),
			set(velocity_y,-200-1d100),
			facing(if(1d2=2,1,-1)),
			set(zsub_order,-10),
		]",

		on_end_anim: "remove_object(me)",

		animation: [
			{
				"@base": true,
				image: "effects/particles2.png",
				pad: 3,
			},
			{
				id: "normal",
				frames: 3,
				duration: 2,
				rect: [2,134,15,151],
			},
		],
	},
	{
		id: "fire_shot_arc",
		prototype: ["shot"],
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		solid_area: [4,5,9,10],
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: true,
			attack_damage: 50,
			damage_cooldown: 10,
			damage_type: "enum fire",
			
			_parent_obj: {type: "custom_obj", dynamic_initialization: true},
			death_effects: "def(string type) -> commands spawn('frogatto_playable.fire_shot_puff', mid_x + 10*sign(velocity_x), mid_y, facing)",
			
			
			dies_upon_colliding_with_level: "bool :: false",

			termination_counter: { type: "int", default: 10 },
			increment_termination_counter: "commands :: if(termination_counter > 0, 
															add(termination_counter, -1),
															me.force_death()
														)",
			
			_contrail_particles: {
				type: "obj particle_attache",
				init: "object('particle_attache', mid_x, mid_y, {
					_particle_type:'fireball_sparks',
					parent: me,
					zsub_order: -1,
					time_to_die: 60,
				})",
				persistent: false,
			},
			
			_glow_effect: {
				type: "obj effects_attache_glow_source",
				init: "object('effects_attache_glow_source', mid_x, mid_y, {
					time_to_die: 0,
					parent: me,
					base_alpha: 160,
					flicker_type: enum sputter,
					graphics: enum firey,
					scale_factor: 0.32,
				})",
				persistent: false,
			},
			

			terrain_response_head: "commands :: [
					play_sound__falloff('fireball-bounce', {max_volume: 0.8}),
					set(velocity_x, speed * (vel_xy_after_reflection.x)),
					set(velocity_y, speed * (vel_xy_after_reflection.y)),
					increment_termination_counter,
				]",
		
			terrain_response_side: "commands :: [
					play_sound__falloff('fireball-bounce', {max_volume: 0.8}),
					set(velocity_x, speed * (vel_xy_after_reflection.x)),
					set(velocity_y, speed * (vel_xy_after_reflection.y)),
					increment_termination_counter,
				]",
			
			terrain_response_feet: "commands :: [
					play_sound__falloff('fireball-bounce', {max_volume: 0.8}),
					set(velocity_x, speed * (vel_xy_after_reflection.x)),
					set(velocity_y, speed * (vel_xy_after_reflection.y)),
					increment_termination_counter,
				]",

			angle_after_reflection: "decimal :: (get_ground_angle_from_xy_values) + (motion_angle + 180)",
			vel_xy_after_reflection: "{x: decimal, y: decimal} :: unit_triangle_xy_components_for_angle(angle_after_reflection)",
				
			light_circular: {
				type: "obj light_source_attache",
				init: "object('light_source_attache', mid_x, mid_y, {
					_sprite_type: enum eased_halo,
					time_to_die: 0,
					parent: me,
					custom_relative_pos_default: {mid_x: 0,	mid_y: 0},
					scale: 0.75,
					variable_name: 'light_circular',
				})",
				persistent: false,
			},
		},
		
		on_create:"[
			lib.sound.play_sound(me, 'fireball-throw'),
		]",
		
		on_spawned: "[
			set(_parent_obj, arg.spawner),
			add_object(light_circular),
			add_object(_contrail_particles),
			add_object(_glow_effect),
			
			schedule(160, force_death()),
		]",
		
		on_end_normal_anim: "animation('normal')",
		
		on_process: "set_rotation_to_angle_of_motion",
		
		animation: [
			{
				"@base": true,
				image: "effects/particles2.png",
				pad: 3,
				no_remove_alpha_borders: true,
			},
			{
				id: "normal",
				accel_y: 30,
				frames: 4,
				duration: 2,
				rect: [2,113,15,130],
				//body_area: "all",
				attack_area: "all",
			}
		],
	},
	{
		id: "super_fire_attack",
		prototype: ["shot"],
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		solid_area: [5,5,10,10],
		
		properties: {
			team: "'player'",
			dies_upon_dealing_damage: true,
			attack_damage: 50,
			damage_cooldown: 10,
			damage_type: "enum fire",
			
			_parent_obj: {type: "custom_obj", dynamic_initialization: true},
			death_effects: "def(string type) -> commands spawn('frogatto_playable.fire_shot_puff', mid_x + 10*sign(velocity_x), mid_y, facing)",
			
			status_effects_this_attack_inflicts: "[enum exploding]",
			
			do_stuff: "map( filter(level.active_chars, value is obj hittable_enemy), status_effect_add(enum exploding, value) )",
		},
		
		on_spawned: "[
			set(_parent_obj, arg.spawner),
			do_stuff,
			
			schedule(160, force_death()),
		]",
		
		on_end_normal_anim: "animation('normal')",
		
		
		animation: [
			{
				"@base": true,
				image: "effects/particles2.png",
				pad: 3,
			},
			{
				id: "normal",
				accel_y: 30,
				frames: 4,
				duration: 2,
				rect: [2,113,15,130],
				//body_area: "all",
				attack_area: "all",
			}
		],
	},

	{
		id: "reflector_bubble",
		prototype: ["shot"],
		
		properties: {
			team: "'player'",
			handle_attack_area_collision_with_hittable_body:  "def(obj hittable collide_with) -> commands execute(me,
				if(collide_with.is_a_shot, 
					[
						collide_with.force_death(),
						lib.sound.play_sound(me, 'metal bonk'),
						spawn('frogatto_playable.reflector_bubble_reflected_shot', collide_with.mid_x, collide_with.mid_y, {
							velocity_x: spd * vel_xy_after_reflection.x,
							velocity_y: spd * vel_xy_after_reflection.y,
							rotate: reflected_angle,
						}),
					] 
						where spd = collide_with.speed
						where vel_xy_after_reflection = ({x: decimal, y: decimal} :: unit_triangle_xy_components_for_angle(reflected_angle))
						where reflected_angle = (incident_angle) + 180 /*((collide_with.motion_angle) + 180)*/
						where incident_angle = lib.math.angle(collide_with, me)
				)
			)",
			ignores_object_level_collisions: true,
		},
		
		animation: [
			{
				"@base": true,
				image: "effects/bubble-giant.png",
				pad: 3,
			},
			{
				id: "normal",
				frames: 1,
				duration: 2,
				rect: [1,1,93,93],
				body_area: "none",
				attack_area: "all",
			}
		],
	},
	{
		id: "reflector_bubble_reflected_shot",
		dies_on_inactive: true,
		prototype: ["shot"],
		properties: {
			team: "'player'",
			attack_damage: "standard_thrown_damage",
			goes_through_enemy_shots: true,
			ignores_object_level_collisions: true,
		},
		on_end_anim: "set(animation,animation)",
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			rect: [261,108,287,134],
			pad: 3,
			frames: 3,
			duration: 2,
		},
	},
	{
		id: "super_fireball",
		dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: 500,
		solid_area: [10,10,22,22],
		
		properties: {
			attack_damage: "0", //rely entirely on the explosion for the actual damage
			team: "'player'",
			damage_type: "enum fire",
			goes_through_enemy_shots: true,
			death_effects: "def(string type) -> commands [
				lib.sound.play_sound(me, 'fire-explode'),
				spawn('explosion_huge_harmful', mid_x, mid_y, {facing: facing, _shot_by_player: true}),
				level.player.screen_shake(if(facing = 1,180,0),400,30-1d60,20,4.0)
			]",

			light_circular: {
				type: "obj light_source_attache",
				init: "object('light_source_attache', mid_x, mid_y, {
					_sprite_type: enum eased_halo,
					time_to_die: 0,
					parent: me,
					custom_relative_pos_default: {mid_x: 0,	mid_y: 0},
					scale: 1.0,
					variable_name: 'light_circular',
				})",
				persistent: false,
			},
		},
		
		
		on_create: "[
			add_object(light_circular),
			level.player.screen_shake( if(facing = 1,180,0), 200 ,5-1d10, 25, 2.5),
			set(time_in_animation, 1d6),
			lib.sound.play_sound(me, 'fire-stream', { volume: 0.6 }),
			schedule(50,force_death()),
		]",
	
		on_process: "[
			if(cycle%2 = 1, spawn('explosion_spark', mid_x, mid_y, facing)),
			//set(velocity_x,velocity_x*0.97),
			//set(velocity_y,velocity_y*0.97),
			set(light_circular.scale, sin(cycle*100 + 1d20)/2.0 ),
		]",

		
		on_end_anim: "animation('normal')",
		
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			rect: [107,74,138,105],
			pad: 3,
			frames: 8,
			frames_per_row: 4,
			duration: 2,
		},
	},
	{
		id: "energyshot",
		//dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		
		properties: {
			attack_damage: 20,
			team: "'player'",
			damage_type: "enum energy",
			
			death_effects: "def(string type) -> commands [
					spawn('frogatto_playable.energyshot_bloom',mid_x,mid_y,0),
					lib.sound.play_sound(me, 'energyshot-impact'), 
				]",


			incept_angle: { type: "int", dynamic_initialization: true },
			_damage_beam: {
				type: "obj damage_beam_attache",
				init: "object('damage_beam_attache', mid_x, mid_y, {
					parent: me,
					relative_x: 0,
					relative_y: 0,
					beam_distance: 30,
					attack_diameter: 10,
				})",
				persistent: false,
			},


			my_particles: {
				type: "obj legacy_particle_attache",
				init: "object('legacy_particle_attache', mid_x, mid_y, {
					_particle_type: 'energy_shot_contrail',
					parent: me,
					time_to_die: 50,
					variable_name: 'my_particles',
					zsub_order: -1,
				})",
				persistent: false,
			},


			light_circular: {
				type: "obj light_source_attache",
				init: "object('light_source_attache', mid_x, mid_y, {
					_sprite_type: enum eased_halo,
					time_to_die: 0,
					parent: me,
					custom_relative_pos_default: {mid_x: 0,	mid_y: 0},
					scale: 1.0,
					variable_name: 'light_circular',
				})",
				persistent: false,
			},
		},
		
		on_create: "[
			add_object(_damage_beam),
			add_object(light_circular),
			add_object(my_particles),
			set(_damage_beam.beam_angle, incept_angle),
			set(_damage_beam.relative_x, 0),
			set(_damage_beam.relative_y, 0),
			set(time_in_animation, 1d6),
			lib.sound.play_sound(me, 'energy-shot-medium'),
			schedule(30, me.force_death() ),
			spawn('frogatto_playable.energyshot_bloom',mid_x,mid_y,0),
		]",
	
		on_process: "[
			set(velocity_x,velocity_x*0.97),
			set(velocity_y,velocity_y*0.97),
			set(light_circular.scale, sin(cycle*100 + 1d20)/2.0 )
		]",

		on_end_anim: "animation('normal')",
		
		animation: {
			body_area: "all",
			//attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x: 3,
			y: 15,
			w: 10,
			h: 10,
			pad: 3,
			frames: 4,
			duration: 2,
		},
	},
	{
		id: "energyshot_bloom",
		prototype: ["transient_object"],
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: -10,

		properties: {
			#-------------------------- constructor/destructor --------------------------#
			/*
				We want to spawn a bunch of particles at the start, and then stop, so we schedule an event to stop spawning immediately after we are created.
			*/

			transient_obj_constructor: "[
				set(rotate, 1d360),
				add_object(my_particles),
				;
				my_particles.turn_on,
				;
				schedule(3, bind_command(def() execute(me, my_particles.turn_off ))),
			]",


			#-------------------------- fx --------------------------#
			my_particles: {
				type: "obj legacy_particle_attache",
				init: "object('legacy_particle_attache', mid_x, mid_y, {
					_particle_type: 'energy_shot_contrail',
					parent: me,
					time_to_die: 50,
					variable_name: 'my_particles',
					zsub_order: -1,


					customized_spawn_rates: [{
						particle_id: 'energy_shot_contrail',
						magnitude: 10000,
					}],

				})",
				persistent: false,
			},
		
		},


		on_end_anim: "[
			animation('invis'),
			schedule(30, die()), 
		]",
	
		
		animation: [{
			"@base": true,
			image: "effects/powerup-fx.png",
			x: 122, y: 2, w: 21, h: 23,
			pad: 3,
			frames: 8,
			frames_per_row: 4,
			duration: 2,
		},
		{
			id: "sparkle",
		},
		{
			id: "invis",
			w: 0, h: 0,		
		}],
	},
	
	{
		id: "super_energyshot",
		//dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: 500,
		
		properties: {
			attack_damage: "lib.math.round(standard_thrown_damage*(1.0/3.0))",
			team: "'player'",
			dies_upon_dealing_damage: false,
			damage_cooldown: 6,
			damage_type: "enum energy",
			goes_through_enemy_shots: true,
			ignores_object_level_collisions: true,

			light_circular: {
				type: "obj light_source_attache",
				init: "object('light_source_attache', mid_x, mid_y, {
					_sprite_type: enum eased_halo,
					time_to_die: 0,
					parent: me,
					custom_relative_pos_default: {mid_x: 0,	mid_y: 0},
					scale: 1.0,
					variable_name: 'light_circular',
				})",
				persistent: false,
			},

			my_particles: {
				type: "obj legacy_particle_attache",
				init: "object('legacy_particle_attache', mid_x, mid_y, {
					_particle_type: 'energy_shot_contrail',
					parent: me,
					time_to_die: 50,
					variable_name: 'my_particles',
					zsub_order: -1,


					customized_spawn_rects: [{
						particle_id: 'energy_shot_contrail',
						rect: [-16, 16, -18, 18],
					}],

				})",
				persistent: false,
			},
		},
		
		
		on_create: "[
			level.player.screen_shake( if(facing = 1,180,0), 200 ,5-1d10, 25, 2.5),
			add_object(light_circular),
			add_object(my_particles),
		
			set(animation, 'init'),
			lib.sound.play_sound(me, 'energy-shot-uber'),
			lib.sound.play_sound(me, 'energy-uber-fizzle'),
			schedule(80,animation('dissipate')),
		]",
	
		on_process: "[
			set(velocity_x,lib.math.round(velocity_x*1.01)),
			set(velocity_y,lib.math.round(velocity_y*1.01)),
			set(light_circular.scale, sin(cycle*100 + 1d20)/2.0 )
		]",

		
		on_end_anim: "if(animation = 'dissipate', force_death(), animation('normal'))",
		
		animation: [
		{
			//body_area: "all",
			id: "init",
			image: "effects/particles2.png",
			x:111, y:319, w:36, h:32,
			attack_area: [0,0,32,32,"solid"],
			pad: 3,
			frames: 8,
			frames_per_row: 2,
			duration: 2,
			feet_x: 18,
			feet_y: 16,
		},
		{
			//body_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x:154, y:144, w:100, h:32,
			attack_area: [0,0,100,32,"solid"],
			pad: 3,
			frames: 5,
			frames_per_row: 1,
			duration: 2,
			feet_x: 76 ,
			feet_y: 16,
		},
		{
			body_area: "all",
			id: "dissipate",
			image: "effects/particles2.png",
			x:247, y:1, w:36, h:32,
			attack_area: [0,0,36,32,"solid"],
			pad: 3,
			frames: 12,
			frames_per_row: 4,
			duration: 4,
			feet_x: 18 ,
			feet_y: 16,
		},
		],
	},

	
	{
		id: "super_homingshot",
		//dies_on_inactive: true,
		
		properties: {
			orb_count: "5",
			current_angle: "decimal :: cycle*2.5",
			ang_offset: "def(int n) -> decimal n*(360.0/orb_count)",
			radius: "int :: int(min(cycle/0.5,110))",
			
			_orbs: { type: "[custom_obj]|null", default: null },
		},
		
		on_create: "[
			map(filter(level.player.spawned_children, value is obj frogatto_playable.super_homingshot and value != me), fire_event(value, 'remove')),
			set(parent,level.player),
			[ spawn('frogatto_playable.super_homingshot_orb',mid_x,mid_y,facing, [add(me._orbs, [child])]) | value <- range(orb_count)],
			lib.sound.play_sound(me, 'energyshot'),
			schedule(900,fire_event(me,'remove')),
		]",
		
		on_process: "[set(relative_x,0),set(relative_y,0),
					 if(me._orbs != null,
						map(me._orbs,
						[set(value.mid_x, me.mid_x + radius*cos(current_angle + ang_offset(index))),
						set(value.mid_y, me.mid_y + radius*sin(current_angle + ang_offset(index)))] ))]",
	
		on_remove: "[ [(obj hittable <- value).force_death() | value <- me._orbs], die()]",

		
		on_end_anim: "animation('normal')",
		on_collide_level: "",
		
		animation: {
			id: "normal",
			image: "effects/particles2.png",
			x:111, y:319, w:1, h:1,
			pad: 3,
			frames: 8,
			frames_per_row: 2,
			duration: 2,
			feet_x: 18,
			feet_y: 16,
		},

	},

	{
		id: "super_homingshot_orb",
		//dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			goes_through_enemy_shots: true,
			dies_upon_dealing_damage: false,
			attack_damage: 13,
			damage_cooldown: 10,
			damage_type: "enum arcane",
			team: "'player'",
			
			death_effects: "def(string type) -> commands [
					spawn('frogatto_playable.homingshot_bloom', mid_x, mid_y, 0),
					lib.sound.play_sound(me, 'homingimpact'), 
				]",
		
		
			my_particles: {
				type: "obj legacy_particle_attache",
				init: "object('legacy_particle_attache', mid_x, mid_y, {
					_particle_type: 'arcane_shot_contrail',
					parent: me,
					time_to_die: 50,
					variable_name: 'my_particles',
					zsub_order: -1,
				})",
				persistent: false,
			},
		
			epihittable_obj_constructor: "[
				set(time_in_animation, 1d6),
				spawn('frogatto_playable.homingshot_bloom',midpoint_x,midpoint_y,0), 
				add_object(my_particles),
			]",
		
		},
				
	
		on_end_anim: "[animation('normal')]",
		
		animation: {
			scale: 5,
			body_area: "none",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x: 1,
			y: 208,
			w: 15,
			h: 15,
			pad: 3,
			frames: 4,
			duration: 1,
		},

	},
	
	{
		id: "homingshot_bloom",
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: -10,
		
		on_end_anim: "die()",

		animation: {
			id: "sparkle",
			image: "effects/homing-shot-init.png",
			rect: [1,1,31,31],
			frames:9,
			frames_per_row:3,
			duration: 2,
			pad: 3,
		},
	},


	{
		id: "homingshot_impact",
		prototype: ["transient_object"],
		dies_on_inactive: true,
		ignore_collide: true,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		zsub_order: -10,


		properties: {
			#-------------------------- constructor/destructor --------------------------#
			/*
				We want to spawn a bunch of particles at the start, and then stop, so we schedule an event to stop spawning immediately after we are created.
			*/

			transient_obj_constructor: "[
				add_object(my_particles), 
				schedule(3, my_particles.turn_off),
			]",


			#-------------------------- fx --------------------------#
			my_particles: {
				type: "obj legacy_particle_attache",
				init: "object('legacy_particle_attache', mid_x, mid_y, {
					_particle_type: 'arcane_shot_contrail',
					parent: me,
					time_to_die: 50,
					variable_name: 'my_particles',
					zsub_order: -1,
				})",
				persistent: false,
			},
		
		},

		on_end_anim: "[
			animation('invis'),
			schedule(30, die()), 
		]",

		
		animation: [{
			"@base": true,
			image: "effects/homing-shot-impact.png",
			x: 1, y: 1, w: 30, h: 40,		
			frames:11,
			duration: 3,
			pad: 3,
		},
		{
			id: "sparkle",
		},
		{
			id: "invis",
			w: 0, h: 0,		
		}],
	},
	{
		id: "homingshot",
		//dies_on_inactive: true,
		prototype: ["shot"],
		mass: 2,
		zorder: "@include data/zorder.cfg:near_player_foreground_effects",
		object_level_collisions: false,
		
		properties: {
			goes_through_enemy_shots: true,
			attack_damage: 50,
			damage_type: "enum arcane",
			team: "'player'",
			speed: 700,
			accel_speed: 0.2,
			decay: 0.99,
			multiplier_x: "if(_target_lock != null, cos(lib.math.angle(me,_target_lock)), 1.0)",
			multiplier_y: "if(_target_lock != null, sin(lib.math.angle(me,_target_lock)), 1.0)",
			my_angle: "if(_target_lock != null, lib.math.angle(me,_target_lock), 0)",
			nearest_enemy: "choose(filter(filter(level.active_chars, value is obj hittable),
								value.team = 'evil' and (not value.is_a_shot = true) and value.is_a_physical_gameplay_object),
									-lib.math.length(value, self)) or level.player",
			
			_target_lock: { type: "custom_obj|null", default: null },


			death_effects: "def(string type) -> commands [
					spawn('frogatto_playable.homingshot_impact', mid_x, mid_y, 0, set(child.rotate,my_angle)),
					spawn('frogatto_playable.homingshot_bloom', mid_x, mid_y, 0),
					lib.sound.play_sound(me, 'homingimpact'), 
				]",
				
			_damage_beam: {
				type: "obj damage_beam_attache",
				init: "object('damage_beam_attache', mid_x, mid_y, {
					parent: me,
					relative_x: 0,
					relative_y: 0,
					beam_distance: 30,
					attack_diameter: 10,
				})",
				persistent: false,
			},

			my_particles: {
				type: "obj legacy_particle_attache",
				init: "object('legacy_particle_attache', mid_x, mid_y, {
					_particle_type: 'arcane_shot_contrail',
					parent: me,
					time_to_die: 50,
					variable_name: 'my_particles',
					zsub_order: -1,
				})",
				persistent: false,
			},


			light_circular: {
				type: "obj light_source_attache",
				init: "object('light_source_attache', mid_x, mid_y, {
					_sprite_type: enum eased_halo,
					time_to_die: 0,
					parent: me,
					custom_relative_pos_default: {mid_x: 0,	mid_y: 0},
					scale: 1.0,
					variable_name: 'light_circular',
				})",
				persistent: false,
			},
		},
		
		on_create: "[
			add_object(_damage_beam),
			add_object(light_circular),
			add_object(my_particles),
			set(time_in_animation, 1d6),
			lib.sound.play_sound(me, 'homing'),
			schedule(250,force_death()),
			set(_target_lock, nearest_enemy),
			spawn('frogatto_playable.homingshot_bloom',mid_x, mid_y,0), 
		]",
		
		on_process: "[
			if(_target_lock, [
				set(velocity_x, median(-speed, velocity_x*decay + multiplier_x*speed*accel_speed, speed)),
				set(velocity_y,median(-speed,velocity_y*decay+multiplier_y*speed*accel_speed,speed)),
			],[
				set(velocity_x, 600*sign(velocity_x)),
				set(velocity_y, 600*sign(velocity_y)),
				set(_target_lock, nearest_enemy),
			]),
			set(light_circular.scale, sin(cycle*100 + 1d20)/2.0 ),
			
			set(_damage_beam.beam_angle, facing_adjusted_velocity_angle -180),
		]",

				
		timer_frequency: 21,
		on_timer: "if((not _target_lock in level.active_chars) or _target_lock = level.player, set(_target_lock, nearest_enemy))",
		
		on_end_anim: "[animation('normal')]",
		
		animation: {
			body_area: "all",
			attack_area: "all",
			id: "normal",
			image: "effects/particles2.png",
			x: 1,
			y: 208,
			w: 15,
			h: 15,
			pad: 3,
			frames: 4,
			duration: 1,
		},
		
	},
],

}
