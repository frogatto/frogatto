{
id: "kitty_sniper",
prototype: ["kitty"],
solid_area: [21,16,45,38],
is_strict: true,
has_feet: true,

editor_info: {
	"@derive": "@include data/object_prototypes/enemies_general_types/kitty.cfg:editor_info",
	help: "Processor-heavy object! A sniper kitty who tries to shoot Frogatto. Somewhat experimental...",
},

properties: {
#-------------------------- constructor/destructor logic --------------------------#
	specialized_creature_category_constructor: "[
													animation('snipe'), 
													set(time_in_animation_delta, 1),
													add_object(reticule), 
													add_object(sniper_ray), 
													set(sniper_ray.zorder, me.zorder-1),
													//show_points(),
												]",

	specialized_creature_category_destructor: "[
													remove_object(sniper_ray)
												]",


#-------------------------- hittable metadata --------------------------#
	title: "~Sniper Kitty~", //duplicated in kitty_sniper_background.cfg
	description: "~Boom, headshot.~",
	taste: "~Dry.~",


#-------------------------- gameplay functionality --------------------------#
	range: "{
		min: 50,
		max: if(higher_difficulty, 1000, 500), //in level coordinates
	}",
	  
	gunsight_distance_from_source: 20,

	target: "level.player",
	
	granularity: 4,

#-------------------------- cosmetic stuff for the kitty itself --------------------------#
		/*
			Point the kitty, visually, in the right direction.
			
			This uses a "cheap trick" where we just have one animation for the full 360° rotation of the kitty, and we use "manual adjustment of frame timing" to actually point it at the player.
		*/
	aim_at: "def(PointLike target)->commands [
		if(0 < frame and frame < frames/2, set(facing, -1)), //Don't flip for straight up/down, to add in a little continuity/personality/lazyness.
		if(frames/2 < frame and frame < frames, set(facing, 1)),
		set(time_in_animation, int(lib.math.interpolate([0,8,0], frame/1.0/frames))), //We've got separate animations for straight up and down, so we animate up to and back down from the apex.
	] where frame = m.loop(m.round(m.angle(me, target)/(360/16.0)-frames/4), frames)
	  where m = lib.math
	  where frames = 16",
	  

#-------------------------- line of sight calculations for the shot being fired --------------------------#
		/*
			This gets used for one end of a line segment - this represents the "breech" (the deep-inside-the-gun end of the barrel) where the shots starts;  this is just a visual offset so the shot comes out of the middle of the kitty and not out of some other visually weird spot.
		*/
	gunsight_source: "Point <- zip(me.midpoint_xy, [0,14])", //TODO: Factor in distance to rifle barrel here?

		/*
			And this is the other end of the line segment - what's being shot at.
		*/
	target_position: "Point <- lib.standardize.toPoint(target)",
	
	
		/*
			This is how many recursive "solidity checks" we do along the line between the shooter and the victim.
		*/
	steps_to_target: "int <- max(abs(gunsight_source[0]-target.mid_x), abs(gunsight_source[1]-target.mid_y))/granularity",

	
		/*
			Return a list of points on the line of sight between the sniper kitty and frogatto.
		*/
	line_of_sight: "[Point] <- map(range(steps_to_target+1), 'step', [
		//lib.math.interpolate(gunsight_source, step/1.0/steps_to_target, target_position))
		(target_position[0]*(percent) + gunsight_source[0]*(1.0-percent)),
		(target_position[1]*(percent) + gunsight_source[1]*(1.0-percent))
	] where percent = step/1.0/steps_to_target)",

		
		/*
			Used to find 1) how many samples from the point of origin the collision is and 2) what we're actually colliding with.
		*/
	steps_to_collision: "def([Point] steps, int iteration=0) -> {step: int, obj: null | obj hittable} //This doesn't work, returning merely a bunch of strings - a list of valid functions?
		base iteration = size(steps): 
			{step: iteration-1, obj: null} //No collisions.
		base solid(level, int(steps[iteration][0]), int(steps[iteration][1])): 
			{step: iteration, obj: null} //Level collision.
		base find(filter(level.active_chars, value is obj hittable and value not in [me, me.target]), 'char', 
				char.solid_rect.x < steps[iteration][0] and steps[iteration][0] < char.solid_rect.x2 and
				char.solid_rect.y < steps[iteration][1] and steps[iteration][1] < char.solid_rect.y2) :
			{step: iteration, obj:
			find(filter(level.active_chars, value is obj hittable and value not in [me, me.target]), 'char', 
				char.solid_rect.x < steps[iteration][0] and steps[iteration][0] < char.solid_rect.x2 and
				char.solid_rect.y < steps[iteration][1] and steps[iteration][1] < char.solid_rect.y2) }
		recursive: steps_to_collision(steps, iteration+1)",



	process_aiming: "commands :: if(lib.math.length(me, target) < range.max, [
			me.aim_at(target),
			set(reticule.mid_xy, target.mid_xy),
			sniper_ray.set_ends(gunsight_source[0], gunsight_source[1], cs[0], cs[1]) where cs = los[collision.step],
			set(reticule.alpha, if(can_see_target, int(lib.math.interpolate([200, 200, 200, 255], target_sighted_duration/1.0/target_sighted_duration_needed)), 127)),
			//set(sniper_ray.alpha, if(can_see_target, int(lib.math.interpolate([200, 200, 200, 255], target_sighted_duration/1.0/target_sighted_duration_needed)), 127)),
			if(not can_see_target, [
				set(target_sighted_duration, 0),
			],[
				add(target_sighted_duration, 1),
				if(target_sighted_duration = target_sighted_duration_needed, [
					fire_shot,
					/*
						if(collision.obj, collision.obj.get_hit_sourceless(enum lacerate, 200), target.get_hit_sourceless(enum lacerate, 2)),
					*/
					set(target_sighted_duration, 0),
				]),
			]),
		]	where can_see_target = collision.obj or collision.step >= steps_to_target
			where collision = steps_to_collision(los)
			where los = line_of_sight, 
		[
			set(reticule.alpha, 0),
			set(sniper_ray.alpha, 0),
			set(target_sighted_duration, 0),
		])",

#-------------------------- shot firing logic --------------------------#
		unit_triangle_xy_components_for_angle: "def(decimal angle) -> {x: decimal, y: decimal} {x: cos(angle), y: sin(angle)}",
		angle_components_to_player: "{x: decimal, y: decimal} :: unit_triangle_xy_components_for_angle( lib.math.angle(me, level.player) )",

		fire_shot: "commands :: [
							spawn('kitty_sniper.muzzle_flash',
								mid_x + muzzle_flash_offset * ang.x,
								mid_y + 14 + muzzle_flash_offset * ang.y,
							{
								rotate: lib.math.angle(me, level.player) + 90,
							}),
		
		
							spawn('kitty_sniper.shot',
								mid_x + shot_offset * ang.x,
								mid_y + 14 + shot_offset * ang.y,
							{
								rotate: lib.math.angle(me, level.player) + 90,
								velocity_x: shot_speed * ang.x,
								velocity_y: shot_speed * ang.y,
							})
						] where ang = angle_components_to_player where shot_speed = 5000
						  where muzzle_flash_offset = 62
						  where shot_offset = 22",


#-------------------------- master control logic --------------------------#
		/*
			There's a whole mess of logic for controlling the behavior of this object when it's ready to shoot.   However, being ready to shoot is only a condition that's active a small percentage of the time - the rest of the time, these guys pace back and forth, like other kitties.
		
		*/
	player_noticeable: "bool :: (player_in_decent_y_pos and abs(level.player.midpoint_x - self.midpoint_x) < if(self.facing = desired_facing, front_detection_area, rear_detection_area))",

	rear_detection_area: "int :: range.max/2",
	front_detection_area: "int :: range.max",


	choose_action: "commands :: if(dump(player_noticeable), if(not animation = 'snipe', animation('snipe')), animation('walk'))",

	player_in_decent_y_pos: "true",




#-------------------------- some object references --------------------------#
		
	sniper_ray: {
		type: "obj rope_angled_controller", 
		init: "object('rope_angled_controller', me.x, me.y, {animation: 'tongue'})",
	},
	
	reticule: {
		type: "obj kitty_sniper.reticule", 
		init: "object('kitty_sniper.reticule', me.x, me.y, 1)",
	},
	
	target_sighted_duration: {type: "int", default: 0},
	target_sighted_duration_needed: "1*50", //1s @ 50fps
	
		/*
			A debug function you can use (would need some cleanup for live usage) to see where along the shooting path the individual solidity-testing nodes are.
		*/
	show_points: "def() -> commands map(line_of_sight, spawn('target', value[0], value[1], {scale: 0.5}))",

},

on_process_snipe: "[process_aiming, choose_action]",
//on_process: "process_aiming",

animation: [
	{
		"@base": true,
		image: "enemies/kitty-sniper.png",
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		rotate_on_slope: true,
		body_area: "all",
		no_remove_alpha_borders: true,
	},

	{
		id: "stand",
		rect: [1,83,68,151],
		frames: 1,
		duration: 8,
	},
	{
		id: "turn",
		rect: [1,83,68,151],
		frames: 1,
		duration: 8,
	},
	{
		id: "spring",
		rect: [1,83,68,151],
		frames: 1,
		duration: 8,
	},
	{
		id: "hurt",
		rect: [1,83,68,151],
		frames: 1,
		duration: 8,
	},
	{
		accel_x: 300,

		id: "walk",
		rect: [1,83,68,151],
		frames: 4,
		duration: 6,
		events: "0:12:footfall",
	},


	{
		id: "snipe", //One frame for each of the drawn 180° rotations.
		no_remove_alpha_borders: true,
		rect: [1,1,68,71],
		frames: 9,
		duration: 1,
	},
],

object_type: [{
	id: "smoke_trail",
	is_strict: true,
	zorder: "@include data/zorder.cfg:in_front_of_everything",
	
	animation: {
		id: "disperse",
		image: "enemies/kitty-sniper-bullet.png",
		rect: [1,0,10,9],
		frames: 4,
		pad: 3,
		duration: 4,
	},
},{
	id: "muzzle_flash",
	zorder: "@include data/zorder.cfg:in_front_of_everything",
	
	on_end_anim: "die()",
	
	animation: {
		id: "normal",
		image: "enemies/kitty-sniper-shot-muzzle-flash.png",
		x: 0,
		y: 0,
		w: 41,
		h: 41,
		frames: 8,
		pad: 0,
		duration: 2,
		no_remove_alpha_borders: true,
	},
},{
	id: "shot",
	prototype: ["shot"],
	zorder: "@include data/zorder.cfg:in_front_of_everything",
	
	on_end_anim: "set(animation, animation)",
	
	animation: {
		id: "normal",
		image: "enemies/kitty-sniper-shot.png",
		x: 0,
		y: 0,
		w: 23,
		h: 23,
		frames: 6,
		pad: 0,
		duration: 2,
		no_remove_alpha_borders: true,
	},
},{
	id: "reticule",
	is_strict: true,
	zorder: "@include data/zorder.cfg:in_front_of_everything",
	
	
	animation: {
		id: "normal",
		image: "enemies/kitty-sniper-reticule.png",
		x: 0,
		y: 0,
		w: 25,
		h: 25,
	},
},{
	id: "target",
	is_strict: true,
	zorder: "@include data/zorder.cfg:in_front_of_everything",
	
	
	animation: {
		id: "normal",
		image: "effects/particles.png",
		x: 23,
		y: 197,
		w: 28,
		h: 28,
	},
}],
	
}