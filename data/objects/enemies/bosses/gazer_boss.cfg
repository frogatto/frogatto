{
id: "gazer_boss",
prototype: ["hittable"],
always_active: true,
editor_info: {
	category: "boss",
},

types: {
	GazerBossBehaviorModeTypes: "enum {
		aggro_mooks,
		charging_laser,
		attack_laser,
		laser_sweep_setup, laser_sweep_attack, //just uses scattershot_return ðŸ˜¬
		spawn_mooks,
		scattershot_charge, scattershot_attack, scattershot_return,
		spiral_attack,
		idle,
	}",
},


preload_objects: ["gazer_small_bare", "coin_silver_kinetic", "bouncing_debris_chunk", "die_cloud_medium", "heart_object"],

properties: {
#-------------------------- hittable overrides --------------------------#
	attack_damage:  "if(true, kill_anything, 0)",
	team:  			"if(true, 'evil', 'evil_harmless')",
	
	title: "~Gazer Boss~",
	description: "~When you stare into The Great Eye, it also stares into you!  And fires death beams at you, because eyes totally do that sometimes.  Honest.~",
	taste: "~AHA!~",

	
	taxonomy: "TaxonomyType :: enum stone",
	custom_damage_table: "{
		enum neutral: 1.0,
		enum fire: 0.0,
		enum energy: 0.0,
		enum arcane: 0.0,
		enum acid: 0.0,
		enum impact: 1.0,
		enum impale: 1.0,
		enum lacerate: 1.0
	}",

#-------------------------- custom death logic --------------------------#
	death_fx_type: "'moth-boss'",
	corpse_object_type: "'${me.type}.corpse'",
	death_fx_ignore_damage_type: "true",

#-------------------------- boss HUD stuff --------------------------#
	is_a_boss: { default: true },


#-------------------------- setup --------------------------#
	setup: "commands ::	[
							set_max_hitpoints({casual: standard_thrown_damage * 20, challenging: standard_thrown_damage * 45}),
							spawn('gazer_boss_bg_effect', {
								use_absolute_screen_coordinates: true,
								width: SCREEN_WIDTH,
								height: SCREEN_HEIGHT,
							})
						]",


#-------------------------- helpers --------------------------#
	angle_to_look_at: "def(PointLike target) -> decimal
		//Rotate the target around me, so that the closest angle is the shortest rotation to look at the actual target. (If we just added 90 degrees, the breakpoint for clockwise/counterclockwise would be rotated as well and we'd wind up taking a longer rotation when we didn't need to.)
		lib.math.closest_angle(me,
			lib.math.rotate(
				lib.standardize.to_point(me), 90,
				lib.standardize.to_point(target) ) )",


#-------------------------- core behavior --------------------------#
	process_behavior: "				[		
										switch(_state,
											enum aggro_mooks,		process_aggro_mooks,
											enum charging_laser,	process_charging_laser,
											enum attack_laser,		process_laser,
											enum laser_sweep_setup, process_laser_sweep_setup,
											enum laser_sweep_attack,process_laser_sweep_attack,
											enum spawn_mooks,		process_spawn_mooks,
											enum scattershot_charge,process_scattershot_charge,
											enum scattershot_attack,process_scattershot_attack,
											enum scattershot_return,process_scattershot_return,
											enum spiral_attack,		process_spiral_attack,
											enum idle,				null
										),
										//debug(cycle - _phase_started_at, ' : ', _current_phase_random_timer)
									]",
													
	pick_random_behavior: "commands :: [
											switch(_behavior_mode_prng.get_next_value,
//												0, ; [debug('begin_charging_laser'), begin_charging_laser],
												0, ; if(should_spawn_mooks, [debug('begin_spawn_mooks'), begin_spawn_mooks], [debug('begin_aggro_mooks'), begin_aggro_mooks]),
												1, ; if(me.hitpoints <= me.max_hitpoints/2, [debug('begin_charging_laser'), begin_charging_laser], [debug('begin_scattershot'), begin_scattershot]),
												2, ; if(should_spawn_mooks, [debug('begin_spawn_mooks'), begin_spawn_mooks], [debug('begin_spiral_attack'), begin_spiral_attack]),
												3, ; [debug('begin_scattershot'), begin_scattershot],
												4, ; [debug('begin_laser_sweep'), begin_laser_sweep],
											),
											_behavior_mode_prng.iterate_random_pool,
											; set(_phase_started_at, cycle)
										]",
										
	pick_specific_behavior: "def( commands new_behavior ) -> commands	[
																			; new_behavior,
																			; set(_phase_started_at, cycle)
																		]",
	
		#------ fire shot ------#
	spawn_scattershot_instance: "commands ::	[
													spawn_scattershot('gazer_boss.scatter_shot', 300),
													sound('wobbly-projectile'+1d3+'.wav'),
												]
													",
	spawn_scattershot: "def(string shot_type, decimal shot_speed) -> commands [
		spawn(shot_type, shot_offset.x, shot_offset.y, {velocity_x: shot_velocity.x, velocity_y: shot_velocity.y}),
		spawn('gazer_boss.scatter_shot_bloom', bloom_offset.x, bloom_offset.y, {rotate: rotate}),
	]
		where shot_velocity = { x: decimal, y: decimal } :: { x: shot_speed * cos(shot_angle), y: shot_speed * sin(shot_angle)}
		where bloom_offset =  { x: decimal, y: decimal } :: { x: mid_x + bloom_dist * cos(shot_angle), y: mid_y + bloom_dist * sin(shot_angle)}
		where shot_offset =  { x: decimal, y: decimal } :: { x: mid_x + shot_dist * cos(shot_angle), y: mid_y + shot_dist * sin(shot_angle)}
		where bloom_dist = 43
		where shot_dist = 49
		where shot_angle = rotate-90
	",
	
	
#-------------------------- aggro-mooks mode --------------------------#
	/*
		In this mode, the various gazerlets will all, sequentially, "catch fire" and start chasing the player - they'll home in on the player until they explode.  This will burn through an entire roster of them, leaving the boss with none.
	*/

	begin_aggro_mooks: "commands ::	[
									set(_state, enum aggro_mooks),
									set(_current_phase_random_timer, 170+1d50)
								]",

	process_aggro_mooks: "		[
									add(rotate, sin(cycle*7) * 0.05 + sin(cycle*3) * 0.15 + sin(cycle*2.5) * 0.25),
									if(mod(cycle - _phase_started_at, 75) = 0, trigger_single_mook_aggro),
									if(cycle - _phase_started_at = _current_phase_random_timer,
										if(size(existing_non_aggroed_mooks) > 0,
											[debug('force begin_aggro_mooks'), pick_specific_behavior(begin_aggro_mooks)],
											pick_random_behavior
										)
									)
								]",

	
	trigger_single_mook_aggro: "if(the_mook != null, 
									[
										if(the_mook is obj gazer_small_bare,
											the_mook.do_aggro_behavior
										),
										if(the_mook is obj gazer_small_bare_harmless,
											the_mook.do_aggro_behavior
										)
									]
								) where the_mook = choose(existing_non_aggroed_mooks)",







#-------------------------- scattershot mode --------------------------#



	/*
		The scattershot attack has three stages.
		
		First, in scattershot_charge, we align ourselves and charge towards the
		player. When we're close enough, we'll move on to the next stage.
		
		While in scattershot_attack, we'll quickly fire off shots which will knock
		us back and off-angle. We'll try to compensate and continue our charge, but
		the knockback will be too much and most of the shots will miss.
		
		The third and final stage, scattershot_return, we will return to the center
		of the stage so the rest of the boss fight will work. We will want to come
		up with something to allow the next attacks to not require this.
	*/
	// TODO DDR 2019-10-05: Move movement logic out of scattershot section, since it's used by the sweep attack as well.
	
		#------ Knobs ------#
	_home_midpoint_xy: "[477, 2109]", #The center of the level, where we start. TODO DDR 2019-10-05: This *really should* be saved at the beginning...
	_scattershot_target_firing_location: "[
		(477 + 2d400 - 400 + level.player.midpoint_x) / 2,
		2109 + 2d100 - 100,
	]",
	
	_linear_acceleration_rate: 0.1, #px/frame
	_linear_break_power: 20, #percentage, 0..99, of how strong our breaks are. We break when we're not looking at our target, ie, we've lost it.
	
	_rotational_damping: 1.06, #Min 1. Higher values result in less overshoot, lower values result in a "springier" rotation.
	_max_rotation_speed: 6, #deg/frame
	_max_rotation_speed_delta: 0.20, #deg/frame
	_rotational_speed_delta_damping: 20, #Divisor for amount of rotation desired. Higher = less hasty rotations with overshoot.
		
	_scattershot_fire_rate: "decimal :: //Number of shots per frame to fire. Maximum 1 for now.
		if(me.hitpoints > me.max_hitpoints/2, 0.30, 
			if(me.hitpoints > me.max_hitpoints/4, 0.55, 0.70 ) )", 
	_scattershots_to_fire: "25+1d20", //Total number of shots for this attack to do.
	_scattershot_velocity: "decimal :: 
		if(me.hitpoints > me.max_hitpoints/2, 500, 
			if(me.hitpoints > me.max_hitpoints/4, 550, 600 ) )",
	
	_scattershot_max_spread: "decimal :: 
		if(me.hitpoints > me.max_hitpoints/2, 70, 
			if(me.hitpoints > me.max_hitpoints/4, 90, 110 ) )",
	_scattershot_linear_kick: "1200", #Higher number = less kick.
	_scattershot_rotational_kick: "40", #Higher number = less kick.
		
		
		#------ internal-use variables ------#
	_linear_velocity: { type: "Vector", init: "[0,0]" },
	_rotational_velocity: { type: "decimal", init: "0" },
	_scattershots_ready_to_fire: { type: "decimal", init: "0" }, #Incremented with _scattershot_charge_speed. Fractional shots count towards the next full shot.
	_scattershots_fired: { type: "int", init: "0" },
	_scattershots_to_fire_this_time: { type: "int", init: "0" },
	_reached_home_target: { type: "bool", init: "false" },
	_knows_where_going: { type: "bool", init: "false" }, #Don't break if we know where we're going, for example, to the center of the screen.
	_current_scattershot_target_firing_location: { type: "Point", init: "[0,0]" },
	
	
		#------ scattershot logic ------#
	process_gazer_movement: "def(PointLike target, decimal|null angle=null) -> commands	[
		//Allow linear velocity to change.
		set(_linear_velocity, zip(_linear_velocity, [
			raw_accel[0] - _linear_velocity[0]/(40.0 - (1-facing_right_way)*_linear_break_power),
			raw_accel[1] - _linear_velocity[1]/(40.0 - (1-facing_right_way)*_linear_break_power),
		] where raw_accel = map(
			lib.math.rotate(
				angle_to_target+225,
				map([_linear_acceleration_rate, _linear_acceleration_rate], value*1000.0*facing_right_way)
			), value / 1000.0)
		)) where facing_right_way = if(_knows_where_going, 1, 
			1 - (lib.math.constrain(45, abs(rotate - angle_to_target), 90) - 45) / 45 );
		
		//Allow position to change.
		set(xy, map(zip(xy, _linear_velocity), int(value))),
		
		//Allow rotational velocity to change.
		set(_rotational_velocity, 
			lib.math.constrain(
				-_max_rotation_speed, 
				_rotational_velocity/_rotational_damping + lib.math.constrain(
					-_max_rotation_speed_delta, 
					(if(angle != null, angle, angle_to_target) - me.rotate) / _rotational_speed_delta_damping,
					_max_rotation_speed_delta ), 
				_max_rotation_speed ) );
		
		//Allow rotation to change.
		add(rotate, _rotational_velocity),
	] where angle_to_target = angle_to_look_at(target)",
	
	begin_scattershot: "commands ::	[
										set(_state, enum scattershot_charge),
										set(_linear_velocity, [0,0]),
										set(_rotational_velocity, 0),
										set(_scattershots_ready_to_fire, 0),
										set(_scattershots_fired, 0),
										set(_scattershots_to_fire_this_time, _scattershots_to_fire), //Sample once, otherwise we'd roll the dice each time.
										set(_reached_home_target, false),
										set(_knows_where_going, false),
										set(_current_scattershot_target_firing_location, _scattershot_target_firing_location),
									]",
	
	fire_scattershot_shot: "commands ::	[
											//Spawn the shot and effect.
											sound('wobbly-projectile'+1d3+'.wav'),
											spawn('gazer_boss.scatter_shot', shot_offset.x, shot_offset.y, {velocity_x: shot_velocity.x, velocity_y: shot_velocity.y}),
											spawn('gazer_boss.scatter_shot_bloom', bloom_offset.x, bloom_offset.y, {rotate: rotate}),
											
											//Calculate and apply kickback.
											set(_linear_velocity, [
												_linear_velocity[0] - shot_velocity.x/_scattershot_linear_kick,
												_linear_velocity[1] - shot_velocity.y/_scattershot_linear_kick,
											]),
											set(_rotational_velocity,
												_rotational_velocity - (rotate - angle_to_look_at(shot_offset)) / _scattershot_rotational_kick )
										]
											where shot_velocity = { x: decimal, y: decimal } :: { x: _scattershot_velocity * cos(shot_angle), y: _scattershot_velocity * sin(shot_angle)},
											      bloom_offset =  { x: decimal, y: decimal } :: { x: mid_x + bloom_dist * cos(shot_angle), y: mid_y + bloom_dist * sin(shot_angle)},
											      shot_offset =  { x: decimal, y: decimal } :: { x: mid_x + shot_dist * cos(shot_angle), y: mid_y + shot_dist * sin(shot_angle)}
											where bloom_dist = 43,
											      shot_dist = 49,
											      shot_angle = rotate-90 + 1d(spread)-spread/2
											where spread = _scattershot_max_spread",
	
	
		#------ Stage 1: scattershot_charge ------#
	process_scattershot_charge: "commands ::	[
													process_gazer_movement(_current_scattershot_target_firing_location),
													
													if(lib.math.length(me, _current_scattershot_target_firing_location) < 20, [
														set(_state, enum scattershot_attack),
													]),
												]",
	
	
		#------ Stage 2: scattershot_attack ------#
	process_scattershot_attack: "commands ::	[
													process_gazer_movement(level.player);
													
													add(_scattershots_ready_to_fire, _scattershot_fire_rate),
													if(_scattershots_ready_to_fire >= 1, [
														add(_scattershots_ready_to_fire, -1),
														add(_scattershots_fired, 1),
														fire_scattershot_shot,
													]),
													if(_scattershots_fired >= _scattershots_to_fire_this_time, [
														set(_state, enum scattershot_return),
														set(_knows_where_going, true), //We live here, we know where we're going now. Unlike tracking that stupid frog...
													])
												]",


		#------ Stage 3: scattershot_return ------#
	process_scattershot_return: "commands ::	[
													process_gazer_movement(_home_midpoint_xy);
													
													//Lock position if we're close to the home target, so we don't spin around while near because I haven't put in anticipatory breaking.
													if(lib.math.length(me, _home_midpoint_xy) < 50, [
														set(_rotational_velocity, _rotational_velocity/2),
													]);
													
													if(lib.math.length(me, _home_midpoint_xy) < 10, [
														set(_linear_velocity, map(_linear_velocity, value/1.1)), //Hack, just dump momentum when close.
														set(me.rotate, orginial_rotate), //Don't spin around near home.
														if(not _reached_home_target, [
															set(_reached_home_target, true),
															schedule(60, pick_random_behavior), //Give some time to apply the breaks.
														]),
													]),
													
												] where orginial_rotate = me.rotate",


#-------------------------- ground-hugging shockwave attack mode --------------------------#
	//i.e. the shots the boss fires during the spiral attack

	prepare_aimed_shockwave_shot:  "commands :: 	[
									animate(me, {
											rotate: angle_to_player + 90,
										},{
											duration: arc_duration,
											on_complete: fire_aimed_shockwave_shot
									}),
								]
									where arc_duration = 30
									where angle_to_player = angle_to_look_at(level.player)",

	fire_aimed_shockwave_shot: "commands ::	[ 
									; spawn_large_shot('gazer_boss.shockwave_shot', 700, true),
									sound('wobbly-projectile'+1d3+'.wav')
								]",

	spawn_large_shot: "def(string shot_type, decimal shot_speed, bool use_aimed_rotation) -> commands [
													spawn(shot_type, shot_offset.x, shot_offset.y, {
														velocity_x: shot_velocity.x,
														velocity_y: shot_velocity.y,
														rotate: if(use_aimed_rotation, rotate - 180, 0)
													}),
													spawn('gazer_boss.scatter_shot_bloom', bloom_offset.x, bloom_offset.y, {rotate: rotate}),
												]
													where shot_velocity = { x: decimal, y: decimal } :: { x: shot_speed * cos(shot_angle), y: shot_speed * sin(shot_angle)}
													where bloom_offset =  { x: decimal, y: decimal } :: { x: mid_x + bloom_dist * cos(shot_angle), y: mid_y + bloom_dist * sin(shot_angle)}
													where shot_offset =  { x: decimal, y: decimal } :: { x: mid_x + shot_dist * cos(shot_angle), y: mid_y + shot_dist * sin(shot_angle)}
													where bloom_dist = 43
													where shot_dist = 49
													where shot_angle = rotate-90
												",
			



#-------------------------- laser mode #1: Rotate --------------------------#



		#------ charging laser ------#
	_laser_chargeup_duration: { type: "int", init: "0" },
	_time_started_laser_chargeup: { type: "int", init: "0", persistent: false },
		
	begin_charging_laser: "commands :: [
									set(_laser_chargeup_duration, 100),
									set(_state, enum charging_laser),
									set(_time_started_laser_chargeup,cycle),
									add_charging_laser_effect,
								]",
									

	add_charging_laser_effect: "commands ::	[
												add_object(_laser_charge_bloom),
												fire_event(_laser_charge_bloom,'create'),
												set(_laser_charge_bloom.mid_x, mid_x + bloom_offset.x),
												set(_laser_charge_bloom.mid_y, mid_y + bloom_offset.y),
												set(_laser_charge_bloom.rotate, rotate),
												spawn('effects_attache_glow_source', mid_x, mid_y, {
													time_to_die: 0,
													parent: me,
													flicker_type: enum window_light,
													graphics: enum gazer_flare,
													scale_factor: 0.1,
													base_alpha: 20,
													custom_relative_pos_default: {mid_x: bloom_offset.x, mid_y: bloom_offset.y},
													zorder: 50,
												},[
													animate(child, {base_alpha: 180}, {duration: 40, easing: lib.math.ease_in_quint}),
													animate(child, {scale: 0.3}, {duration: 100, easing: lib.math.ease_in_quint}),
													schedule(100, remove_object(child)),
												])
											]",
								

	process_charging_laser: "commands ::	[
												if(cycle - _time_started_laser_chargeup > _laser_chargeup_duration, begin_laser),
												process_charging_laser_particles
											]",
	
	process_charging_laser_particles: "commands :: 	[
														if(cycle % 10 = 0 and (cycle - _time_started_laser_chargeup < _laser_chargeup_duration * 3/5.0),
															map(chargeup_particle_positions, spawn('gazer_boss.laser_chargeup_particle', value.x, value.y, {_target_obj: _laser_charge_bloom}))
														)
													]",

	chargeup_particle_positions: "lib.math.randomized_even_spread_radial_distribution({count: 4, min_angle: 0, max_angle: 359, angle_delta_scale: 1.0, origin: {x: me.mid_x, y: me.mid_y}, min_length: 200, max_length: 300})",

	bloom_offset: "{ x: decimal, y: decimal } :: { x: beam_dist * cos(beam_angle), y: beam_dist * sin(beam_angle)}
								where beam_dist = 38
								where beam_angle = me.rotate - 90",



		#------ firing mah lazor ------#
	_current_laser_duration: { type: "int", init: "0" },
	_time_started_laser: { type: "int", init: "0", persistent: false },

	begin_laser: "commands :: [
									set(_current_laser_duration, lib.math.round( base_laser_duration - (laser_duration_variance/2.0) + 1d(laser_duration_variance) )),
									set(_rotation_direction, if(1d2=2, -1, 1)),
									set(_state, enum attack_laser),
									set(_time_started_laser,cycle), 
									add_object(_laser_beam),
									_laser_beam.do_setup,
								]",
	stop_laser: "[
					remove_object(_laser_beam),
					[debug('force begin_aggro_mooks'), pick_specific_behavior(begin_aggro_mooks)]
				]",
	
	process_laser: "[
						add(rotate, laser_rotation_speed),
						if(cycle - _time_started_laser > _current_laser_duration, stop_laser),
					]",

	laser_rotation_speed_max: "decimal :: 1.1",
	laser_rotation_speed: "if(cycle - _time_started_laser < laser_deceleration_timeslice, 
						lib.math.constrain(0, laser_rotation_speed_max*((cycle - _time_started_laser)/laser_deceleration_timeslice), laser_rotation_speed_max),
						if(_time_started_laser + _current_laser_duration - cycle < laser_deceleration_timeslice,
							lib.math.constrain(0, laser_rotation_speed_max*((_time_started_laser + _current_laser_duration - cycle)/ laser_deceleration_timeslice), laser_rotation_speed_max),
							laser_rotation_speed_max
						)
					) * _rotation_direction",


	approximate_laser_arc_length: "360.0",
	base_laser_duration: "decimal :: (approximate_laser_arc_length / laser_rotation_speed_max) * (1 + (2.0 * laser_deceleration_timeslice_ratio))",
	laser_deceleration_timeslice: "decimal :: base_laser_duration * laser_deceleration_timeslice_ratio",
	laser_deceleration_timeslice_ratio: "decimal :: 1/6.0",
	laser_duration_variance: "decimal :: base_laser_duration * 1.0/5.0",






#-------------------------- laser mode #2: Sweep --------------------------#



	/*
		The scattershot attack has three stages.
		
		First, in scattershot_charge, we align ourselves and charge towards the
		player. When we're close enough, we'll move on to the next stage.
		
		While in scattershot_attack, we'll quickly fire off shots which will knock
		us back and off-angle. We'll try to compensate and continue our charge, but
		the knockback will be too much and most of the shots will miss.
		
		The third and final stage, scattershot_return, we will return to the center
		of the stage so the rest of the boss fight will work. We will want to come
		up with something to allow the next attacks to not require this.
	*/
	
		#------ Knobs ------#
	_laser_sweep_firing_location_left_bottom: "[-35, 2508]",
	_laser_sweep_firing_location_left_top: "[-95, 2046]",
	
	
		#------ internal-use variables ------#
	_reached_laser_sweep_start_target: { type: "bool", init: "false" },
	_reached_laser_sweep_end_target: { type: "bool", init: "false" },
	
	
	begin_laser_sweep: "commands ::	[
										set(_state, enum laser_sweep_setup),
										set(_linear_velocity, [0,0]),
										set(_rotational_velocity, 0),
										set(_knows_where_going, true),
										set(_reached_home_target, false),
										set(_reached_laser_sweep_start_target, false),
										set(_reached_laser_sweep_end_target, false),
										set(_laser_chargeup_duration, 100),
										set(_time_started_laser_chargeup, cycle),
									]",
	
	
	process_laser_sweep_setup: "commands ::	[
												process_gazer_movement(_laser_sweep_firing_location_left_bottom, target_angle);
												
												if(
													not _reached_laser_sweep_start_target
													and lib.math.length(me, _laser_sweep_firing_location_left_bottom) < 20
													and abs(me.rotate - target_angle) < 5,
												[
													set(_reached_laser_sweep_start_target, true),
													add_charging_laser_effect,
													schedule(_laser_chargeup_duration, [
														set(_state, enum laser_sweep_attack),
														add_object(_laser_beam),
														_laser_beam.do_setup,
													]),
												]),
												
												if(_reached_laser_sweep_start_target, process_charging_laser_particles)
												
											] where target_angle = if(lib.math.length(me, _laser_sweep_firing_location_left_bottom) > 300,
												angle_to_look_at(level.player), //Look at the player for the first little bit,
												angle_to_look_at([me.midpoint_x + 100, me.midpoint_y]) //then get into position.
											)",
												
											
	process_laser_sweep_attack: "commands ::	[
													process_gazer_movement(_laser_sweep_firing_location_left_top, target_angle);
														
													if(
														not _reached_laser_sweep_end_target
														and lib.math.length(me, _laser_sweep_firing_location_left_top) < 20
														and abs(me.rotate - target_angle) < 5,
													[
														set(_reached_laser_sweep_end_target, true),
														schedule(60, [
															set(_state, enum scattershot_return),
															remove_object(_laser_beam),
														]),
													]),
												] where target_angle = angle_to_look_at([me.midpoint_x + 100, me.midpoint_y])",






#-------------------------- spawn mooks mode --------------------------#



	begin_spawn_mooks: "commands :: [
									set(_state, enum spawn_mooks),
									set(_current_phase_random_timer, 100+1d50)
							]",

	process_spawn_mooks: "commands :: 	[
									add(rotate, sin(cycle*7) * 0.05 + sin(cycle*3) * 0.15 + sin(cycle*2.5) * 0.25),
									if(cycle - _phase_started_at = 50, spawn_mooks),
									if(cycle - _phase_started_at = _current_phase_random_timer, pick_random_behavior)
								]",

								
	/* unused */ single_mook_position: "lib.math.random_radial_pos({min_angle: 0, max_angle: 359, angle_delta_scale: 1.0, origin: {x: me.mid_x, y: me.mid_y}, min_length: 250, max_length: 350})",

	mook_positions: "def(int mook_count) -> [{x:decimal, y:decimal}]
			lib.math.randomized_even_spread_radial_distribution({count: mook_count, min_angle: -120 - 23 , max_angle: 120 - 23, angle_delta_scale: 0.10, origin: {x: me.mid_x, y: me.mid_y}, min_length: 350, max_length: 375})",

	existing_mooks: "[obj gazer_small_bare|obj gazer_small_bare_harmless] :: ([obj gazer_small_bare|obj gazer_small_bare_harmless] <- filter(level.chars, value is obj gazer_small_bare or value is obj gazer_small_bare_harmless))",
	existing_non_aggroed_mooks: "filter(existing_mooks, value._target_obj != level.player)",
	max_mook_count: "5",
	should_spawn_mooks: "size(existing_non_aggroed_mooks) <= max_mook_count / 2",

	spawn_mooks:	"[
						map(mook_positions(max_mook_count),
							if(index = 1,
								spawn('gazer_small_bare_harmless', mid_x, mid_y, {facing: if(1d2=2,1,-1)}, [child.fly_to([{x: lib.math.round(value.x), y: lib.math.round(value.y)}])]),
								spawn('gazer_small_bare', mid_x, mid_y, {facing: if(1d2=2,1,-1)}, [child.fly_to([{x: lib.math.round(value.x), y: lib.math.round(value.y)}])]),
							)
						),
						sound('gazer-boss-spawn-gazerlet'+1d4+'.wav'),
					]",


#-------------------------- mook spiral attack --------------------------#
	begin_spiral_attack: "commands :: [
									set(_state, enum spiral_attack),
									set(_current_phase_random_timer, 50 + (100 + 640) + (50 + 1d75) )
							]",

	process_spiral_attack:  "commands :: 	[
									if(cycle - _phase_started_at = 50, start_mook_spiral_animation),
									if((cycle - _phase_started_at) % 200 = 0, prepare_aimed_shockwave_shot),
									if(cycle - _phase_started_at = _current_phase_random_timer, pick_random_behavior)
								]",
								

		#-------------------------- stuff for the actual spiral attack --------------------------#
		
	start_mook_spiral_animation: "commands :: [
								schedule(10, _spiral_attack_sound_loop.turn_on),
								schedule(100, sound_falloff('gazer-spin-windup.wav')),

								map(existing_non_aggroed_mooks, [
									set(value.animation, 'burning'),
									(commands <- value.flame_on),
									animate(value, {
											mid_x: location.x,
											mid_y: location.y
										},{
											duration: 100,
											name: 'pull_inwards',
											replace_existing: false,
											sleep: true,
											//on_complete: do_mook_spiral_animation  //<-- scrap this; it's giving us 8 copies
									})
										where location = _to_point([decimal, decimal] <- orbit(mid_x, mid_y, angle, dist))
										where _to_point = def([decimal, decimal] pt) -> {x: int, y: int} {x: lib.math.round(pt[0]), y: lib.math.round(pt[1])}
										where angle = (index * (360/size(existing_non_aggroed_mooks))) 
										where dist =  125 + 175 * 0
									]);
									do_mook_spiral_animation
								]",

	do_mook_spiral_animation: "commands :: [map(existing_non_aggroed_mooks,
										[
											internal_mook_spiral(value, index),
											schedule(640, [set(value.animation,'fly'), (commands <- value.flame_off)])
										]
									),
									schedule(640, do_mook_spiral_animation_recovery),
									schedule(600, sound_falloff('gazer-spin-end.wav'))
								]
	
					where internal_mook_spiral = def(obj gazer_small_bare|obj gazer_small_bare_harmless the_mook, int __index) -> commands
					
					[
						set(the_mook.spiral_info, {
							mid_x: me.mid_x,
							mid_y: me.mid_y,
							__index: __index,
							num_mooks: size(existing_non_aggroed_mooks),
						}),
						set(the_mook.spiral_anim, 0),
						animate(the_mook, {
							spiral_anim: 640,
						}, {
							duration: 640,
						})
					]
					",

	do_mook_spiral_animation_recovery: "commands :: [map(existing_non_aggroed_mooks,
											animate(value, {
													mid_x: positions[index].x,
													mid_y: positions[index].y
												},{
													duration: 100,
													name: 'restore',
													replace_existing: false,
											})
										) where positions = mook_positions(size(existing_non_aggroed_mooks)),
										_spiral_attack_sound_loop.turn_off,
									]", 

	

	


#-------------------------- vars --------------------------#
	_behavior_mode_prng:	{ type: "class pseudo_random_numbers", init: "construct('pseudo_random_numbers',{_size_of_pool:5, _pool_size_multiplier: 1})", persistent: false },

	_spiral_attack_sound_loop: { type: "obj sound_source_individual_attache", init: "object('sound_source_individual_attache', mid_x, mid_y, {parent: me, sound_file:'gazer-spin-loop.wav', starts_with_sound_on: false})" },

	_phase_started_at: { type: "int", init: "0", persistent: false },
	_current_phase_random_timer: { type: "int", init: "0", persistent: false },
	_rotation_direction:  { type: "int", init: "1" },
	_laser_charge_bloom: { type: "obj gazer_boss.laser_chargeup_bloom", init: "object('gazer_boss.laser_chargeup_bloom', mid_x, mid_y, facing)" },
	_laser_beam: { type: "obj gazer_boss.beam", init: "object('gazer_boss.beam', mid_x, mid_y, {parent: me, time_to_die: 1})" },
	_state: { type: "GazerBossBehaviorModeTypes", init: "enum idle", persistent: false },
},
		
on_create:  "[setup, begin_spawn_mooks, add_object(_spiral_attack_sound_loop)]",

on_process: "process_behavior",

on_end_anim: "animation('normal')",

animation: [
{
	"@base": true,
	image: "enemies/gazer-boss1.png",
	attack_area: "all",
	body_area: "all",
	no_remove_alpha_borders: true,
	pad: 2,
},
{
	id: "normal",
	rect: [1,1,125,125],
	frames:5,
	duration: 5,
	reverse: true,
},
],

object_type: [
	{
		id: "beam",
		prototype: ["effects_attache"],
		always_active: true,
		serializable: false,
		zorder: 20,
		
		properties: {
			texture_offset: "0",
			beam_length: "800",
			
			draw_w: "img_w/2",
			pupil_offset: "74.0",
			width_coefficient: "img_w/pupil_offset * (decimal(0.5*img_h)/img_w)", //<- this is some black magic, here.   
			
			beam_angle: "parent.rotate - (90 - parent.laser_rotation_speed) asserting parent is obj gazer_boss", //single frame of delay

			offset: "{ x: decimal, y: decimal } :: { x: length * cos(beam_angle),
													 y: length * sin(beam_angle) - (beam_length - (width_coefficient) * pupil_offset)} where length = (pupil_offset + beam_length)", 

			glow_offset: "{ x: decimal, y: decimal } :: {
														x: pupil_offset * 0.6 * cos(beam_angle),
													 	y: pupil_offset * 0.6 * sin(beam_angle)
													 }", 


			update_attache: "[
								set(_beam_damage_provider.beam_angle, beam_angle),
								set(_beam_damage_provider.beam_distance, beam_length + pupil_offset)
							]",

			update_draw_positions: "[
									update_attache,
									//debug(decimal(0.5*img_h)/img_w),
									//debug(draw_w/decimal(img_h)),
									_beam_root.update_draw_positions,
									set(relative_x, offset.x),
									set(relative_y, offset.y),
									set(_glow.relative_x, glow_offset.x),
									set(_glow.relative_y, glow_offset.y),
									set(rotate, parent.rotate),
									set(draw_area, [0, texture_offset, draw_w, beam_length])
								] asserting parent != null",
			
								


			_beam_damage_provider: { type: "obj damage_beam_attache", init: "object('damage_beam_attache', mid_x, mid_y, {parent: me.parent, relative_x: 0, relative_y: 0})" },
			_beam_root: { type: "obj gazer_boss.beam_root", init: "object('gazer_boss.beam_root', mid_x, mid_y, {parent: me.parent, relative_x: 0, relative_y: 0})" },
			_glow: {
				type: "obj effects_attache_glow_source",
				init: "object('effects_attache_glow_source', mid_x, mid_y, {
								time_to_die: 0,
								parent: me.parent,
								flicker_type: enum window_light,
								graphics: enum gazer_flare,
								scale_factor: 0.60,
								base_alpha: 180,
								zorder: 50,
							})",
			},

			#-------------------------- effects_attache overrides --------------------------#
			additional_death_cleanup: "commands :: [remove_object(_beam_damage_provider),remove_object(_beam_root),remove_object(_glow)]",
			do_setup: "commands :: [
							initialize_position,
							add_object(_glow),
							add_object(_beam_damage_provider),
							add_object(_beam_root),
							set(_beam_root.mid_x, _parent_obj.mid_x),
							set(_beam_root.mid_y, _parent_obj.mid_y),
							set(_beam_damage_provider.mid_x, _parent_obj.mid_x),
							set(_beam_damage_provider.mid_y, _parent_obj.mid_y),
							spawn('sound_source_individual_attache',mid_x,mid_y,{parent:_beam_damage_provider, sound_file:'extended-laser.wav'}),
						
							; update_draw_positions
						]",
		},

		
		on_process: "update_draw_positions",
		
		on_end_anim: "animation('normal')",
		
		animation: [{
			id: "normal",
			image: "enemies/gazer-boss-beam1.png",
			rect: [0,0,72,31],
			frames: 6,
			reverse: true,
			pad: 0,
			duration: 2,
			no_remove_alpha_borders: true,
		}],

	},
	{
		id: "beam_root",
		always_active: true,
		serializable: false,
		zorder: 20,
		properties: {
			offset: "{ x: decimal, y: decimal } :: { x: beam_dist * cos(beam_angle), y: beam_dist * sin(beam_angle)}
								where beam_dist = 38",
			beam_angle: "parent.rotate - (90 - parent.laser_rotation_speed) asserting parent is obj gazer_boss", //single frame of delay

			update_draw_positions: "commands :: [
										set(relative_x, me.offset.x),
										set(relative_y, me.offset.y),
										set(rotate, me.parent.rotate),
									]  asserting me.parent != null",
		},

		on_end_anim: "animation('normal')",

		animation: [{
			id: "normal",
			image: "enemies/gazer-boss-beam-root1.png",
			rect: [0,0,72,39],
			frames: 6,
			reverse: true,
			pad: 0,
			duration: 2,
			no_remove_alpha_borders: true,
		}],

	},
	{
		id: "shockwave_shot",
		prototype: ["shot"],
		always_active: true,
		serializable: false,
		zorder: 20,

		solid_area: [05,15,17,27],

		properties: {
			death_effects: "def(string type) -> commands [
				spawn('gazer_boss.shockwave_zoomer', mid_x, mid_y, 1),
				spawn('gazer_boss.shockwave_zoomer', mid_x, mid_y, {_moving_clockwise: false})
			]",
		},
		
		on_end_anim: "animation('normal')",

# 		on_create: "spawn('effects_attache_glow_source', mid_x, mid_y, {
# 								time_to_die: 0,
# 								parent: me,
# 								flicker_type: enum window_light,
# 								graphics: enum gazer_flare,
# 								scale_factor: 0.17,
# 								base_alpha: 160
# 							})",

		
		animation: [{
			id: "normal",
			image: "enemies/gazer-boss-shot.png",
			rect: [255,0,273,43],
			frames: 6,
			pad: 1,
			duration: 5,
			no_remove_alpha_borders: true,
		}],

	},
	
	{
		id: "scatter_shot",
		prototype: ["shot"],
		always_active: true,
		serializable: false,
		zorder: 20,

		
		on_process: "add(rotate, 3d2)",
		on_end_anim: "animation('normal')",

		on_create: "spawn('effects_attache_glow_source', mid_x, mid_y, {
								time_to_die: 0,
								parent: me,
								flicker_type: enum window_light,
								graphics: enum gazer_flare,
								scale_factor: 0.17,
								base_alpha: 160
							})",
		
		animation: [{
			id: "normal",
			image: "enemies/gazer-boss-shot.png",
			rect: [0,0,31,31],
			frames: 8,
			frames_per_row: 4,
			reverse: true,
			pad: 0,
			duration: 2,
			no_remove_alpha_borders: true,
		}],

	},
	{
		id: "scatter_shot_bloom",
		always_active: true,
		serializable: false,
		zorder: 21,

		
		on_end_anim: "die()",
		
		animation: [{
			id: "normal",
			image: "enemies/gazer-boss-shot.png",
			rect: [0,64,47,95],
			frames: 8,
			frames_per_row: 4,
			pad: 0,
			duration: 3,
			no_remove_alpha_borders: true,
		}],

	},
	{
		id: "laser_chargeup_bloom",
		always_active: true,
		serializable: false,
		zorder: 22,
		prototype: ["standard_values"],
		properties: {
			_anim_counter: { type: "decimal", init: "0" },
			
		},

		on_create: "[animation('normal'), sound_falloff('laser-charge.wav')]",
		on_end_normal_anim:	"if(_anim_counter < 5,
								[animation('normal'), add(_anim_counter, 1)],
								[set(_anim_counter,	0), animation('outro')]
							)",
		on_end_outro_anim: "remove_object(me)",
		
		animation: [{
			id: "normal",
			image: "enemies/gazer-boss-shot.png",
			rect: [144,128,191,175],
			frames: 4,
			frames_per_row: 2,
			pad: 0,
			duration: 2,
			reverse: true,
			no_remove_alpha_borders: true,
		},{
			id: "outro",
			image: "enemies/gazer-boss-shot.png",
			rect: [0,128,47,255],
			frames: 3,
			pad: 0,
			duration: 2,
			no_remove_alpha_borders: true,
		}],

	},
	{
		id: "laser_chargeup_particle",
		always_active: true,
		serializable: false,
		zorder: 20,

		properties: {
			_angle_to_target: "decimal :: lib.math.closest_angle(me, _target_obj)",
			attract_duration: "decimal :: 72.0",
			attraction_elapsed: "int :: (level.cycle - _started_attracting_at_cycle) asserting _started_attracting_at_cycle is int",
			fraction_into_attraction: "decimal :: attraction_elapsed/attract_duration",
			ang_offset: "attraction_elapsed * 0.05",
			_started_attracting_at_cycle: { type: "int|null", init: "level.cycle" },
			_original_length: { type: "decimal", init: "0" },

			_target_obj: { type: "custom_obj", dynamic_initialization: true },

			process_attract: "commands ::
					[
						set(mid_x, _target_obj.mid_x - x_diff) where x_diff = ((1.0 - fraction_into_attraction) * cos(_angle_to_target + ang_offset) * _original_length),
						set(mid_y, _target_obj.mid_y - y_diff) where y_diff = ((1.0 - fraction_into_attraction) * sin(_angle_to_target + ang_offset) * _original_length),
				
						if(level.cycle - _started_attracting_at_cycle > attract_duration, remove_object(me)),
					] asserting _started_attracting_at_cycle is int",
		
		},
		
		on_create: "set(_original_length, lib.math.length(me,_target_obj))", 

		on_process:  "process_attract",
		
		on_end_anim: "[animation('normal'),/*debug(cycle)*/]",

		
		animation: [{
			id: "normal",
			image: "enemies/gazer-boss-shot.png",
			rect: [128,0,142,14],
			frames: 6,
			frames_per_row: 3,
			reverse: true,
			pad: 0,
			duration: 6,
			no_remove_alpha_borders: true,
		}],

	},
	{
		id: "shockwave_zoomer",
		always_active: true,
		serializable: false,
		zorder: 20,
		prototype: ["ground_hugger"],

		properties: {
			taxonomy: "TaxonomyType :: enum neutral",
			attack_damage: "1",
		
			speed: "10.0",
			set_initial_position: "execute(me, if(new_pos = null,
										debug('could not find ground to attach the zoomer to'),
										[set(mid_x, new_pos.x),set(mid_y, new_pos.y-1)]
									)
			
				where new_pos = if(wall_pos_left != null,
									wall_pos_left,
									if(floor_pos != null,
										floor_pos,
										if(wall_pos_right != null,
											wall_pos_right,
											if(ceil_pos != null,
												ceil_pos,
												null
											)
										)
									)
								)
			
				where ceil_pos = find_ceiling(mid_x,mid_y,search_depth)
				where wall_pos_left = find_wall(mid_x,mid_y,search_depth, -1)
				where wall_pos_right = find_wall(mid_x,mid_y,search_depth, 1)
				where floor_pos = find_floor(mid_x,mid_y,search_depth)
				where search_depth = 150
				
				)", 

			my_particles: { type: "obj legacy_particle_attache", init: "object('legacy_particle_attache', mid_x, mid_y, {_particle_type: 'gazer_boss_zoomer_trail', parent: me, time_to_die: 20, zorder: me.zorder - 1})", },

		},
		on_create: "[
						spawn('effects_attache_glow_source', mid_x, mid_y, {
								time_to_die: 0,
								parent: me,
								flicker_type: enum window_light,
								graphics: enum gazer_flare,
								scale_factor: 0.15,
								base_alpha: 160,
								zorder: 50,
							}),
						set_initial_position,
						schedule(100, force_death()),
						add_object(my_particles),
					]",
		on_process: "[move_forward]",
		on_end_anim: "[animation('normal'),set(rotate, 1d360)]",



		animation: [{
			"@base": true,
			id: "normal",
			image: "enemies/gazer-boss-shot.png",
			frames: 1,
			pad: 0,
			duration: 1,
			no_remove_alpha_borders: true,
			attack_area: "all",
		},{
			rect: [192,64,211,83],
			frames: 4,
			frames_per_row: 2,
		},{
			rect: [234,64,253,83],
		},{
			rect: [234,85,253,104],
		},{
			rect: [234,106,253,125],
		}],
	},
	
	{
		id: "corpse",
		always_active: true,
		prototype: ["standard_values"],

		on_create: "[set(level.focus, [me]),sinusoidal_transition({period: 200, _init_theta:1.0, _length_theta:-1.0, addend:0, coefficient:255, obj:me, aspect:'alpha'})]",
		
		on_end_anim: "[set(level.focus, []), if(controller, fire_event(controller, 'postfight_outro')) where controller = get_object(level,'postfight_controller'), die()]",
		animation: [
		{
			"@base": true,
			image: "enemies/gazer-boss1.png",
			body_area: "all",
			no_remove_alpha_borders: true,
			pad: 2,
		},
		{
			id: "normal",
			rect: [1,1,125,125],
			frames:1,
			duration: 200,
			reverse: true,
		},
		],
	},		
	{
		id: "body_spawn_animation",
		prototype: ["transient_object"],

		properties: {
			process_spawning_particles: "commands ::	[
												if(cycle % 10 = 0,
													map(chargeup_particle_positions, spawn('gazer_boss.laser_chargeup_particle', value.x, value.y, {_target_obj: me}))
												)
											]",

			chargeup_particle_positions: "lib.math.randomized_even_spread_radial_distribution({count: 4, min_angle: 0, max_angle: 359, angle_delta_scale: 1.0, origin: {x: me.mid_x, y: me.mid_y}, min_length: 200, max_length: 300})",

		
		},


		on_create: "[
						set(alpha,0),
						map(range(duration), schedule(value, ; process_spawning_particles)),
						map(range(duration),
							schedule(value, [
								set(brightness, lib.math.round(255 * 9 * value/decimal(duration))),
								set(alpha, lib.math.round(255 * value/decimal(duration)))
							])
						),
						schedule(260,
							spawn('effects_attache_glow_source', mid_x, mid_y, {
								time_to_die: 0,
								parent: me,
								flicker_type: enum window_light,
								graphics: enum gazer_flare,
								scale_factor: 0.65,
								base_alpha: 20
							},[
								animate(child, {base_alpha: 250}, {duration: 40, easing: lib.math.ease_in_quint}),
								schedule(40,
									animate(child, {scale: 7.0}, {duration: 100, easing: lib.math.ease_in_quint})
								),
								schedule(191, die())
							])
						),
						schedule(duration, spawn('gazer_boss', mid_x, mid_y, facing)),
						schedule(duration, remove_object(me))

					] where duration = 450",

		animation: [
		{
			"@base": true,
			image: "enemies/gazer-boss1.png",
			attack_area: "all",
			body_area: "all",
			no_remove_alpha_borders: true,
			pad: 2,
		},
		{
			id: "normal",
			rect: [1,1,125,125],
			frames:1,
			duration: 5,
			reverse: true,
		},
		],
	}
	
],

}
