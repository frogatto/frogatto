{
	id: "damage_beam_attache",
	is_strict: true,
	hidden_in_game: true,
	prototype: ["hittable_attache"],

	editor_info: {
		category: "   test",
	},

	properties: {

	
		beam_angle: { type: "decimal", init: "60.0" },
		beam_distance: { type: "decimal", init: "180.0" },
		attack_diameter: { type: "decimal", init: "40.0" },
		attack_radius: "decimal :: lib.math.round( attack_diameter / 2.0 )",
		hitbox_count: "decimal :: lib.math.ceil(beam_distance / (attack_diameter / 1.0))",



		offset: "{ x: decimal, y: decimal } :: { x: length * cos(beam_angle), y: length * sin(beam_angle) } where length = (beam_distance / hitbox_count)", 

		hitbox_animation: "map :: {
								id: 'image',
								image: 'effects/particles.png',
								x: 0,
								y: 0,
								w: 1,
								h: 1,
								//attack_area: 'all',
								//body_area: 'all',  //<- we haven't coded any other active protection against this, itself, taking damage, other than nulling this out;  we almost never would want laser beams to actually get hurt.
								attack_area: [-attack_radius, -attack_radius, attack_radius, attack_radius, 'solid'],
							}",
		
		cached_hitbox_objs: { type: "[obj damage_beam_attache.hitbox_object]", init: "[]" },							
							
		process_hitboxes: "commands ::	[
											populate_hitboxes ;
											attach_hitboxes ;
											set_hitbox_anims

										]",

		attach_hitboxes: "commands ::	[
												//Since we've already grown the array, we'll always have enough hitboxes to be >= the cached array in size; we only have to handle the case where we're detaching spares, not the case where we don't have enough.
											map(range(0, hitbox_count), add_object(cached_hitbox_objs[value])),
											map(range(hitbox_count, size(cached_hitbox_objs)), remove_object(cached_hitbox_objs[value])),
										]",

		set_hitbox_anims: "commands ::	[
											map( range(0, hitbox_count),
												[
													set(box.animation, hitbox_animation),
													set(box.relative_x, (offset.x * value)),
													set(box.relative_y, (offset.y * value)),
												] where box = cached_hitbox_objs[index]
											)
										]",
							
		populate_hitboxes: "commands ::	[
											set(cached_hitbox_objs, cached_hitbox_objs + if( size(cached_hitbox_objs) > hitbox_count, [],
													map( range(size(cached_hitbox_objs), hitbox_count),
														object('damage_beam_attache.hitbox_object', x,y, {facing: facing, mid_x: mid_x + (offset.x * value), mid_y: mid_y + (offset.y * value), animation: hitbox_animation, parent: _parent_obj})
													)
												)
											)
										]",
	},

	on_process: "[process_hitboxes]",
	
	on_create: "[proto_event('hittable_attache','create'),process_hitboxes]",

object_type: [
	{
		id: "stub_hittable",
		/*
			Although these form a series of hitboxes, these often are not used for graphical 'laser beams' - they're often just used to fake diagonal, single-sprite shot hitboxes.
		
			Some 90% of the time, we're going to attach these beams to real, hittable objects, providing the 'core' of all their stats (and usually representing their graphic).  If at all possible, we overwhelmingly want to use those instead.  On rare occasions, such as the gazer boss, we're left with situations where no such natural object exists.  That's what this stub is for - it's a basic hittable object with a few configurable parameters we can set up, hopefully alleviating the need for a certain amount of boilerplate.
		*/
		
		prototype: ["hittable"],
	//	zorder: "@include data/zorder.cfg:in_front_of_everything",
		always_active: true,
		solid_dimensions: [],
		
		properties: {
			taxonomy: "'neutral'",
			attack_damage_to_player: "int :: if(higher_difficulty, 2, 3)",
			attack_damage: "int :: 20",
			team: "string :: _team",
			has_mini_hp_bar: "bool :: false",

			_team: { type: "string", default: "evil" },
		},

	},
	{
		id: "hitbox_object",
		hidden_in_game: true,
		always_active: true,
		serializable: false,
		prototype: ["hittable_attache"],
		
		collide_dimensions: ["enemy","~hazard"],

	}
],

}
