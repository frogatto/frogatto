{
id: "hittable",
prototype: ["transient_object"],
is_strict: true,
collide_dimensions: ["~player","~enemy","~hazard"],

mass: 5,

preload_objects: ['heart_object', 'mana_cube', 'coin_silver_kinetic'],



properties: {
#-------------------------- constructor/destructor logic --------------------------#
	hittable_obj_constructor: "commands :: execute(me, [
					if(not _preexisting_object, attach_mini_hp_bar),
					readd_attaches(me),
					if(original_level_we_spawned_on = null, set(original_level_we_spawned_on, level.id)),
					if(me.is_a_boss and level.player is obj frogatto_playable,
						add(level.player.gui_boss_progress_display.boss_list, [me])
					),
					if(level.cycle < time_last_hit, set(time_last_hit, 0)),  //<- originally meant to trigger `on_start_level`
				])",

	hittable_obj_destructor: "commands :: execute(me,[
					map(me._hittable_attaches, remove_object(value)),
				])",
							




#--------------------------  vars --------------------------#
	time_last_hit: { type: "int", default: 0, persistent: false },
	attributes: { type: "{string->string}", default: {}, persistent: false }, 
	is_a_boss: { type: "bool", default: false, persistent: true },
	_preexisting_object: { type: "bool", default: false },
	original_level_we_spawned_on: { type: "string", dynamic_initialization: true },
	currently_forcing_death: { type: "bool", default: false },
	
#-------------------------- temporary vars --------------------------#

	_in_solidity_fail: { type: "bool", default: false, persistent: false },
	
	_last_entered_water: { type: "int", default: 0, persistent: false },

	_hittable_attaches: { type: "[obj hittable_attache]", default: [] },
	has_already_been_replaced: { type: "bool", default: false, persistent: false },

#--------------------------  constants --------------------------#

		#-- core hittable settings --#	
	team: "string :: 'evil'",
	teams_which_wont_get_hurt_by_me: "[string] :: []",	//a special exemption; used on e.g. the shockwave airplane boss bomb, to keep it from killing the bridge
	flinch_threshold: "int :: 3",
	hurt_velocity_y: "int :: -400",
	hurt_velocity_x: "int :: -200",
	attack_knockback: "int :: 0",
	attack_damage: "int :: 0",
	attack_damage_to_player: "int :: 0",
	damage_type: "DamageType :: enum neutral",  //options include fire, acid, energy
	armor: "int :: 0",
	posthit_invicibility_period: "int :: 0",
	damage_cooldown: "int :: 0",
	sourceless_damage_cooldown: "int :: 20",

	
		#-- behavior/physics flags --#	
	default_solid_dimensions: "[string] :: ['common']",
	swallowable: "bool :: false",
	is_a_flier: "bool :: false",

	is_player_body_part: "bool :: false",
	is_a_physical_gameplay_object: "bool :: true",  //when false, indicates a rare object that happens to use the hittable prototype, but actually isn't physically a part of gameplay itself.  We use this on e.g. the mushroom boss fight controller, and it makes sense for other hittable-attache things.

	taxonomy: "TaxonomyType :: enum neutral",	//e.g. plant, bug, fish, etc.  Used for damage type reductions.
	my_taxonomy: "TaxonomyType :: taxonomy",

	default_anim: "string ::	if(custom_default_anim != null,
									custom_default_anim,
									if(size(usable_animations) > 0,
										usable_animations[0],
										available_animations[0]
									)
								)
									where usable_animations = filter(desired_animations, value in available_animations)
									where desired_animations = ['fly','fly1','stand','walk']",
	custom_default_anim: "string|null :: null",


	

	
		#-- debug flags --#	
	should_debug_output_damage_values: "bool :: false",
	should_debug_output_bad_collision_state_deaths: "bool :: true",


		#-- thrown object info --#	
	basic_type: "string :: me.type",
	thrown_type: "string :: me.basic_type",
	frogourmet_tag: "string :: me.basic_type",  //this actually does have to do with thrown objects, since it's detected upon tongue touch.
	

		#-- rewards --#
	points_value: "int :: 0",

	
		#-- bestiary description --#
	is_enemy_character: "bool :: false", //set to true if the object is, semantically, an enemy. Enables inclusion in the bestiary panel.
	//The following properties can be overridden with a ~translatable string~ in an individual object.
	title:       "string :: 'missing title'",
	description: "string :: dump('no desc for:  ${type}.cfg  ', 'Error, no description for ${type}.\nPlease define a description property.\n(Reported from hittable.cfg:description.)')", //for now, noisily warn if we're missing a description
	taste:       "string :: ''", //Optional, as not everything can be tasted.
	

		#-- shot includes --#
	deflectable_via_attacks: "bool :: if(team = 'player', false, true)",  
	dies_upon_dealing_damage: "bool :: true",
	is_a_shot: "bool :: false",
	goes_through_enemy_shots: "bool :: false",
	
	
		#-- special flags for specific objects --#
	affects_ethereal_block_triggers: "bool :: true",
	
	
		#-- tools for managing the miniature hitpoint bars --#
	has_mini_hp_bar: "bool :: if(is_a_boss, false, true)",
	attach_mini_hp_bar:	"commands :: if(has_mini_hp_bar, spawn('hp_bar_attache', mid_x, mid_y, {facing: 1, parent: me, relative_x: 0, relative_y: - 30, time_to_die: 00}))",
	
	
	
	
	
#--------------------------  core behavior handlers --------------------------#	
	get_hit_by: "def(obj hittable collide_with) -> commands execute(me, [
							handle_special_pre_damage_reaction(collide_with),
	
							if((collide_with.attack_damage > 0) and (collide_with.hitpoints > 0) and collide_with.damage_cooldown < (level.cycle - time_last_hit),
								[
									if((not is_invincible) and collide_with.attack_damage > armor,
										[
											display_posthit_invincibility_flash_sequence(me.posthit_invicibility_period),
											handle_flinch(collide_with),
											handle_damage(collide_with),
											set(time_last_hit, level.cycle),
										]
									)
								]
							),
							handle_knockback(collide_with)
						])",
						
	get_hit_sourceless: "def(DamageType damage_type, int damage_amount) -> commands execute(me, 
						 /*
						 	take damage and invoke the usual behavior, but without having a source object available to refer to.  This almost universally should be used for e.g. being stomped on, or other self-determined damage amounts (falling?).  It's also used for thrown damage because the throwee is dead and would (potentially) be a null reference by the time the latter collision was processed.
						 */
						if((not is_invincible) and (damage_amount >= armor) and (sourceless_damage_cooldown < (level.cycle - time_last_hit)),
								[
									display_posthit_invincibility_flash_sequence(me.posthit_invicibility_period),
									handle_damage_sourceless(damage_type, damage_amount),
									/* specifically skip flinching, because kitties don't do it.  TODO: Might be something to later reconsider. */
									set(time_last_hit, level.cycle),
								]
						)
					)",


	
	/*
		Notes RE: handle_body_collision:
		The business about "all_collisions" and "collision_index" is meant to ensure we don't take multple instances of damage from a damage type that's a stream/flurry in a single frame.  If we get hit, we check for other collisions with the same kind of shot, and only take damage from the first one.
		
		We double-check it's the same collide-with area, because we DO want multiple collisions from an object for each different area; we use this on e.g. the milgram-pod to allow it to be shot out of the air by the player (needs a body area and a thrown area during the thrown anim, rather than the usual "only the thrown area" for player-spat objects).  This mechanism may be the ideal place to check for 'armored regions' on an otherwise vulnerable creature; check if we're getting a collision on both the body and the armor.
		
		TODO:  this may be unwanted on shots without a cooldown, where a "shotgun" effect of multiple hits is desired.


		Notes RE: process_collision:
		There are two special exceptions here besides the 'no friendly-fire' rule - evil_harmless is a special team for thrown enemies wherein they can't hurt anyone, regardless of the target's team, but also - stuff from team 'evil' won't friendly-fire them.  They can and will be hurt by any player actions, though, and any traps/neutral damage sources.
	*/
	
	handle_body_collision: "def(custom_obj _collide_with, string collide_with_area, [builtin user_collision_callable]|null all_collisions=null, int|null collision_index=null) -> commands execute(me,  bind_command( def()
		if(not collide_with_area in ['attack','thrown'],
			
			handle_unusual_collisions(_collide_with, collide_with_area, all_collisions, collision_index),

			if(_collide_with is obj hittable,
				handle_it(_collide_with),
				if(_collide_with is obj hittable_attache, handle_it(_collide_with._parent_obj))
			)

			where handle_it = def(obj hittable collide_with) -> commands  if(not get_hittable_root_object(me).self_or_attache_already_got_hit_this_frame, 
				[//debug(get_hittable_root_object(me).type, get_hittable_root_object(collide_with).type),
				if(all_collisions != null and collision_index != null, if(not  find(   filter(all_collisions,  get_type_of_an_object_or_root_object(value.collide_with) = get_type_of_an_object_or_root_object(collide_with) and value.collide_with_area = collide_with_area), value.collision_index < collision_index), process_collision(collide_with)), process_collision(collide_with))

				where process_collision = def(obj hittable collide_with) -> commands  if(collide_with.team != team and (not team in collide_with.teams_which_wont_get_hurt_by_me) and collide_with.team != 'evil_harmless' and (not (collide_with.team = 'evil' and team = 'evil_harmless')), 
					[
						if(me is obj shot,
							me.maybe_get_hit_by(collide_with),
							me.get_hit_by(collide_with)
						),
						
						set(get_hittable_root_object(me).self_or_attache_last_hit, level.cycle ),
						
						if(collide_with is obj throwable,
							if(not get_hittable_root_object(collide_with).self_or_attache_already_got_hit_this_frame, [
								collide_with.handle_collision_with_hittable(get_hittable_root_object(me), 'body'),
								set(get_hittable_root_object(collide_with).self_or_attache_last_hit, level.cycle ),
							])
						),
						if(collide_with is obj shot, collide_with.handle_attack_area_collision_with_hittable_body(get_hittable_root_object(me))),
						
						//debug(str(level.cycle) + ' ' + str(collide_with_area) +'::'+str(get_type_of_an_object_or_root_object(collide_with)) + ' ' + str(get_type_of_an_object_or_root_object(me)))
					]
				)
		]))))",
	
		/*
			major caveat - this hit-tracking-by-cycle will completely prevent all objects from being hit by more than one thing per frame, period.  This may have some benefits (preventing multiple triggers of the death handling code), but it's worth noting that previously the system allowed multiple hits provided they were of a different type - spread shots of a single type would only have one instance hit per frame, but two damage-sources of different types would both hit.
		*/
	self_or_attache_last_hit: { type:"int", default: -1, persistent: false },
	self_or_attache_already_got_hit_this_frame: "bool :: self_or_attache_last_hit = level.cycle",
	
	get_type_of_an_object_or_root_object: "def(custom_obj _obj) -> string
		if(_obj is obj hittable_attache, _obj._parent_obj.type, _obj.type)
	",
	
	/*
		In any collision logic, we want everything to take into consideration ONLY the very root hittable object; never the attaches.  This translates a reference to either one into the root, only.
	*/
	get_hittable_root_object: "def( custom_obj _obj ) -> obj hittable
		if(_obj is obj hittable, _obj, _obj._parent_obj asserting _obj is obj hittable_attache)
	",
	
	/*
		Notes RE: handle_body_collision:
		Our core collisions are a trifecta of: ['body','attack','thrown'], but our system gives us the possibility of any name, for implementing anything else that's dependent on object-to-object contact.  This is used, for example, to implement 'interact' areas.
	*/
	handle_unusual_collisions: "def(custom_obj collide_with, string collide_with_area, [builtin user_collision_callable]|null all_collisions=null, int|null collision_index=null) -> commands  null",	//a virtual hook for doing any other collide types than the built-in ones.
	
	
	
	
	
	
#-------------------------- attache logic --------------------------#
	graphical_body_parts: "[custom_obj] :: me_and_hittable_attaches",
	me_and_hittable_attaches: "[obj hittable|obj hittable_attache] :: [me] + _hittable_attaches",
	_all_attaches: "[obj hittable_attache|obj effects_attache] :: _effects_attaches + _hittable_attaches",
	
	handle_grabbed_cleanup: "commands :: map(_all_attaches, remove_object(value))",



	/*
		Notes RE: replacement_object_with_preserved_attributes:
		Our current idiom for changing objects from one type to another is to delete the object of type A, and spawn a new object of type B "in situ"; with only the properties we explicitly want to preserve, preserved.  Our previous system preserved all stored-data properties, and simply changed the type name (thus replacing only the evaluatable events/properties).  We ran into a *lot* of issues where preserved state had lots of unexpected side-effects (for an easy example, some objects would set fall_through_platforms or solid/collide dimensions, and not have them get unset upon swapping to a different type (since the new type had none of the cleanup code)).  This new system isn't perfect, but it's a heck of a lot less stateful, which kills a lot of bugs.
	*/	
	replacement_object_with_preserved_attributes: "def(obj hittable source_object, string dest_obj_type, int|null new_hitpoints=null, int|null new_max_hitpoints=null) -> obj hittable
			(obj hittable <- object(dest_obj_type, source_object.mid_x, source_object.mid_y,
				{
					hitpoints: if(new_hitpoints != null, new_hitpoints, source_object.hitpoints),
					max_hitpoints: if(new_max_hitpoints != null, new_max_hitpoints, source_object.max_hitpoints),
				}
				+
				hittable_attribute_extractor(source_object)
				+
				source_object.unique_attribute_extractor(source_object)
			))",

	unique_attribute_extractor: "def(obj hittable source_object) -> map
		{}	
	",

	hittable_attribute_extractor: "def(obj hittable source_object) ->
		{
			facing: int,
			attributes: {string->string},
			variations: [string],
			event_handlers: object,
			_effects_attaches: [obj effects_attache],
			_hittable_attaches: [obj hittable_attache],
			_preexisting_object: bool,
			original_level_we_spawned_on: string,
			label: string
		}
		{
			facing: source_object.facing,
			attributes:source_object.attributes,
			variations: source_object.variations,
			event_handlers:source_object.event_handlers,
			_effects_attaches: source_object._effects_attaches,
			_hittable_attaches: source_object._hittable_attaches,
			_preexisting_object: true,
			original_level_we_spawned_on: source_object.original_level_we_spawned_on,
			label: source_object.label
		}",

			
	replacement_object_with_preserved_attributes_and_physics: "def(obj hittable source_object, string dest_obj_type, int|null new_hitpoints=null, int|null new_max_hitpoints=null) -> obj hittable
			(obj hittable <- object(dest_obj_type, source_object.mid_x, source_object.mid_y, {
				velocity_x: source_object.velocity_x,
				velocity_y: source_object.velocity_y,
				facing: source_object.facing,
				hitpoints: if(new_hitpoints != null, new_hitpoints, source_object.hitpoints),
				max_hitpoints: if(new_max_hitpoints != null, new_max_hitpoints, source_object.max_hitpoints),
				attributes:source_object.attributes,
				variations: source_object.variations,
				event_handlers:source_object.event_handlers,
				_effects_attaches: source_object._effects_attaches,
				_hittable_attaches: source_object._hittable_attaches,
				_preexisting_object: true,
			}))",			




			/*
				in the event that this automatically/accidentally gets called in a situation where we're "insta-killing" the object we're bringing back (which is a pattern we use from time to time to trigger the death behavior of the "real" object), we need to completely skip doing this transfer, because the objects we transfer would get orphaned.  (Currently this is because effects_attaches have a special behavior to treat "having their destructor triggered" (which is automatic) and "being transferred" as timestamped events, and if both occur simultaneously, the destructor cancels itself.  Unfortunately, that about fully loads the dimensionality of of that information channel, so we can't sneak any more "magical" behavior in there to elide automatically-triggered stuff.)
				
				If we ever get ourselves in a situation where we want to write special, per-attache destruction behavior (for example, if we have some long segmented worm that blows up, segment-by-segment, as it dies), and if that situation involves us specifically putting that behavior **in the hittable_attache objects themselves**, rather than 'faking' it in the parent, then we might need to rethink this slightly.
				
				Also do note that the wrapping [] is important, for some subtle command-sequence reasons.
			*/
	remap_attaches_from_old_to_new: "def( obj hittable old_obj, obj hittable new_obj ) -> commands
				[
					if(not old_obj.currently_forcing_death, [
						set(old_obj.has_already_been_replaced, true);  //we don't have to worry about unsetting this, because the old object is being deleted
						map(new_obj._effects_attaches, [
								set(value.recorded_transfer_at, value.cycle + value.time_to_die),
								set(value.parent, new_obj),
								value.initialize_position,
							]),
						map(new_obj._hittable_attaches, [set(value.parent, new_obj), set(value.parent, new_obj), set(value.relative_x, 0), set(value.relative_y,0)])
					])
				]",


	remap_my_attaches_to_me: "commands :: [
											map(me._effects_attaches, [
												set(value.recorded_transfer_at, value.cycle + value.time_to_die),
												set(value.parent, me),
												value.initialize_position,
											]),
											map(me._hittable_attaches, [
												set(value.parent, me),
												set(value.parent, me),
												set(value.relative_x, 0),
												set(value.relative_y,0)
											])
										]",




#-------------------------- behavior handlers --------------------------#
#-- anims/movement --#


		/*
			meant for unique actions that happen upon getting hit, but take place BEFORE taking damage, and can potentially abort the whole damage chain - right now this isn't quite in the right position to do this (it can only do so by replacing the object before damage is dealt at the end of processing), but we'll reposition it when need arises to actually use this, and make the rest of the damage chain an executable parameter.  Good uses of this include becoming invincible in response to taking damage without actually taking damage, or setting off a timed explosion, etc.
		*/
	handle_special_pre_damage_reaction: "def(obj hittable|null collide_with) -> commands null #virtual#",


		/*
			meant for unique actions upon taking damage, like losing wings.  Also for special type-based behavior that happens regardless of damage amount (such as maybe a feathered creature having its feathers burned off and effectively turning into a different, flightless enemy type).  Because this has the potential to be highly conditional on whether the creature dies or not, we pass in a bool for death (some responses like losing feathers should always happen; some responses like extruding spikes and hurting the player should only happen if the creature doesn't die).
		*/
	handle_special_damage_response: "def(DamageType damage_type, int final_damage_amount, bool will_die) -> commands null #virtual#",

	
	handle_flinch: "def(obj hittable collide_with) -> commands
			execute(me, if(final_damage_amount(collide_with, collide_with.attack_damage) >= flinch_threshold, if(me.is_a_flier, cause_flinch(collide_with), if(is_standing, cause_flinch(collide_with))) ))",

	cause_flinch: "def(obj hittable|null collide_with) -> commands execute(me, [
			add(me.velocity_x,me.hurt_velocity_x * sign(me.midpoint_x - if(collide_with, collide_with.midpoint_x, 0))), 
			add(me.velocity_y,me.hurt_velocity_y),
			cause_hurt_anim(collide_with)
			])",

	cause_hurt_anim: "def(obj hittable|null collide_with) -> commands execute(me, if('hurt' in available_animations,set(me.animation, 'hurt')))",

	player_damage_response: "def(DamageType damage_type, int amount) -> commands null",	//player objects will always do special responses to damage (like making the screen flash), besides the built-in stuff

	enter_water_only_once_per_frame: "execute(me, bind_command(def() [if(level.cycle > _last_entered_water, [set(_last_entered_water, level.cycle), bind_command(def() enter_water)] )]))",
	enter_water: "commands :: null",

	elastic_collision: "def( obj hittable the_other_object, {multiplier: decimal, constraint: {min: decimal, max: decimal}|null} params ) -> commands
		([set(velocity_x, radius * cos(angle)), set(velocity_y, radius * sin(angle))]
		where angle = lib.math.angle(the_other_object, me)
		where radius = if(params.constraint, lib.math.constrain(params.constraint.min, params.multiplier * velocity_magnitude , params.constraint.max), params.multiplier * velocity_magnitude) )
		where velocity_magnitude = hypot(velocity_x,velocity_y)",
		

			/*there's a sharp loss of precision as this goes through the calculations, even though the resulting angles from the calcs are right.  I've beaten my head against this and can't, for the life of me, figure out what's going wrong; I don't know if it's due to data type precision, or what.  So what we're doing instead is figuring out how much we've deviated from the correct "conservation of momentum" velocity magnitude, and we use that as a fudge-factor to multiply the values back up into the right ballpark area.  It's a horrible hack ... but that's the price of getting things done. */
	
	two_party_elastic_collision: "def( obj movable_enemy|obj throwable other_object, decimal multiplier=1.0) -> commands
			internal_two_party_elastic_collision( (obj hittable <- other_object), multiplier)",
	
			
	internal_two_party_elastic_collision: "def( obj hittable other_object, decimal multiplier=1.0 ) -> commands
			if(cycle - _last_elastic_collided > 0 and cycle - other_object._last_elastic_collided > 0, 
			[
				set(velocity_x, (my_new_velocity.x) * fudge_factor * multiplier),
				set(velocity_y, (my_new_velocity.y) * fudge_factor * multiplier),
				set(other_object.velocity_x, (others_new_velocity.x) * fudge_factor * multiplier),
				set(other_object.velocity_y, (others_new_velocity.y) * fudge_factor * multiplier),
				set(_last_elastic_collided, cycle),
				set(other_object._last_elastic_collided, cycle)
			])
			
		where fudge_factor = 1.002 * ((abs(hypot(velocity_x,velocity_y))+abs(hypot(other_object.velocity_x,other_object.velocity_y))) /
				 ((abs(hypot(my_new_velocity.x,my_new_velocity.y)) + abs(hypot(others_new_velocity.x,others_new_velocity.y))))),


		where my_new_velocity = {	x: cos(angle_of_incidence) * my_new_velocity_in_rotated_coords.x  +  cos(opp_angle_of_incidence) * my_new_velocity_in_rotated_coords.y,
		 							y: sin(angle_of_incidence) * my_new_velocity_in_rotated_coords.x  +  cos(opp_angle_of_incidence) * my_new_velocity_in_rotated_coords.y },
		 							
		where others_new_velocity = {	x: cos(angle_of_incidence) * others_new_velocity_in_rotated_coords.x  +  cos(opp_angle_of_incidence) * others_new_velocity_in_rotated_coords.y,
		 								y: sin(angle_of_incidence) * others_new_velocity_in_rotated_coords.x  +  cos(opp_angle_of_incidence) * others_new_velocity_in_rotated_coords.y },
		 							
	
		where my_new_velocity_in_rotated_coords = {	x: (my_velocity_in_rotated_coords.x * (my_mass - others_mass) + others_velocity_in_rotated_coords.x * (my_mass + others_mass)) / (my_mass + others_mass),
													y: my_velocity_in_rotated_coords.y },
		where others_new_velocity_in_rotated_coords = { x: (my_velocity_in_rotated_coords.x * (my_mass + others_mass) + others_velocity_in_rotated_coords.x * (others_mass - my_mass)) / (my_mass + others_mass),
														y: others_velocity_in_rotated_coords.y },
	
		where my_velocity_in_rotated_coords = {	x: my_vel_mag * cos(my_angle_of_motion - angle_of_incidence), y: my_vel_mag * sin(my_angle_of_motion - angle_of_incidence)}
			where my_vel_mag = hypot(velocity_x,velocity_y)
			where my_angle_of_motion = atan2( velocity_y, velocity_x )
		where others_velocity_in_rotated_coords = {	x: others_vel_mag * cos(others_angle_of_motion - angle_of_incidence), y: others_vel_mag * sin(others_angle_of_motion - angle_of_incidence)}
			where others_vel_mag = hypot(other_object.velocity_x,other_object.velocity_y)
			where others_angle_of_motion = atan2( other_object.velocity_y, other_object.velocity_x )

		where my_mass = 1.0 where others_mass = 1.0
		where angle_of_incidence = lib.math.angle(other_object, me)
		where opp_angle_of_incidence = lib.math.angle(me, other_object)",
		
	_last_elastic_collided: { type:"int", default: 0 },
		
		
	
	
	
#-- damage --#
	//meant for applying any kind of arithmetic to the raw damage amount, based on type.
	
		//this is what you overload if you want to have an exception to the damage tables (i.e. for an unusual weakness; as opposed to a usual one for a given type)
	handle_custom_damage_type_modifications: "def(DamageType damage_type, int amount) -> int|null null #virtual#",  
	
		//only overload this if you want to completely annul the damage tables for this object (i.e. for complete immunity to all but one damage type)
	handle_damage_type_modifications: "def(DamageType damage_type, int amount) -> int
		if(handle_custom_damage_type_modifications(damage_type,amount) != null,  int <- handle_custom_damage_type_modifications(damage_type,amount),
			if(custom_damage_table != null, int(custom_damage_table[damage_type] * amount),
				if(my_taxonomy in keys(damage_tables), int(damage_tables[my_taxonomy][translate_damage_type_analogs(damage_type)] * amount), amount
		)))", //the neutral case automatically falls through
	
	
	//meant for flat, type-agnostic reductions to ALL damage.
	handle_base_damage_reductions: "def(int amount) -> int amount #virtual#",  
	
	final_damage_amount: "def(interface {damage_type: DamageType} collide_with, int damage_amount) -> int
		if((damage_amount < armor) or me.is_invincible,
			0,
			handle_damage_type_modifications(collide_with.damage_type, handle_base_damage_reductions( damage_amount ))
		)",
		
	will_be_dead: "def(int damage_amount) -> bool ((me.hitpoints - damage_amount) <= 0)",

	
	handle_damage_sourceless: "def(DamageType incoming_damage_type, int amount) -> commands execute(me,[
			if(not will_be_dead(dmg), [
				handle_adding_damage_reaction_status_effects(incoming_damage_type),
				/* we don't do the code to add attack-specific status effects, because there is no attacker */
			]) ;
			handle_special_damage_response(incoming_damage_type, dmg, will_be_dead(dmg)),
			if(will_be_dead(dmg), handle_death({damage_type:incoming_damage_type})),
			add(me.hitpoints, -dmg),
			display_hurt_visuals({damage_type:incoming_damage_type},dmg),
			player_damage_response(incoming_damage_type,dmg),
			me.maybe_output_damage_debug_info(dmg, str(incoming_damage_type) + ' sourceless')
		])
			where dmg = final_damage_amount({damage_type:incoming_damage_type}, amount)",

	handle_damage: "def(obj hittable collide_with) -> commands execute(me,[
			if(not will_be_dead(dmg), [
				handle_adding_damage_reaction_status_effects(collide_with.damage_type),
				map(collide_with.status_effects_this_attack_inflicts, status_effect_add(value, me)),
			]) ;
			handle_special_damage_response(collide_with.damage_type, dmg, will_be_dead(dmg)),
			if(will_be_dead(dmg), handle_death(collide_with)),
			add(me.hitpoints, - dmg),
			display_hurt_visuals(collide_with,dmg),
			player_damage_response(collide_with.damage_type,dmg),
			me.maybe_output_damage_debug_info(dmg, str(collide_with.damage_type) + ' from ' + collide_with.type)
		])
			where dmg = final_damage_amount(collide_with, attack_damage_amount)
			where attack_damage_amount = if((me is obj player_controlled) and collide_with.attack_damage_to_player, collide_with.attack_damage_to_player, collide_with.attack_damage)",

	maybe_output_damage_debug_info: "def(decimal _dmg, string source) -> commands if(should_debug_output_damage_values, debug('cycle:' + level.cycle + ' ' + me.type + ':'+ addr(me) + ':  ' +  me.hitpoints + 'hp - ' + _dmg + 'dmg, which came from ' + source))",

	handle_knockback: "def(obj hittable collide_with) -> commands execute(me,add(velocity_x, behind_or_in_front * collide_with.attack_knockback) where behind_or_in_front = sign(me.mid_x - collide_with.mid_x) )",

	custom_damage_table: "{DamageType -> decimal} | null ::
							null",

	/*
	some rationales for these types:
		neutral:  is the grab-bag for unaffiliated attacks that always do full damage, including self-damage, etc.

		fire, energy, acid, arcane:  are all justified by allowing each of frogatto's attacks to have different barriers to break (which lock off major areas of the game).  They're also used to e.g. have some enemies completely immune to the basic thrown attacks, which are of the "impact" type, forcing the player to experiment with different damage types.  Generally all enemies have a particular weakness.
		
		impact, lacerate:  exist to give basic physical contacts different behaviors; we have e.g. hard-shelled bugs which aren't harmed much by scratches, but are crushed by impact.
	*/


	damage_type_to_string: "def(DamageType input) -> string
						switch(input,
							enum neutral,			'neutral',
							enum none,				'none',
							enum fire,				'fire',
							enum ice,				'ice',
							enum energy,			'energy',
							enum arcane,			'arcane',
							enum acid,				'acid',
							enum impact,			'impact',
							enum impale,			'impale',
							enum lacerate,			'lacerate',
							enum stab,				'stab',
							enum organic_bludgeon,	'organic_bludgeon',
							enum slash,				'slash',
							enum bite,				'bite',
							enum electricity,		'electricity'
						)",	


	translate_damage_type_analogs: "def(DamageType specific_type) -> DamageType 
						switch(specific_type,
							enum none,					enum neutral,
							enum stab,					enum impale,
							enum slash,					enum lacerate,
							enum bite,					enum lacerate,
							enum organic_bludgeon,		enum impact,
							enum electricity,			enum energy,
														specific_type				
						)",  

	damage_tables: "{ TaxonomyType -> {DamageType -> decimal} } ::
						{	
							enum bug: {
											enum neutral: 1.0,
											enum fire: 0.75,
											enum ice: 0.75,
											enum energy: 1.0,
											enum arcane: 1.0,
											enum acid: 1.25,
											enum impact: 2.0,
											enum impale: 0.50,
											enum lacerate: 0.25,
									},
							enum plant: {
											enum neutral: 1.0,
											enum fire: 1.0,
											enum ice: 1.0,
											enum energy: 0.5,
											enum arcane: 1.0,
											enum acid: 0.25,
											enum impact: 0.0,
											enum impale: 0.25,
											enum lacerate: 0.5
									},
							enum mushroom: {
											enum neutral: 1.0,
											enum fire: 1.0,
											enum ice: 0.5,
											enum arcane: 2.0,
											enum energy: 1.5,
											enum acid: 0.0,
											enum impact: 0.0,
											enum impale: 0.25,
											enum lacerate: 1.0
									},
							enum stone: {
											enum neutral: 1.0,
											enum fire: 0.0,
											enum ice: 0.0,
											enum energy: 0.5,
											enum arcane: 0.75,
											enum acid: 2.0,
											enum impact: 1.0,
											enum impale: 0.25,
											enum lacerate: 0.0
									},
							enum milgramen: {
											enum neutral: 1.0,
											enum fire: 0.75,
											enum ice: 0.75,
											enum energy: 1.0,
											enum arcane: 1.0,
											enum acid: 0.75,
											enum impact: 1.0,
											enum impale: 1.0,
											enum lacerate: 1.0
									},
							enum fish: {	
											enum neutral: 1.0,
											enum fire: 0.0,
											enum ice: 1.5,
											enum energy: 1.5,
											enum arcane: 1.0,
											enum acid: 0.5,
											enum impact: 0.5,
											enum impale: 1.0,
											enum lacerate: 1.0
									},
							enum mechanical: {
											enum neutral: 1.0,
											enum ice: 0.0,
											enum fire: 0.0,
											enum energy: 1.0,
											enum arcane: 1.0,
											enum acid: 1.5,
											enum impact: 0.5,
											enum impale: 0.25,
											enum lacerate: 0.0
									},
							enum spectral: {
											enum neutral: 1.0,
											enum ice: 0.0,
											enum fire: 0.0,
											enum energy: 1.0,
											enum arcane: 1.0,
											enum acid: 0.0,
											enum impact: 0.0,
											enum impale: 0.0,
											enum lacerate: 0.0
									},
							enum mammal: {
											enum neutral: 1.0,
											enum fire: 1.0,
											enum ice: 0.5,
											enum energy: 0.5,
											enum arcane: 0.5,
											enum acid: 1.5,
											enum impact: 1.0,
											enum impale: 0.75,
											enum lacerate: 1.0
									},
							enum bird: {	
											enum neutral: 1.0,
											enum fire: 1.5,
											enum ice: 0.5,
											enum energy: 0.5,
											enum arcane: 0.5,
											enum acid: 0.5,
											enum impact: 1.0,
											enum impale: 0.75,
											enum lacerate: 1.5
									},
								}",										

#-- death --#
	force_death: "def(DamageType damage_type=enum neutral) -> commands execute(me, bind_command(def() 
							[
								; set(currently_forcing_death, true)
								; handle_death({damage_type: damage_type})
								; die()
							]
						))",

	should_track_death: "bool :: false", //tracking is for achievements
	handle_death: "def(interface {damage_type: DamageType} collide_with) -> commands execute(me, bind_command(def() [
						; set(currently_forcing_death, true)
						; add(level.player.score,points_value),
						if(not acquirable_item_drop_value = null,drop_acquirable_items()),
						if(should_track_death, level.player.register_kill(me)),
						if(me.corpse_object_type, spawn_corpse),
						destructor,
						
						death_effects( _death_fx_type )
						] where _death_fx_type =	if(collide_with.damage_type in death_fx_damage_types_that_have_animations and (not death_fx_ignore_damage_type),
														damage_type_to_string(collide_with.damage_type),
														death_fx_type
													)
						
						) asserting level.player is obj player_controlled)",
						
	spawn_corpse: "commands :: if(corpse_object_type is string, spawn(corpse_object_type, mid_x, mid_y, facing))",
	corpse_object_type: "string|null :: null",

	my_taxonomy_as_string: "string :: switch(my_taxonomy,   //this is just a bit of glue to ease the transition to enums-for-all-stringly-typed stuff.
									enum bug,			'bug',
									enum plant,			'plant',
									enum mushroom,		'mushroom',	
									enum stone,			'stone',
									enum milgramen,		'milgramen',
									enum fish,			'fish',
									enum mechanical,	'mechanical',
									enum spectral,		'spectral',
									enum mammal,		'mammal',
									enum bird,			'bird',
														'neutral'
							)", 


	death_fx_type: "string :: if(my_taxonomy_as_string in keys(death_fx_table), death_fx_table[my_taxonomy_as_string], 'medium')",
	death_fx_ignore_damage_type: "bool :: false", //certain bosses always have the same death effects, rather than having "special" ones according to what they got damaged by.
	death_fx_damage_types_that_have_animations: "[DamageType] :: [enum none, enum fire, enum acid, enum energy]",   //we don't and won't have special animations for all damage types, only for "flashy" ones like fire and such.
	death_fx_table: "{string->string} :: {
						'bug':			'bug', 
						'plant':		'plant', 
						'mushroom':		'mushroom',
						'mammal':		'animal', 
						'bird':			'animal', 
						'fish':			'animal', 
						'milgramen':	'milgramen',
						'stone':		'stone',
						'mechanical':	'medium',
						'spectral':		'medium',
					}",
#-- invincibility --#
	is_invincible_posthit: "bool :: if(time_last_hit and (abs(time_last_hit - level.cycle) < posthit_invicibility_period), true, false)",
	is_invincible: "bool :: (
								bool(invincible) or
								level.in_dialog or
								is_invincible_posthit or
								(me is obj player_controlled and (size(the_player.control_lock_registry) > 0))
							) where the_player = (obj player_controlled_platformer_character <- level.player)",




#-------------------------- item drop logic --------------------------#
#-- core settings --#
	acquirable_item_drop_value: "int :: 0",  //how many of the dropped items the dying monster/thing is worth.
	
	acquirable_item_drop_value_delta_scale:  "decimal :: 0.75", //if the original is, say, 10, this means we could land anywhere between 10, and 18 (rounded up)
	
	final_acquirable_item_drop_value: "int :: max(0, lib.math.round( me.acquirable_item_drop_value + ( 1d( me.acquirable_item_drop_value * acquirable_item_drop_value_delta_scale) - 1.0) ))",



#-- raw stats tables --#
	_drop_item_list: "{string -> int} :: {
									'heart_object' : 10,
									'mana_cube' : 7,
									'coin_silver_kinetic' : 5
								}",
								
	_drop_item_weights: "{string -> int} :: {
									'heart_object' : 50,
									'mana_cube' : 70,
									'coin_silver_kinetic' : 130
								}",
								
	drop_item_validity: "{string -> bool} :: {
									'heart_object' : (not level.player.hitpoints = level.player.max_hitpoints),
									'mana_cube' : true,
									'coin_silver_kinetic' : true
								}",



#-- filtered by those allowed to drop --#
	sans_undroppables: "def({string -> int} source) -> {string -> int} filter(source, drop_item_validity[key])",

	drop_item_list: "{string -> int} :: sans_undroppables(_drop_item_list)",
	
	drop_item_weights: "{string -> int} :: sans_undroppables(_drop_item_weights)",


	
#-- filtered by that, and by how many points are left in the current process of dropping --#
	drop_item_list_remaining: "def(int value_left) -> {string -> int} filter(drop_item_list, value <= value_left)",

	drop_item_weights_remaining: "def(int value_left) -> {string -> int} filter(drop_item_weights, key in drop_item_list_remaining(value_left))",					

	

#-- the actual drop logic --#
	
	/*
		This is a little unintuitive, so here's how `search_drop_list` works:
		
			â€¢ choose_drop_item_weighted:
		Each item has a weight, which is basically like a % chance, except it doesn't have to add up to 100; it's still just a fractional chance.  What choose_drop_item_weighted does is it basically rolls a value from 0->total.  It then steps through the list of possible drops and decides "does the number I rolled match the 'slice of the pie' allotted to each kind of item?"  It's doing a tally, rather than comparing the individual value for each slice, so it behaves correctly for any number of inputs - if our first item was worth 10, and the second was worth 70, it'd be searching for 80 and 10, not 70 and 10.  It searches in ascending order, because key-value maps in Anura are automatically ordered by the engine in descending order of the value.
		
		Now, for each step through, it needs to also filter out the list to see if the remaining points for 'what could still be dropped' include the thing in question.  To do this, it passes all choices through a set of simple filters that weed out what's inappropriate to still roll for.

	*/
	//choose_drop_item_nonweighted: "string :: choose(keys(drop_item_list))",  //unused but useful reference
	
	choose_drop_item_weighted: "def(int value_left) -> string|null search_drop_list(__weights, 0, 0, 1d(sum(values(__weights))))
					where __weights = drop_item_weights_remaining(value_left)",
	
	search_drop_list: "def({string -> int} potential_drop_list, int i, int tally, int target_val) -> string|null
			if(size(potential_drop_list) > 0,
				if(tally >= target_val,
					keys(potential_drop_list)[i-1],
					search_drop_list( potential_drop_list, i+1, tally + values(potential_drop_list)[i], target_val)
				),
				null
			)",

	calculate_drop_items: "def(int value_left, [string] toBeDropped) -> [string]
			if( anything_can_still_be_dropped,
				calculate_drop_items(value_left - cost_of_item_we_are_dropping, if(picked != null,
					toBeDropped + [picked],
					toBeDropped
				)),
				toBeDropped
			)
			
				where cost_of_item_we_are_dropping = int :: if(picked != null, __item_list[picked], 0)
				where picked = choose_drop_item_weighted(value_left)
				where anything_can_still_be_dropped = (find(values(__item_list), value <= value_left) != null) and (value_left > 0)
				where __item_list = drop_item_list_remaining(value_left)",
				
	drop_acquirable_items: "def() -> commands
			if((not higher_difficulty) or 1d4=4,
				map( calculate_drop_items((me.final_acquirable_item_drop_value), []),
					spawn(value, me.mid_x, me.y, {facing:facing, velocity_x: velocity_x/6 +1d600-300, velocity_y: velocity_y/6})
				)
			)",





#-------------------------- status effects - buffs and debuffs --------------------------#
	status_effect_presets: "[StatusEffectKindInfo]
								::
							[{
								kind: enum burning,
								process_effect:	def(obj status_effect_attache instance) -> commands
													[if((level.cycle - instance.cycle_started_at) % 5 = 0,
														instance.hittable_parent.get_hit_sourceless(enum fire, 10)
													)],
								visual_fx_type: enum fire,
								duration: null,
							},{
								kind: enum poison,
								process_effect:	def(obj status_effect_attache instance) -> commands
													[if((level.cycle - instance.cycle_started_at) % 5 = 0,
														if(instance.hittable_parent.handle_damage_type_modifications(enum acid, 5) != 0,
															instance.hittable_parent.get_hit_sourceless(enum acid, 5),
															instance.schedule_forced_death_cleanup
														)
													)],
								visual_fx_type: enum poison,
								duration: null,
							},{
								kind: enum exploding,
								process_effect:	def(obj status_effect_attache instance) -> commands
													[if((level.cycle - instance.cycle_started_at) > 150,
														[
															spawn('explosion_big_harmful', instance.hittable_parent.mid_x, instance.hittable_parent.mid_y, 1),
															instance.schedule_forced_death_cleanup,
														]
													)],
								visual_fx_type: enum explosive,
								duration: null,
							},{
								kind: enum frozen,
								process_effect:	def(obj status_effect_attache instance) -> commands
													[
														set(instance.hittable_parent.time_in_animation, 0),
														set(accel_x, 0),
														set(accel_y, if(instance.hittable_parent.should_fall_when_stunned, 80, 0)),
													],
								visual_fx_type: enum frozen,
								duration: 120,
							},{
								kind: enum bubble_trapped,
								process_effect:	def(obj status_effect_attache instance) -> commands
													[
														set(instance.hittable_parent.time_in_animation, 0),
														set(accel_x, 0),
														set(accel_y, if(instance.hittable_parent.should_fall_when_stunned, 80, 0)),
													],
								visual_fx_type: enum bubble_trapped,
								duration: 300,
							}]",

	status_effect_add:	"def(StatusEffectKind kind, obj transient_object the_parent) -> commands execute(me,
		if(not has_status_effect(kind, the_parent),
			( ; spawn('status_effect_attache', mid_x, mid_y, {
				kind: kind,
				parent: the_parent,
				time_to_die: 50,
			})  )
		)
	)",

	has_status_effect: "def(StatusEffectKind kind, obj transient_object the_parent) -> bool (
		find(
			filter(the_parent._effects_attaches, value is obj status_effect_attache),
			value.kind = kind
		) != null
	)",
				
		/*
			Certain types of enemies will always receive a status effect when they take a damage source that's a certain type of damage, regardless of what attack actually delivers it.  Plants catch on fire when attacked by fire.
		*/
	handle_adding_damage_reaction_status_effects: "def(DamageType incoming_damage_type) -> commands
		if(me.my_taxonomy = enum plant and incoming_damage_type = enum fire,
			status_effect_add(enum burning, me)
		)
	",
	
		/*
			We also have the ability to let individual attacks deliver status effects.  Most acid attacks only temporarily affect the victim, but the super-acid-attack will inflict a poison status.
		*/
	status_effects_this_attack_inflicts: "[StatusEffectKind] :: []",	
		
	//handle_delivering_attack_specific_status_effects: "def(obj hittable victim) -> commands
	//	null
	//",  

	// someday we might populate this, but for the time behind having this would be quite silly, as there would basically be ... an empty table with one valid entry.
	//damage_reaction_status_effect_vulnerability_table: "{ TaxonomyType -> {DamageType -> StatusEffectKind|null} }"


	should_fall_when_stunned: "bool :: do_we_have_a_solid_area",
	
#-------------------------- cosmetic functions --------------------------#
	play_grabbed_cosmetics: "commands :: [
									play_hurt_sounds(enum neutral, 1, my_taxonomy),
									play_object_specific_grabbed_cosmetics,
								]",

	display_hurt_visuals: "def(interface {damage_type: DamageType} collide_with, int amount) -> commands execute(me, 
						[
							play_hurt_sounds(collide_with.damage_type, amount, my_taxonomy),
							display_damage_type_particles(collide_with.damage_type, amount),
							if(amount > 0, hurt_flash_sequence, invincible_flash_sequence)
						]
					)",

	death_effects: "def(string type) -> commands execute(me,
			play_death_effects(type, victim_size)
			
			where victim_size = switch( true,
				me.physical_size >= 48,									enum big,
				me.physical_size <= 16 and me.physical_size > 8,		enum small,
				me.physical_size <= 8,									enum tiny,
																		enum small
			)
		)",
	
					
					
					
					
					
#-------------------------- bad game state handling --------------------------#

		//this is meant to be a client function only used from individual monster classes and such.	
	handle_damage_from_immersion: "def(object the_water_object) -> commands //water_object is accessible within any object event, if one exists
		[
			if(underwater and not is_invincible_posthit, 										
				if( the_liquid.liquid_damage, 
					get_hit_sourceless(the_liquid.damage_type, the_liquid.liquid_damage)
				)
			),
		] where the_liquid = (obj liquid <- water_object)",											


	die_from_bad_collision_state: "[if(should_debug_output_bad_collision_state_deaths, debug('bad collision state death in: ' + call_stack)), force_death()]", 



},










#-------------------------- collision event handling --------------------------#

	on_outside_level: "if(y > level.dimensions[3] and unless_we_shouldnt, force_death())
		where unless_we_shouldnt = if(level.player is obj player_controlled,
										not (
												level.player.exempt_from_dying_whilst_falling_rules_for_a_cutscene or level.player.exempt_from_dying_whilst_falling_due_to_level_portals
											),
									true)",




	on_collide_object_body: "handle_body_collision(arg.collide_with, arg.collide_with_area, arg.all_collisions, arg.collision_index)",

	on_enter_water: "enter_water_only_once_per_frame",






#-------------------------- error condition handling --------------------------#
	on_change_solid_dimensions_fail: "fire_event('solidity_fail')",
	on_change_animation_failure: "fire_event('solidity_fail')",

		# if the level starts, and we're embedded in solid stuff, try moving upwards to get out of it.
		# this should catch any errors introduced by changes to solid area or handling thereof
	on_solidity_fail: "if(_in_solidity_fail, die_from_bad_collision_state,
				[
					set(_in_solidity_fail, true),
				  	resolve_solid(me),
					set(_in_solidity_fail, false)
				])",
			  
	on_add_object_fail: 	"if(collide_with is obj hittable,
									/*	if it's hittable, we'll definitely kill ourselves, but let's at least damage it on the way out.
										The purpose of this is to punish the player if they're 'camping' a spawn point for, say, an anthill.
										It's fine if they can use it to kill enemies, but it should not be *free*. */
								[if(collide_with.team != team and collide_with.get_hit_by, collide_with.get_hit_by(me)), die_from_bad_collision_state],
									/* if we're stuck on something that's not hittable, we have to treat the other party as indestructible; we're the one that has to give */
								die_from_bad_collision_state
							) where collide_with = arg.collide_with",
							
}
