/*
 building off of 'throwable', this prototype makes an enemy which can be thrown like an ant, and has the same 'recovery from being thrown' where it sits and twitches on the ground briefly before hopping upwards again.
 to conform to this prototype, an object needs to:
 - specify a thrown animation with a thrown-area that covers the whole of the object, and with no body area.
 - specify an on_back animation with regular body area
 - an animation specified in 'consts' which it will revert to after recovering 
*/

{
id: "throwable_small_enemy",
prototype: ["throwable"],
mass: 5,
friction: 1000,
traction: 1000,
solid_area: [5,10,20,25],
solid_dimensions: ["enemy","common"],
properties: {
	swallowable: "bool :: true",

	team: "string :: if(velocity_x != 0 or velocity_y != 0, if(time_spat != null, 'player','evil'), 'evil_harmless')",
	hurt_velocity_y: "int :: -400",
	hurt_velocity_x: "int :: 200",
	attack_damage: "int :: if(animation in ['thrown'], standard_thrown_damage, 1)",
		
	on_back_duration: "int :: 200",  #if we're re-running the thrown animation.
	default_solid_dimensions: "[string] :: ['enemy','common']",
	default_anim: "string :: 'stand'",
	basic_type: "string :: regex_replace(me.type,'.thrown','')", 
	frogourmet_tag: "string :: basic_type",
	springiness: "int :: 190",
	spring_amount: "int :: 1200",
	bounce_roundness: "int :: 10",
	
	
	
	
	enter_water: "[
						remove_object(me),
						add_object(replacement_object),
						set(replacement_object.animation,default_anim),
						replacement_object.enter_water_only_once_per_frame
					] where replacement_object = replacement_object_with_preserved_attributes(me, basic_type)",
	
	
	handle_death: "def(interface {damage_type: string} collide_with) -> commands execute(me, bind_command(def() [
			remove_object(me),
			add_object(restored_enemy),
			set(restored_enemy.velocity_y, me.velocity_y - 600),
			; remap_attaches_from_old_to_new(me,restored_enemy),
			; restored_enemy.force_death(collide_with.damage_type)
		] where restored_enemy = replacement_object_with_preserved_attributes(me, me.basic_type)
		
	))",
},


#-------------------------- gets fired by frogatto immediately after the creature is launched --------------------------#
on_spat: "[proto_event('throwable','spat'),set(_on_back_count, 0)]",

#-------------------------- handle turning back to a regular object --------------------------#
						
on_return_to_normal: "	[	remove_object(me),
							add_object(restored_enemy),
							set(restored_enemy.velocity_y, me.velocity_y - 600),
							; remap_attaches_from_old_to_new(me,restored_enemy),
						] where restored_enemy = replacement_object_with_preserved_attributes(me, me.basic_type)",
				

#-------------------------- handle on_back twitching --------------------------#
on_process_on_back: "[
						add(_on_back_count,1),
						if(_on_back_count > (on_back_duration*3)/4,
							set(brightness, if(cycle%6 > 2, 256, 512))
						),
						annul_ground_velocity_if_nearly_at_rest
					]",
on_enter_on_back_anim: "[set(me.solid_dimensions_in, default_solid_dimensions)]",


on_bounced_on: "if(animation = 'on_back', force_death())",

on_end_anim: "if(_on_back_count > on_back_duration, fire_event('return_to_normal'), if(is_standing and 'on_back' in available_animations, animation('on_back'), animation(animation)))",


animation: [
	{
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		id: "thrown",
		thrown_area: "all",
		duration: 60,
		frames: 1,
		body_area: ["solid","all"],
	},
	{
		accel_x: 0,
		accel_y: 80,
		pad: 3,
		id: "on_back",
		frames: 2,
		duration: 5,
		body_area: ["solid","all"],
	},
],
}
